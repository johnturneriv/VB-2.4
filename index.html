<!-- TURNERROSSA VANITY BUILDER 2.0 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Turnerrossa Vanity Builder 2.0</title>

    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- =========================================================== -->
    <!-- === SECTION: GLOBAL CSS (DESKTOP + MOBILE)                === -->
    <!-- =========================================================== -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Raleway', sans-serif;
        }

        body {
            background: #f7f8f9;
            color: #222;
            overflow-x: hidden;
        }

        /* FIELD SYSTEM (auto sizing, no strict columns) */
        .field-row {
            display: flex;
            flex-wrap: wrap;
            gap: 18px 24px;
            margin-bottom: 18px;
        }

        .field {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-width: 140px;
            max-width: 320px;
        }

        .field-note {
            font-size: 11px;
            color: #1373d6;
            /* your blue */
            margin-top: 4px;
            display: none;
            /* important: hidden by default */
        }



        .field.sm {
            max-width: 120px;
        }

        .field.md {
            max-width: 240px;
        }

        .field.lg {
            max-width: 360px;
        }

        .field label {
            margin-bottom: 6px;
            font-size: 14px;
            text-transform: lowercase;
        }

        /* Page 5: ensure dynamic rows align horizontally like other pages */
        #page5 .field-row {
            align-items: flex-end;
        }

        #page5 .field-card {
            margin-bottom: 32px;
        }



        .section-selected {
            stroke: #3b82f6;
            stroke-width: 2;
        }


        /* keep dimension labels on one line and inputs same width */
        .dimension-field label[for="height"] {
            white-space: nowrap;
        }

        .dimension-field input#width,
        .dimension-field input#height,
        .dimension-field input#depth {
            min-width: 240px;
            /* big enough so the long height label doesn't wrap */
        }

        .field-error {
            min-height: 14px;
            margin-top: 4px;
            font-size: 11px;
            color: #c0483a;
            /* subtle red for errors */
        }


        /* Prevent labels from wrapping into two lines */
        .field label {
            white-space: nowrap;
        }


        .field input,
        .field select {
            padding: 9px 12px;
            border-radius: 7px;
            border: 1px solid #ccc;
            font-size: 14px;
            width: 100%;
        }

        /* DESKTOP LAYOUT */
        #desktop-layout {
            display: flex;
            width: 100%;
            min-height: 100vh;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 180px;
            background: #ffffff;
            border-right: 1px solid #e5e5e5;
            padding-top: 30px;
            position: fixed;
            top: 0;
            bottom: 0;
            overflow-y: auto;
        }

        #sidebar .nav-item {
            padding: 12px 16px;
            font-size: 15px;
            text-transform: lowercase;
            cursor: pointer;
            color: #444;
            border-left: 3px solid transparent;
        }

        #sidebar .nav-item:hover {
            background: #f1f3f5;
        }

        #sidebar .nav-item.active {
            background: #e9ebee;
            border-left: 3px solid #1a73e8;
            color: #000;
            font-weight: 600;
        }

        /* MAIN PAGE AREA */
        #page-container {
            margin-left: 180px;
            padding: 30px;
            width: calc(100% - 180px);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* hide per-page nav bars; we use one global nav under the drawing */
        .page .nav-buttons {
            display: none;
        }

        /* =========================
   PRICE UI
========================= */

        .price-wrapper {
            position: relative;
            margin-right: auto;
            /* pushes buttons right */
        }


        .price-breakdown {
            position: absolute;
            bottom: 48px;
            left: 0;
            width: 280px;
            background: #ffffff;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
            z-index: 50;
        }

        .price-breakdown.hidden {
            display: none;
        }

        .price-breakdown h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 6px;
        }

        .price-line {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .price-line.extra {
            padding-left: 10px;
        }

        .price-total {
            font-weight: 600;
            border-top: 1px solid #e5e7eb;
            padding-top: 6px;
            margin-top: 8px;
        }


        /* Field card UI */
        .field-card {
            background: #fff;
            padding: 22px 24px;
            margin-bottom: 32px;
            border-radius: 14px;
            box-shadow: 0px 3px 12px rgba(0, 0, 0, 0.05);
        }

        .field-card h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 18px;
            text-transform: lowercase;
        }

        /* NAV BUTTONS */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .nav-split {
            justify-content: space-between;
        }

        .nav-left,
        .nav-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* =========================
   PRICE MODAL OVERLAY
========================= */

        .price-modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .price-modal.hidden {
            display: none;
        }

        .price-modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
        }

        .price-modal-card {
            position: relative;
            background: #ffffff;
            max-width: 360px;
            width: calc(100% - 32px);
            margin: 80px auto;
            border-radius: 14px;
            padding: 20px 22px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        }

        .price-modal-card h3 {
            margin: 0 0 14px 0;
            font-size: 18px;
            font-weight: 600;
            text-transform: lowercase;
        }

        .price-modal-close {
            margin-top: 16px;
            width: 100%;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            background: #1a73e8;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        /* =========================
   PRICE BUTTON
========================= */

        .price-button {
            background: #1a73e8;
            /* same blue as next */
            color: #fff;
            border: none;
            padding: 10px 20px;
            /* EXACT match */
            border-radius: 8px;
            /* EXACT match */
            font-size: 14px;
            /* EXACT match */
            cursor: pointer;
            text-transform: lowercase;
            display: flex;
            align-items: center;
        }


        .price-button:hover {
            background: #15803d;
            /* darker green */
        }

        .price-button:active {
            background: #15803d;
        }

        .price-value {
            font-weight: 700;
            margin-left: 6px;
        }


        .nav-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background: #1a73e8;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
        }

        .nav-buttons button:disabled {
            background: #b0b0b0;
        }

        .nav-buttons .back {
            background: #999;
        }

        /* DRAWING PANEL */
        #drawing-panel {
            background: #ffffff;
            padding: 20px;
            margin-top: 40px;
            border-radius: 14px;
            box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.05);
            display: none;
            /* shown on page 3+ */
            min-height: 420px;
            height: auto;

            overflow-x: auto;
            /* ðŸ”‘ SCROLL CONTAINER */
            overflow-y: hidden;
        }

        /* DESKTOP SVG SIZE CONSTRAINT */
        #drawing-panel #vanityDrawing {
            display: block;
            width: auto;
            height: 420px;
            /* desktop visual target */
            max-height: 70vh;
            /* prevents giant small vanities */
            background: #fff;
        }

        #drawing-panel {
            background: rgba(255, 0, 0, 0.12) !important;
            outline: 2px solid rgba(255, 0, 0, 0.85) !important;
        }

        #drawing-panel::before {
            content: "DESKTOP DRAWING PANEL";
            display: block;
            font-size: 12px;
            padding: 4px 6px;
        }


        @media (max-width: 768px) {

            #drawing-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;

                height: 33vh;
                /* ðŸ”‘ bottom third */
                min-height: 220px;

                margin: 0;
                border-radius: 0;
                padding: 10px;

                display: block;
                z-index: 100;



            }

            #vanityDrawing {
                height: 100%;
            }
        }



        #vanityDrawing {
            touch-action: none;
            /* required for pinch */
            transform-origin: center center;
        }



        /* MOBILE MINI-APP */
        #mobile-app.hidden {
            display: none;
        }

        #mobile-app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            z-index: 9999;
            display: flex;
            flex-direction: column;
        }

        #mobile-header {
            height: 52px;
            display: flex;
            align-items: center;
            padding: 0 14px;
            border-bottom: 1px solid #eaeaea;
        }

        #mobile-step-container {
            flex: 1;
            padding: 18px;
            overflow-y: auto;
        }



        #mobile-drawing {
            height: 230px;
            background: #fafafa;
            border-top: 1px solid #eaeaea;
            padding: 10px;
            background: rgba(0, 120, 255, 0.18) !important;
            outline: 2px solid rgba(0, 120, 255, 0.9) !important;

        }

        #mobile-drawing::before {
            content: "MOBILE DRAWING";
            display: block;
            font-size: 12px;
            padding: 4px 6px;
        }


        #mobileVanityDrawing {
            width: 100%;
            height: 100%;
        }

        /* =========================
   MOBILE MODE SWITCH
========================= */

        @media (max-width: 768px) {

            /* MOBILE: show the real (desktop) app layout */
            #desktop-layout {
                display: flex;
            }

            /* MOBILE: keep the mini app hidden for now */
            #mobile-app {
                display: none;
            }

            /* MOBILE DRAWING ALWAYS VISIBLE AT BOTTOM */
            #mobile-drawing {
                flex-shrink: 0;
            }

            /* MOBILE SVG FITS ITS CONTAINER */
            #mobileVanityDrawing {
                width: 100%;
                height: 100%;
            }
        }

        #mobile-nav {
            display: flex;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid #ddd;
            background: #fff;
        }

        .mobile-nav-btn {
            flex: 1;
            padding: 14px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #f7f7f7;
        }

        .mobile-nav-btn.primary {
            background: #000;
            color: #fff;
            border-color: #000;
        }
    </style>
</head>

<body>

    <div id="desktop-layout">

        <aside id="sidebar">
            <div class="nav-item active" data-page="page1">your info</div>
            <div class="nav-item" data-page="page2">vanity details</div>
            <div class="nav-item" data-page="page3">layout & style</div>
            <div class="nav-item" data-page="page4">further customization</div>
            <div class="nav-item" data-page="page5">materials & finish</div>
            <div class="nav-item" data-page="page6">summary</div>
        </aside>

        <main id="page-container">

            <!-- PAGE 1 -->
            <section id="page1" class="page active">
                <div class="field-card">
                    <h2>welcome</h2>
                    <p class="subtitle" style="margin-bottom:20px;">
                        start by telling me who this vanity is for and where it will be installed.
                    </p>

                    <div class="field-row">
                        <div class="field md"><label>first name</label><input id="firstName"></div>
                        <div class="field md"><label>last name</label><input id="lastName"></div>
                        <div class="field lg"><label>email</label><input id="email"></div>
                    </div>

                    <div class="field-row">
                        <div class="field md"><label>phone</label><input id="phone"></div>
                        <div class="field lg"><label>street address</label><input id="deliveryStreet"></div>
                        <div class="field md"><label>city</label><input id="deliveryCity"></div>
                        <div class="field sm"><label>state</label><input id="deliveryState"></div>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="back" disabled>back</button>
                    <button class="next" data-next="page2">next: vanity details</button>
                </div>
            </section>

            <!-- PAGE 2 -->
            <section id="page2" class="page">
                <div class="field-card">
                    <h2>vanity details</h2>

                    <!-- row 1: main size + sides + sinks -->
                    <div class="field-row">
                        <div class="field dimension-field">
                            <label for="width">width (in)</label>
                            <input id="width" type="number" min="18" step="0.25" placeholder='18" min.'>
                            <div id="widthError" class="field-error"></div>
                        </div>

                        <div class="field dimension-field">
                            <label for="height">
                                height <strong>without</strong> countertop (in)
                            </label>
                            <input id="height" type="number" min="6" step="0.25" placeholder='32â€“34.5" is standard'>
                        </div>

                        <div class="field dimension-field">
                            <label for="depth">depth (in)</label>
                            <input id="depth" type="number" min="6" step="0.25" placeholder='21â€“22" is standard'>
                        </div>


                        <div class="field sm">
                            <label>sink count</label>
                            <select id="sinkCount">
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                            </select>
                        </div>
                        <div class="field" id="sinkPositionField" style="display:none;">
                            <label for="sinkPosition">sink position</label>
                            <select id="sinkPosition" name="sinkPosition">
                                <option value="center">centered</option>
                                <option value="left">left</option>
                                <option value="right">right</option>
                            </select>
                        </div>

                    </div>

                    <!-- row 2: floating / shelf / makeup -->
                    <div class="field-row">
                        <div class="field">
                            <label for="doorDrawerPreset">door and drawer style</label>
                            <select id="doorDrawerPreset">
                                <option value="slab">slab</option>
                                <option value="shaker">shaker</option>
                                <option value="double-shaker">double shaker</option>
                                <option value="slab-shaker">slab/shaker combo</option>
                                <option value="slab-double-shaker">slab/double shaker combo</option>
                            </select>
                        </div>


                        <div class="field md">
                            <label>which sides are visible?</label>
                            <select id="visibleSides">
                                <option value="none" selected>no sides visible</option>
                                <option value="left">left side</option>
                                <option value="right">right side</option>
                                <option value="both">both sides</option>
                            </select>
                        </div>

                        <div class="field">
                            <label for="visibleSideStyle">visible side style</label>
                            <select id="visibleSideStyle" name="visibleSideStyle">
                                <option value="slab" selected>slab</option>
                                <option value="shaker">shaker</option>
                                <option value="double-shaker">double shaker</option>
                            </select>
                        </div>

                        <div class="field md">
                            <label>floating?</label>
                            <select id="floating">
                                <option value="false">no</option>
                                <option value="true">yes</option>
                            </select>
                        </div>

                        <div class="field" id="shelfBelowField">
                            <label for="shelfBelow">add shelf below?</label>
                            <select id="shelfBelow">
                                <option value="no" selected>no</option>
                                <option value="yes">yes</option>
                            </select>
                        </div>

                        <!-- MAKEUP DESK -->
                        <div class="field">
                            <label>makeup desk</label>
                            <select id="makeupDeskEnabled">
                                <option value="no">no</option>
                                <option value="yes">yes</option>
                            </select>
                        </div>

                        <div class="field" id="makeupDeskPositionField" style="display:none;">
                            <label>desk position</label>
                            <select id="makeupDeskPosition">
                                <option value="center">center</option>
                                <option value="left">left</option>
                                <option value="right">right</option>
                            </select>
                        </div>

                        <div class="field" id="makeupDeskWidthField" style="display:none;">
                            <label>desk width (in)</label>
                            <input id="makeupDeskWidth" type="number" step="0.25" min="24" max="36" />
                        </div>

                        <div class="field" id="makeupDeskHeightField" style="display:none;">
                            <label>desk drawer height (in)</label>
                            <input id="makeupDeskHeight" type="number" step="0.25" min="3" max="5" />
                        </div>

                    </div>
                </div>

                <!-- nav buttons BELOW the card -->
                <div class="nav-buttons">
                    <button class="back" data-back="page1">back</button>
                    <button class="next" data-next="page3">next: layout & style</button>
                </div>
            </section>


            <!-- PAGE 3 -->
            <section id="page3" class="page">
                <div class="field-card">
                    <h2>layout & style</h2>

                    <!-- row 1: layout + styles + drawer widths -->
                    <div class="field-row">
                        <div class="field md">
                            <label>configuration</label>
                            <select id="layoutPreset">
                                <option value="default">default layout</option>
                            </select>
                        </div>

                        <div class="field md">
                            <label>door style</label>
                            <select id="doorStyle">
                                <option value="shaker">shaker</option>
                                <option value="slab">slab</option>
                                <option value="double-shaker">double shaker</option>
                            </select>
                        </div>

                        <div class="field md">
                            <label>drawer style</label>
                            <select id="drawerStyle">
                                <option value="slab">slab</option>
                                <option value="shaker">shaker</option>
                                <option value="double-shaker">double shaker</option>
                                <option value="slab-shaker">slab top + shaker</option>
                                <option value="slab-double-shaker">slab top + double shaker</option>
                            </select>
                        </div>



                        <!-- drawer width controls (shown/hidden by JS) -->
                        <div class="field sm" id="drawerWidthSingleField" style="display:none;">
                            <label>drawer width</label>
                            <input type="number" id="drawerWidthSingle" step="0.25">
                        </div>

                        <div class="field sm" id="drawerWidthOuterField" style="display:none;">
                            <label>outside drawer width</label>
                            <input type="number" id="drawerWidthOuter" step="0.25">
                        </div>

                        <div class="field sm" id="drawerWidthCenterField" style="display:none;">
                            <label>center drawer width</label>
                            <input type="number" id="drawerWidthCenter" step="0.25">
                        </div>

                        <div id="drawerWidthTwoSectionField" class="field" style="display:none;">
                            <label>drawer width</label>
                            <input id="drawerWidthTwoSection" type="number" step="0.25" min="1">
                        </div>
                    </div>

                    <!-- row 2: bottom detail + toe/open-below height -->
                    <div class="field-row">
                        <div class="field">
                            <label for="topDrawerHeightPreset">top drawer height</label>
                            <select id="topDrawerHeightPreset">
                                <option value="equal">equal to others</option>
                                <option value="5">5"</option>
                                <option value="5.5">5.5"</option>
                                <option value="6">6"</option>
                                <option value="6.5">6.5"</option>
                                <option value="7">7"</option>
                                <option value="7.5">7.5"</option>
                                <option value="8">8"</option>
                            </select>
                        </div>

                        <div class="field sm" id="bottomDetailField">
                            <label>bottom detail</label>
                            <select id="bottomDetail">
                                <option value="toe-kick">toe kick</option>
                                <option value="open-below">open below</option>
                            </select>
                        </div>

                        <div class="field sm" id="bottomHeightField">
                            <label id="toeKickLabel">toe kick height (in)</label>
                            <input type="number" id="toeKickHeight">
                        </div>

                        <!-- rails between drawers -->
                        <div class="field sm" id="drawerRailsModeField">
                            <label for="drawerRailsMode">rails between drawers</label>
                            <select id="drawerRailsMode">
                                <option value="none" selected>none</option>
                                <option value="top">top only</option>
                                <option value="all">between all drawers</option>
                            </select>
                        </div>




                    </div>
                </div>

                <!-- nav buttons BELOW the card -->
                <div class="nav-buttons">
                    <button class="back" data-back="page2">back</button>
                    <button class="next" data-next="page4">next: further customization</button>
                </div>
            </section>


            <!-- PAGE 4 -->
            <section id="page4" class="page">
                <div class="field-card">
                    <h2>further customization</h2>

                    <div class="field-row">

                        <!-- SPACE ABOVE SHELF -->
                        <div id="shelfSpaceField" class="field sm">
                            <label for="shelfSpaceIn">space above shelf (in)</label>
                            <input id="shelfSpaceIn" type="number" step="0.25" min="6" max="12" value="8">
                        </div>

                        <!-- SHELF THICKNESS (only appears when shelfBelow=yes) -->
                        <div class="field sm" id="shelfThicknessField" style="display: none;">
                            <label for="shelfThickness">shelf thickness (in)</label>
                            <select id="shelfThickness">
                                <option value="1.5">1.5"</option>
                                <option value="2" selected>2"</option>
                                <option value="2.5">2.5"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>


                        <!-- ======================= -->
                        <!--     COMBINED FIELDS     -->
                        <!-- ======================= -->

                        <!-- STILE OPTIONS -->
                        <div class="field sm" id="frameStileWidthField">
                            <label>stile options</label>
                            <select id="frameStileWidth">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5" selected>1 1/2"</option>
                                <option value="2">2"</option>
                            </select>

                            <!-- Keep your blue note -->
                            <div id="drawerRailsNote" class="field-note">
                                rails between drawers need stiles!
                            </div>
                        </div>

                        <!-- TOP RAIL OPTIONS -->
                        <div class="field sm">
                            <label>top rail options</label>
                            <select id="frameTopRailHeight">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5" selected>1 1/2"</option>
                                <option value="2">2"</option>
                            </select>
                        </div>

                        <!-- BOTTOM RAIL OPTIONS -->
                        <div class="field sm">
                            <label>bottom rail options</label>
                            <select id="frameBottomRailHeight">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2" selected>2"</option>
                                <option value="2.5">2 1/2"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>


                        <!-- DIVIDING RAIL HEIGHT -->
                        <div class="field sm" id="drawerRailHeightField">
                            <label for="drawerRailHeightIn">dividing rail height</label>
                            <select id="drawerRailHeightIn">
                                <option value="0.75">3/4"</option>
                                <option value="1" selected>1"</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2">2"</option>
                            </select>
                        </div>

                        <!-- LEG WIDTH -->
                        <div class="field sm">
                            <label>leg width (in)</label>
                            <select id="frameLegWidth">
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2" selected>2"</option>
                                <option value="2.5">2 1/2"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>

                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page3">back</button>
                    <button class="next" data-next="page5">next: materials & finish</button>
                </div>
            </section>

            <!-- ======================= -->
            <!--        PAGE 5           -->
            <!-- ======================= -->
            <section id="page5" class="page">
                <div class="field-card">
                    <h2>materials & finish</h2>

                    <!-- THIS IS THE ONLY ROW -->
                    <div id="finishRow" class="field-row">

                        <!-- ALWAYS VISIBLE -->
                        <div class="field md">
                            <label>finish type</label>
                            <select id="finishType">
                                <option value="">select finish type</option>
                                <option value="wood">wood grain</option>
                                <option value="paint">painted</option>
                            </select>
                        </div>

                        <!-- WOOD FIELDS -->
                        <div class="field md wood-field" style="display:none;">
                            <label>wood species</label>
                            <select id="woodSpecies">
                                <option value="">select species</option>
                                <option value="white-oak">white oak (most popular)</option>
                                <option value="walnut">walnut</option>
                                <option value="mahogany">mahogany</option>
                                <option value="cherry">cherry</option>
                                <option value="maple">maple</option>
                                <option value="red-oak">red oak</option>
                            </select>
                        </div>

                        <div class="field md wood-field" style="display:none;">
                            <label>stain options</label>
                            <select id="stainOption">
                                <option value="">select stain</option>
                                <option value="clear">hardwood with clear finish</option>
                                <option value="natural-seal">bona "natural seal"</option>
                                <option value="country-white">country white</option>
                                <option value="classic-gray">classic gray</option>
                                <option value="custom-stain">custom stain (formula required)</option>
                            </select>
                        </div>

                        <!-- PAINT FIELDS -->
                        <div class="field md paint-field" style="display:none;">
                            <label>finish options</label>
                            <select id="paintFinish">
                                <option value="">select paint finish</option>
                                <option value="custom">painted custom color</option>
                                <option value="primed">primed wood, ready for paint</option>
                                <option value="raw">raw wood, ready for paint</option>
                            </select>
                        </div>

                        <div class="field lg paint-field" id="customColorField" style="display:none;">
                            <label>custom color name/brand/code</label>
                            <input id="customColorInput" type="text" placeholder="e.g. BM White Dove OC-17">
                            <div class="field-note">omit if you're not sure yet</div>
                        </div>

                        <div class="field md paint-field" id="primerColorField" style="display:none;">
                            <label>primer color</label>
                            <select id="primerColor">
                                <option value="">choose primer</option>
                                <option value="white">white primer (lighter colors)</option>
                                <option value="gray">gray primer (darker colors)</option>
                            </select>
                        </div>

                    </div><!-- END ONE ROW -->

                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page4">back</button>
                    <button class="next" data-next="page6">next: summary</button>
                </div>
            </section>



            <!-- PAGE 6 -->
            <section id="page6" class="page">
                <div class="field-card">
                    <h2>summary</h2>
                    <p>summary details will go here</p>
                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page5">back</button>
                    <button class="next" disabled>done</button>
                </div>
            </section>

            <!-- drawing placeholder (no drawing logic yet) -->
            <div id="drawing-panel">
                <svg id="vanityDrawing" preserveAspectRatio="xMinYMin meet"></svg>
            </div>
            <!-- GLOBAL NAV BELOW DRAWING -->
            <div id="global-nav" class="nav-buttons nav-split">
                <div class="nav-left">
                    <button id="global-back" class="back">back</button>
                </div>

                <div class="nav-right">
                    <button id="price-button" class="price-button">
                        current price:
                        <span id="price-value" class="price-value">$0</span>
                    </button>


                    <button id="global-next" class="next">next</button>
                </div>
            </div>




        </main>

    </div>

    <!-- MOBILE APP -->
    <div id="mobile-app" class="hidden">
        <div id="mobile-header">

            <span class="mobile-title">vanity builder</span>
        </div>



        <div id="mobile-nav">
            <button id="mobile-back" class="mobile-nav-btn">back</button>
            <button id="mobile-next" class="mobile-nav-btn primary">next</button>
        </div>


        <div id="mobile-drawing">
            <svg id="mobileVanityDrawing"></svg>
        </div>
    </div>
    <script>
        var currentPageIndex = 0;


        let initialDrawDone = false;
        let railsModeBeforeStilesOff = null;

        // =====================================================
        // SECTION SELECTION STATE (authoritative)
        // =====================================================

        // null = no section selected
        // number = index into model.sections
        let selectedSectionIndex = null;

        // --------------------------------------------------
        // PERSISTENT SECTION OVERRIDES (survive redraws)
        // --------------------------------------------------
        let sectionOverrides = {};

        let DRAWING_ZOOM = 1; // 1 = default


        const FRAME_DEFAULTS = {
            legWidthIn: 2.0,
            stileWidthIn: 1.5,
            topRailHeightIn: 1.5,
            bottomRailHeightIn: 2.0
        };
        const DEFAULT_DRAWER_RAIL_HEIGHT_IN = 1.0;


        const STROKE = .6;  // master line thickness
        const DRAWING_SCALE = .9; // 1 = current size, <1 smaller, >1 bigger
        const STRUCTURE_COLOR = "#000";     // Cabinet frame, legs, rails, etc.
        const DIM_COLOR = "#777";           // VB1-style gray for dim lines + ticks
        const DIM_STROKE = 0.6;         // thinner lines for dims / floor
        const DASH_PATTERN = "2 2";     // slightly tighter dash than VB1
        const SINK_COLOR = "#1a73e8";   // blue for sinks + sink dims
        const SINK_STROKE = 0.5;        // a little thinner than structure lines
        const SINK_DASH = "2 2";        // dashed outline for sinks
        const FLOAT_TOP_HEIGHT_IN = 34;


        // === Shelf-below constants ===
        const SHELF_THICKNESS_IN = 2;          // fixed 2" thick face
        const DEFAULT_SHELF_SPACE_IN = 8;      // default space above shelf to bottom rail
        const MIN_SHELF_SPACE_IN = 6;
        const MAX_SHELF_SPACE_IN = 12;


        // Track whether the user has manually changed drawer widths.
        // Programmatic seeding won't flip these.
        const drawerOverrideFlags = {
            single: false,
            outer: false,
            center: false,
            twoSection: false
        };

        // Track which drawer group the user last edited ("single" | "outer" | "center")
        let lastDrawerEdited = null;


        // ========================================================
        // SINK DEFAULTS + SECTION TWEAKS BASED ON LENGTH / LAYOUT
        // ========================================================

        /**
         * Decide a good default sink size (bowl width in inches)
         * based on vanity length and sink count.
         *
         *  - Single sink:
         *      18"â€“21"  â†’ 15" sink
         *      >21"â€“47" â†’ 18" sink
         *      â‰¥48"     â†’ 20" sink
         *
         *  - Double sink:
         *      50"â€“54"  â†’ 15" sinks
         *      >54"â€“68" â†’ 18" sinks
         *      â‰¥69"     â†’ 20" sinks
         */
        function chooseDefaultSinkSize(lengthIn, sinkCount) {
            if (sinkCount === 1) {
                if (lengthIn <= 21) return 15;   // smallest single: 18" vanity
                if (lengthIn <= 47) return 18;   // 22.5"â€“42" examples
                return 20;                       // 48"+ singles
            }

            if (sinkCount === 2) {
                if (lengthIn <= 54) return 15;   // 50" double
                if (lengthIn <= 68) return 18;   // 60"â€“66" doubles
                return 20;                       // 72"+ doubles
            }

            // Fallback (just in case)
            return 20;
        }



        /* ======================================================================= */
        /* === SECTION: DESKTOP SIDEBAR NAVIGATION LOGIC                        === */
        /* ======================================================================= */

        const sidebarItems = document.querySelectorAll("#sidebar .nav-item");
        const pages = document.querySelectorAll(".page");

        function setDrawingPanelVisibility(pageId) {
            const drawingPanel = document.getElementById("drawing-panel");
            if (!drawingPanel) return;

            const isMobile = window.matchMedia("(max-width: 768px)").matches;

            // ðŸ”’ HARD RULE: never show DESKTOP drawing panel on mobile (fixes page1 too)
            if (isMobile) {
                drawingPanel.style.display = "none";
                return;
            }

            // desktop behavior
            if (pageId === "page1" || pageId === "page2") {
                drawingPanel.style.display = "none";
            } else {
                drawingPanel.style.display = "block";
            }
        }


        sidebarItems.forEach(item => {
            item.addEventListener("click", () => {
                const pageId = item.getAttribute("data-page");
                goToPage(pageId);
            });
        });

        function updateGlobalNavVisibility(pageId) {
            const backBtn = document.getElementById("global-back");
            const priceBtn = document.getElementById("price-button");

            const isMobile = window.matchMedia("(max-width: 768px)").matches;

            if (backBtn) {
                const hideBack = (pageId === "page1"); // no back on page1
                backBtn.style.display = hideBack ? "none" : "";
                backBtn.disabled = hideBack;
                if (hideBack) backBtn.textContent = "back";
            }


            if (priceBtn) {
                priceBtn.style.display =
                    (pageId === "page1" || pageId === "page2") ? "none" : "";
            }
        }


        /* ======================================================================= */
        /* === SECTION: NEXT/BACK BUTTONS (GLOBAL BELOW DRAWING)                 === */
        /* ======================================================================= */

        /** central helper: switch to a given page id */
        function goToPage(pageId) {
            if (!pageId) return;

            // normalize pages into a real array (ONCE)
            const pagesArr = Array.from(pages);

            // sidebar highlight
            sidebarItems.forEach(i => {
                i.classList.toggle(
                    "active",
                    i.getAttribute("data-page") === pageId
                );
            });

            // activate correct page (DESKTOP SOURCE OF TRUTH)
            pagesArr.forEach(p => p.classList.remove("active"));
            const pageEl = document.getElementById(pageId);
            if (pageEl) pageEl.classList.add("active");

            // update index (AUTHORITATIVE)
            const idx = pagesArr.findIndex(p => p.id === pageId);
            currentPageIndex = idx >= 0 ? idx : 0;

            updateGlobalNavVisibility(pageId);
            updatePriceVisibility(pageId);
            setDrawingPanelVisibility(pageId);
            updateDrawing();
            syncGlobalNavState();

            // ðŸ”‘ MOBILE MUST MIRROR DESKTOP AFTER STATE CHANGE
            updateMobileDrawingVisibility();

        }

        function setupMobileNavHandlers() {
            const backBtn = document.getElementById("mobile-back");
            const nextBtn = document.getElementById("mobile-next");
            if (!backBtn || !nextBtn) return;

            backBtn.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localBack = activePage.querySelector(".nav-buttons .back");
                if (!localBack || localBack.disabled) return;

                const backPage = localBack.getAttribute("data-back");
                if (!backPage) return;

                goToPage(backPage);
            });

            nextBtn.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localNext = activePage.querySelector(".nav-buttons .next");
                if (!localNext || localNext.disabled) return;

                const nextPage = localNext.getAttribute("data-next");
                if (!nextPage) return;

                goToPage(nextPage);
            });
        }


        // =======================================================
        // INITIAL PRICE VISIBILITY (run once on page load)
        // =======================================================
        const activePage = document.querySelector(".page.active")?.id;
        if (activePage) {
            updatePriceVisibility(activePage);
        }

        function syncGlobalNavState() {
            const globalBack = document.getElementById("global-back");
            const globalNext = document.getElementById("global-next");
            if (!globalBack || !globalNext) return;

            const activePage = document.querySelector(".page.active");
            if (!activePage) {
                globalBack.disabled = true;
                globalNext.disabled = true;
                globalBack.textContent = "back";
                globalNext.textContent = "next";
                return;
            }

            // Helper: use the target page's <h2> as the label (fallback to "previous"/"next")
            function getPageTitle(pageId) {
                if (!pageId) return "";
                const el = document.getElementById(pageId);
                const h2 = el ? el.querySelector("h2") : null;
                return (h2?.textContent || "").trim();
            }

            const localNav = activePage.querySelector(".nav-buttons");
            const localBack = localNav ? localNav.querySelector(".back") : null;
            const localNext = localNav ? localNav.querySelector(".next") : null;

            // -----------------
            // BACK button label
            // -----------------
            if (localBack) {
                globalBack.disabled = !!localBack.disabled;

                const backPageId = localBack.getAttribute("data-back") || "";
                const backTitle = getPageTitle(backPageId);

                if (!globalBack.disabled && backTitle) {
                    globalBack.textContent = `back: ${backTitle.toLowerCase()}`;
                } else {
                    globalBack.textContent = "back";
                }
            } else {
                globalBack.disabled = true;
                globalBack.textContent = "back";
            }

            // -----------------
            // NEXT button label (keep your current behavior)
            // -----------------
            if (localNext) {
                globalNext.disabled = !!localNext.disabled;
                globalNext.textContent = localNext.textContent || "next";
            } else {
                globalNext.disabled = true;
                globalNext.textContent = "next";
            }
        }


        // hook up the bottom nav buttons
        (function attachGlobalNavHandlers() {
            const globalBack = document.getElementById("global-back");
            const globalNext = document.getElementById("global-next");
            if (!globalBack || !globalNext) return;

            globalBack.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localBack = activePage.querySelector(".nav-buttons .back");
                if (!localBack || localBack.disabled) return;

                const backPage = localBack.getAttribute("data-back");
                if (!backPage) return;

                goToPage(backPage);
            });

            globalNext.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localNext = activePage.querySelector(".nav-buttons .next");
                if (!localNext || localNext.disabled) return;

                const nextPage = localNext.getAttribute("data-next");
                if (!nextPage) return;

                goToPage(nextPage);
            });
        })();

        /* ======================================================================= */
        /* === SECTION: MOBILE MODE DETECTION                                   === */
        /* ======================================================================= */

        // TEMP: keep the real app visible on mobile.
        // Your current #mobile-app does not render pages/forms, so hiding #desktop-layout breaks mobile.
        function checkMobileMode() {
            // Disabled: mobile/desktop visibility is controlled by CSS now.
            // Leaving this avoids inline styles fighting your media queries.
        }

        /* ======================================================================= */
        /* === SECTION: DRAWING ENGINE â€“ V1 (OUTLINE ONLY)                       === */
        /* ======================================================================= */

        function ensureSvgSetup() {
            const svg = getActiveDrawingSvg();   // âœ… mobile uses #mobileVanityDrawing
            if (!svg) return;

            svg.setAttribute("viewBox", "0 0 900 400");
            svg.setAttribute("preserveAspectRatio", "xMinYMin meet");
            svg.style.display = "block";
        }


        // read optional frame overrides from inputs (if you add them later)
        function readFrameOverrides() {
            const overrides = {};

            const leg = Number(document.getElementById("frameLegWidth")?.value);
            if (leg > 0) overrides.legWidthIn = leg;

            const stile = Number(document.getElementById("frameStileWidth")?.value);
            if (stile > 0) overrides.stileWidthIn = stile;

            const topRail = Number(document.getElementById("frameTopRailHeight")?.value);
            if (topRail > 0) overrides.topRailHeightIn = topRail;

            const bottomRail = Number(document.getElementById("frameBottomRailHeight")?.value);
            if (bottomRail > 0) overrides.bottomRailHeightIn = bottomRail;

            return overrides;
        }

        // =======================================================
        // PRICING ADJUSTMENTS (easy to change later)
        // =======================================================
        const PRICING = {
            BASE_PER_FOOT: 900,

            SHELF_BELOW: 500,
            INTERIOR_SHELF: 50,        // per shelf
            DRAWERS_UNDER_SINK: 450,   // per sink
            MAKEUP_DESK: 300,
            OPEN_BELOW: 100,

            RETURN_SIDE: 250           // per exposed side
        };

        function computePriceBreakdown(model) {
            const breakdown = {
                base: 0,
                extras: [],
                total: 0
            };

            // -----------------------
            // BASE PRICE
            // -----------------------
            const basePrice = (model.widthIn / 12) * PRICING.BASE_PER_FOOT;
            breakdown.base = Math.round(basePrice);

            // -----------------------
            // SHELF BELOW
            // -----------------------
            if (model.shelfBelow) {
                breakdown.extras.push({
                    label: "Shelf below",
                    amount: PRICING.SHELF_BELOW
                });
            }

            // -----------------------
            // INTERIOR SHELVES
            // -----------------------
            const interiorShelfCount = Object.values(model.sectionOverrides || {})
                .filter(o => o?.interiorShelf === true).length;

            if (interiorShelfCount > 0) {
                breakdown.extras.push({
                    label: `Interior shelf Ã—${interiorShelfCount}`,
                    amount: interiorShelfCount * PRICING.INTERIOR_SHELF
                });
            }

            // -----------------------
            // DRAWERS UNDER SINK
            // only when ALL drawers
            // -----------------------
            const allDrawers =
                model.sections?.length &&
                model.sections.every(sec => sec.role === "drawer");

            if (allDrawers && model.sinkCount > 0) {
                breakdown.extras.push({
                    label: `Drawers under sink Ã—${model.sinkCount}`,
                    amount: model.sinkCount * PRICING.DRAWERS_UNDER_SINK
                });
            }

            // -----------------------
            // MAKEUP DESK
            // -----------------------
            if (model.hasMakeupDesk) {
                breakdown.extras.push({
                    label: "Makeup desk",
                    amount: PRICING.MAKEUP_DESK
                });
            }

            // -----------------------
            // OPEN BELOW
            // -----------------------
            if (model.bottomDetail === "open-below" || model.floating) {
                breakdown.extras.push({
                    label: "Open below",
                    amount: PRICING.OPEN_BELOW
                });
            }

            // -----------------------
            // RETURNS / VISIBLE SIDES
            // -----------------------
            if (model.visibleSides === "left") {
                breakdown.extras.push({ label: "Left return", amount: PRICING.RETURN_SIDE });
            } else if (model.visibleSides === "right") {
                breakdown.extras.push({ label: "Right return", amount: PRICING.RETURN_SIDE });
            } else if (model.visibleSides === "both") {
                breakdown.extras.push({
                    label: "Left + right returns",
                    amount: PRICING.RETURN_SIDE * 2
                });
            }

            // -----------------------
            // TOTAL
            // -----------------------
            const extrasTotal = breakdown.extras.reduce((sum, e) => sum + e.amount, 0);
            breakdown.total = breakdown.base + extrasTotal;

            return breakdown;
        }

        function computeCurrentPrice(model) {
            return computePriceBreakdown(model).total;
        }

        function updatePriceUI(model) {
            const breakdown = computePriceBreakdown(model);

            const amountEl = document.getElementById("price-amount");
            const panel = document.getElementById("price-breakdown");

            if (!amountEl || !panel) return;

            amountEl.textContent = `$${breakdown.total.toLocaleString()}`;

            // Build breakdown HTML
            let html = `<h4>price summary</h4>`;

            html += `
        <div class="price-line">
            <span>base price</span>
            <span>$${breakdown.base.toLocaleString()}</span>
        </div>
    `;

            if (breakdown.extras.length) {
                html += `<h4 style="margin-top:10px">extras</h4>`;
                breakdown.extras.forEach(e => {
                    html += `
                <div class="price-line extra">
                    <span>${e.label}</span>
                    <span>+$${e.amount.toLocaleString()}</span>
                </div>
            `;
                });
            }

            html += `
        <div class="price-line price-total">
            <span>total</span>
            <span>$${breakdown.total.toLocaleString()}</span>
        </div>
    `;

            panel.innerHTML = html;
        }


        function updatePriceVisibility(currentPageId) {
            const priceBox = document.getElementById("priceBox");
            if (!priceBox) return;

            // hide on page1 and page2
            const hide =
                currentPageId === "page1" ||
                currentPageId === "page2";

            priceBox.style.display = hide ? "none" : "flex";
        }


        function getDrawingScalePxPerInch() {
            const BASE_PX_PER_INCH = 10.0;   // â† your current visual size
            return BASE_PX_PER_INCH * DRAWING_ZOOM;
        }



        function computeModel() {
            const widthField = document.getElementById("width");
            const heightField = document.getElementById("height");
            const depthField = document.getElementById("depth");

            let widthInRaw = Number(widthField?.value || 0);
            let heightInRaw = Number(heightField?.value || 0);
            let depthInRaw = Number(depthField?.value || 0);

            // Spinner protection
            if (widthField?.value === "0") { widthInRaw = 30; widthField.value = "30"; }
            if (heightField?.value === "0") { heightInRaw = 34.5; heightField.value = "34.5"; }
            if (depthField?.value === "0") { depthInRaw = 22; depthField.value = "22"; }

            // Defaults
            if (!widthInRaw) widthInRaw = 30;
            if (!heightInRaw) heightInRaw = 34.5;
            if (!depthInRaw) depthInRaw = 22;

            // Snap to 1/4"
            widthInRaw = Math.round(widthInRaw * 4) / 4;
            heightInRaw = Math.round(heightInRaw * 4) / 4;
            depthInRaw = Math.round(depthInRaw * 4) / 4;

            // Clamp
            widthInRaw = Math.min(Math.max(widthInRaw, 18), 200);
            heightInRaw = Math.min(Math.max(heightInRaw, 6), 96);
            depthInRaw = Math.min(Math.max(depthInRaw, 12), 30);

            // Styles
            const doorStyle = document.getElementById("doorStyle")?.value || "shaker";
            const drawerStyle = document.getElementById("drawerStyle")?.value || "slab";
            const topDrawerHeightPreset = document.getElementById("topDrawerHeightPreset")?.value || "equal";
            const floating = document.getElementById("floating")?.value === "true";

            const visibleSideStyle = document.getElementById("visibleSideStyle")?.value || "shaker";


            // Toe kick / open-below
            const toeInput = document.getElementById("toeKickHeight");
            let rawToe = Math.round((Number(toeInput?.value || 4)) * 4) / 4;
            rawToe = Math.min(Math.max(rawToe, 2.5), 24);

            const bottomDetail = document.getElementById("bottomDetail")?.value || "toe-kick";
            const toeKickHeightIn = bottomDetail === "toe-kick"
                ? Math.min(Math.max(rawToe, 2.5), 7)
                : Math.min(Math.max(rawToe, 2.5), 24);

            // Sinks
            const sinkCount = Number(document.getElementById("sinkCount")?.value) || 0;
            const layoutPreset = document.getElementById("layoutPreset")?.value || "";
            const sinkPosition = document.getElementById("sinkPosition")?.value || "center";




            // Shelf
            let shelfBelow =
                document.getElementById("shelfBelow")?.value === "yes";

            let shelfSpaceIn = DEFAULT_SHELF_SPACE_IN;

            const makeupDeskEnabled =
                document.getElementById("makeupDeskEnabled")?.value === "yes";

            const makeupDeskPosition =
                document.getElementById("makeupDeskPosition")?.value || "center";

            let makeupDeskWidthIn =
                Number(document.getElementById("makeupDeskWidth")?.value) || 26;

            let makeupDeskHeightIn =
                Number(document.getElementById("makeupDeskHeight")?.value) || 4;

            // clamp defensively
            makeupDeskWidthIn = Math.max(24, Math.min(36, makeupDeskWidthIn));
            makeupDeskHeightIn = Math.max(3, Math.min(5, makeupDeskHeightIn));


            // Default drawer stack behavior
            const defaultDrawerStackCount = shelfBelow ? 2 : 3;

            const drawerStackConfig = {
                defaultCount: defaultDrawerStackCount,
                userOverride: null
            };

            if (shelfBelow) {
                const raw = parseFloat(document.getElementById("shelfSpaceIn")?.value);
                if (isFinite(raw)) shelfSpaceIn = raw;
                shelfSpaceIn = Math.min(Math.max(shelfSpaceIn, MIN_SHELF_SPACE_IN), MAX_SHELF_SPACE_IN);
            }

            let shelfThicknessIn = Number(document.getElementById("shelfThickness")?.value) || 2;
            shelfThicknessIn = Math.min(Math.max(shelfThicknessIn, 1.5), 3);

            // Drawer rails
            const drawerRailsMode = document.getElementById("drawerRailsMode")?.value || "none";

            let drawerRailHeightIn = parseFloat(document.getElementById("drawerRailHeightIn")?.value);
            if (!isFinite(drawerRailHeightIn) || drawerRailHeightIn <= 0)
                drawerRailHeightIn = DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            // Visible sides
            const visibleSides = document.getElementById("visibleSides")?.value || "both";

            // ============================
            // COMBINED FRAME OPTIONS
            // ============================

            // --- Stiles ---
            const stileSel = document.getElementById("frameStileWidth");
            const rawStile = stileSel?.value;
            const removeStiles = rawStile === "remove";
            const stileWidthIn = removeStiles ? 0 : Number(rawStile);

            // --- Top rail ---
            const topSel = document.getElementById("frameTopRailHeight");
            const rawTop = topSel?.value;
            const removeTopRail = rawTop === "remove";
            const topRailHeightIn = removeTopRail ? 0 : Number(rawTop);

            // --- Bottom rail ---
            const botSel = document.getElementById("frameBottomRailHeight");
            const rawBot = botSel?.value;
            const removeBottomRail = rawBot === "remove";
            const bottomRailHeightIn = removeBottomRail ? 0 : Number(rawBot);

            // Frame leg width (unchanged)
            const legWidthIn = Number(document.getElementById("frameLegWidth")?.value) || FRAME_DEFAULTS.legWidthIn;

            // Drawer width controls
            const singleDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthSingle")?.value || 0)) * 4) / 4;
            const outerDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthOuter")?.value || 0)) * 4) / 4;
            const centerDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthCenter")?.value || 0)) * 4) / 4;
            const twoSectionDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthTwoSection")?.value || 0)) * 4) / 4;

            // Final size guards
            const safeWidthIn = Math.max(widthInRaw, 18);
            const safeHeightIn = floating
                ? Math.max(heightInRaw, 14)
                : Math.max(heightInRaw, 20);

            // Floating gap
            let floatingGapIn = floating ? FLOAT_TOP_HEIGHT_IN - safeHeightIn : 0;
            if (floatingGapIn < 0) floatingGapIn = 0;

            // =====================================================
            // FIXED DRAWING SCALE (NO AUTO-FIT)
            // =====================================================

            // ðŸ”’ single source of truth
            const inchToPx = getDrawingScalePxPerInch(); // e.g. 8, later * zoom

            // Drawing height is fixed visually
            const viewH = 400;
            const bottomMargin = 45;

            // cabinet pixel size
            const cabW = safeWidthIn * inchToPx;
            const cabH = safeHeightIn * inchToPx;

            // vertical placement: keep cabinet sitting on floor line
            const floorY = viewH - bottomMargin;
            const gapPx = floating ? floatingGapIn * inchToPx : 0;

            const cabBottomY = floorY - gapPx;

            // ðŸ”’ IMPORTANT: X origin is NOT centered anymore
            // Run layout controls horizontal positioning
            const originX = 10 * inchToPx;

            const originY = cabBottomY - cabH;


            const sinkBowlWidthIn =
                sinkCount > 0 ? chooseDefaultSinkSize(safeWidthIn, sinkCount) : 0;

            // Build FRAME
            const frame = {
                legWidthIn,
                stileWidthIn,
                topRailHeightIn,
                bottomRailHeightIn,
                removeStiles,
                removeTopRail,
                removeBottomRail,
                legs: [
                    { xIn: 0 },
                    { xIn: safeWidthIn - legWidthIn }
                ]
            };

            // Build MODEL
            const model = {
                widthIn: safeWidthIn,
                heightIn: safeHeightIn,
                depthIn: depthInRaw,
                floating,
                floatingGapIn,
                toeKickHeightIn,
                bottomDetail,
                sectionOverrides,


                sinkCount,
                sinkPosition,
                sinkBowlWidthIn,
                layoutPreset,

                makeupDeskEnabled,
                makeupDeskPosition,
                makeupDeskWidthIn,
                makeupDeskHeightIn,


                doorStyle,
                drawerStyle,
                topDrawerHeightPreset,
                drawerStackConfig,

                drawerRailsMode,
                drawerRailHeightIn,

                drawerControls: {
                    singleDrawerWidthIn,
                    outerDrawerWidthIn,
                    centerDrawerWidthIn,
                    twoSectionDrawerWidthIn
                },

                visibleSides,
                visibleSideStyle,

                shelfBelow,
                shelfSpaceIn,
                shelfThicknessIn,

                scale: { inchToPx, originX, originY },
                frame
            };

            // Compute sections now that model exists
            model.sections = computeSections(model);

            // =====================================================
            // HARD RULE: rails require stiles on multi-section
            // =====================================================
            const isSingleSection = model.sections.length === 1;
            const stilesRemoved = model.frame?.removeStiles === true;

            if (!isSingleSection && stilesRemoved) {
                model.drawerRailsMode = "none";
                model.drawerRailHeightIn = 0;
            }


            // attach persistent section overrides
            model.sectionOverrides = sectionOverrides;

            // =====================================================
            // INVALIDATE INTERIOR SHELVES WHEN NO DOOR SECTIONS
            // =====================================================

            const hasDoorSection = model.sections.some(sec => sec.role === "door");

            if (!hasDoorSection && model.sectionOverrides) {
                Object.keys(model.sectionOverrides).forEach(idx => {
                    if (model.sectionOverrides[idx]?.interiorShelf) {
                        delete model.sectionOverrides[idx].interiorShelf;
                    }
                });
            }


            // Shelf px conversion
            model.shelfThicknessPx = shelfThicknessIn * inchToPx;

            // ===========================================================
            // PATCH 7 â€” cache case-opening vertical geometry in model
            // ===========================================================
            const geom = computeCaseOpeningVertical(model);

            // Basic open span
            model.openTopY = geom.openTopY;
            model.openBottomY = geom.openBottomY;

            // Helper geometry
            model.cabTopY = geom.openTopY;         // alias for consistency
            model.cabBottomY = geom.openBottomY;   // alias for consistency

            // Extra geometry only if computeCaseOpeningVertical returns them
            if (geom.caseBottomY !== undefined) model.caseBottomY = geom.caseBottomY;
            if (geom.shelfTopY !== undefined) model.shelfTopY = geom.shelfTopY;
            if (geom.shelfBottomY !== undefined) model.shelfBottomY = geom.shelfBottomY;
            if (geom.toeKickPx !== undefined) model.toeKickPx = geom.toeKickPx;

            // Return the final model
            return model;

        }



        // ---------------------------------------------------------------
        // LAYOUT CONSTANTS + LIBRARY
        // ---------------------------------------------------------------
        // LAYOUT CONSTRAINTS
        const MIN_DRAWER_WIDTH = 8.5;
        const MIN_DOOR_LEAF_WIDTH = 10;
        const MAX_SECTION_WIDTH = 40;
        const MIN_WIDTH_IN = 18; // hard minimum vanity width the UI should accept

        const MIN_SINK_SECTION_WIDTH = 15.5;      // ABSOLUTE LOWEST allowed (user adjustment)
        const DEFAULT_MIN_SINK_SECTION_WIDTH = 20; // Minimum sink section width for default layouts

        // Smallest valid double-sink vanity width (inches), based on:
        //  - two 20" sink sections (DEFAULT_MIN_SINK_SECTION_WIDTH)
        //  - one 8.5" drawer bay (MIN_DRAWER_WIDTH)
        //  - default 2" legs each side (FRAME_DEFAULTS.legWidthIn)
        //  - default 1.5" stiles between 3 sections (FRAME_DEFAULTS.stileWidthIn, 2 gaps)
        //
        // interiorWidth = 2*20 + 8.5 = 48.5
        // plus 2 stiles = 3.0 â†’ 51.5 between legs
        // plus 2 legs  = 4.0 â†’ 55.5 overall
        const MIN_DOUBLE_SINK_WIDTH_IN =
            2 * DEFAULT_MIN_SINK_SECTION_WIDTH +
            MIN_DRAWER_WIDTH +
            2 * FRAME_DEFAULTS.stileWidthIn +
            2 * FRAME_DEFAULTS.legWidthIn;

        // Adjust section widths based on the drawer width controls,
        // WITHOUT touching anything unless the user actually edited a field.
        function applyDrawerWidthOverrides(model, sections) {
            if (!sections || !sections.length) return sections;

            const widthIn = model.widthIn || 0;
            const sectionCount = sections.length;

            // safety: use existing MIN_SECTION_WIDTH if defined, otherwise 8.5"
            const MIN_W = (typeof MIN_SECTION_WIDTH === "number") ? MIN_SECTION_WIDTH : 8.5;

            // helper: snap to nearest 1/4"
            function snapQuarter(val) {
                if (!val || !isFinite(val)) return 0;
                return Math.round(val * 4) / 4;
            }

            // read a drawer width from an <input> by id, return snapped inches or null
            function readDrawerInput(id) {
                const el = document.getElementById(id);
                if (!el) return null;
                const raw = parseFloat(el.value);
                if (!isFinite(raw) || raw <= 0) return null;
                return snapQuarter(raw);
            }

            const drawerInfos = sections
                .map((sec, idx) => ({ sec, idx }))
                .filter(d => d.sec.role === "drawer");

            const drawerCount = drawerInfos.length;
            if (!drawerCount) return sections; // nothing to override

            // =====================================================================
            // CASE A: 2-SECTION OFF-CENTER LAYOUTS WITH EXACTLY ONE DRAWER SECTION
            //         â†’ use drawerWidthSingle, adjust the OTHER bay to keep total
            // =====================================================================
            if (sectionCount === 2 && drawerCount === 1 && drawerOverrideFlags.single) {
                const desiredRaw = readDrawerInput("drawerWidthSingle");
                if (desiredRaw == null || widthIn <= 0) return sections;

                // clamp to something sane
                let drawerW = desiredRaw;
                if (drawerW < MIN_W) drawerW = MIN_W;

                // we must leave at least MIN_W" for the other section
                const maxDrawer = Math.max(widthIn - MIN_W, MIN_W);
                if (drawerW > maxDrawer) drawerW = maxDrawer;

                const drawer = drawerInfos[0];
                const drawerIdx = drawer.idx;
                const otherIdx = drawerIdx === 0 ? 1 : 0;

                // recompute both sections so they still sum to widthIn
                const otherW = widthIn - drawerW;

                // lay them out from left to right
                if (drawerIdx === 0) {
                    // drawer on the LEFT
                    sections[0].xIn = 0;
                    sections[0].widthIn = drawerW;

                    sections[1].xIn = drawerW;
                    sections[1].widthIn = otherW;
                } else {
                    // drawer on the RIGHT
                    sections[0].xIn = 0;
                    sections[0].widthIn = otherW;

                    sections[1].xIn = otherW;
                    sections[1].widthIn = drawerW;
                }

                return sections;
            }

            // =====================================================================
            // CASE B: 3-SECTION LAYOUTS USING SINGLE CONTROL
            //         (all-drawer OR mixed) â†’ drawerWidthSingle
            // =====================================================================
            if (sectionCount === 3 && drawerOverrideFlags.single) {
                const desiredRaw = readDrawerInput("drawerWidthSingle");
                if (desiredRaw == null || widthIn <= 0) return sections;

                const drawerCount3 = drawerInfos.length;
                const doorCount3 = sectionCount - drawerCount3;

                if (drawerCount3 <= 0) return sections;

                let drawerW = desiredRaw;
                if (drawerW < MIN_W) drawerW = MIN_W;

                // total drawer width
                let drawerTotal = drawerW * drawerCount3;
                const minDoorTotal = doorCount3 * MIN_W;

                // if that plus min doors won't fit, shrink the drawer width
                if (drawerTotal + minDoorTotal > widthIn - 0.01) {
                    const maxDrawerTotal = widthIn - minDoorTotal;
                    if (maxDrawerTotal <= 0) return sections;
                    drawerW = snapQuarter(maxDrawerTotal / drawerCount3);
                    if (drawerW < MIN_W) drawerW = MIN_W;
                    drawerTotal = drawerW * drawerCount3;
                }

                const leftover = widthIn - drawerTotal;
                const doorW = (doorCount3 > 0 ? leftover / doorCount3 : 0);

                // now reflow all three sections left â†’ right
                let x = 0;
                for (let i = 0; i < sectionCount; i++) {
                    const sec = sections[i];
                    if (sec.role === "drawer") {
                        sec.xIn = x;
                        sec.widthIn = drawerW;
                        x += drawerW;
                    } else {
                        sec.xIn = x;
                        sec.widthIn = doorW;
                        x += doorW;
                    }
                }

                return sections;
            }

            // =====================================================================
            // CASE C: 5-SECTION LAYOUTS (classic drawer / door / drawer / door / drawer)
            //         â†’ outer drawers use drawerWidthOuter, center drawer uses drawerWidthCenter
            // =====================================================================
            if (sectionCount === 5 && (drawerOverrideFlags.outer || drawerOverrideFlags.center)) {
                const outerValRaw = drawerOverrideFlags.outer ? readDrawerInput("drawerWidthOuter") : null;
                const centerValRaw = drawerOverrideFlags.center ? readDrawerInput("drawerWidthCenter") : null;

                if (outerValRaw == null && centerValRaw == null) return sections;

                const outerVal = outerValRaw != null ? Math.max(MIN_W, outerValRaw) : null;
                const centerVal = centerValRaw != null ? Math.max(MIN_W, centerValRaw) : null;

                // identify leftmost and rightmost drawer as "outer"; any others are "center"
                const drawerIndicesSorted = drawerInfos.map(d => d.idx).sort((a, b) => a - b);
                const firstDrawerIdx = drawerIndicesSorted[0];
                const lastDrawerIdx = drawerIndicesSorted[drawerIndicesSorted.length - 1];

                const drawerTargets = new Array(sectionCount).fill(null);

                // set targets for outer drawers
                drawerInfos.forEach(({ idx }) => {
                    if (idx === firstDrawerIdx || idx === lastDrawerIdx) {
                        if (outerVal != null) drawerTargets[idx] = outerVal;
                    }
                });

                // center drawers (any drawer that's not the extreme left/right)
                drawerInfos.forEach(({ idx }) => {
                    if (idx !== firstDrawerIdx && idx !== lastDrawerIdx) {
                        if (centerVal != null) drawerTargets[idx] = centerVal;
                    }
                });

                // fall back to current width if some drawers had no override
                drawerInfos.forEach(({ sec, idx }) => {
                    if (drawerTargets[idx] == null) {
                        drawerTargets[idx] = sec.widthIn;
                    }
                });

                // total drawer width and door counts
                const drawerTotal = drawerInfos.reduce((sum, { idx }) => {
                    return sum + (drawerTargets[idx] || 0);
                }, 0);

                const doorCount5 = sectionCount - drawerInfos.length;
                const minDoorTotal = doorCount5 * MIN_W;

                if (drawerTotal + minDoorTotal > widthIn - 0.01) {
                    // not enough room to respect all overrides + min doors â†’ bail instead of mangling everything
                    return sections;
                }

                const leftover = widthIn - drawerTotal;
                const doorW = (doorCount5 > 0 ? leftover / doorCount5 : 0);

                // reflow all five sections left â†’ right
                let x = 0;
                for (let i = 0; i < sectionCount; i++) {
                    const sec = sections[i];
                    if (sec.role === "drawer") {
                        const target = drawerTargets[i] || sec.widthIn;
                        sec.xIn = x;
                        sec.widthIn = target;
                        x += target;
                    } else {
                        sec.xIn = x;
                        sec.widthIn = doorW;
                        x += doorW;
                    }
                }

                return sections;
            }

            // all other layouts â†’ leave sections as computed
            return sections;
        }

        // 2-SECTION LAYOUT OVERRIDE (conceptually 2 bays: drawer side + other side)
        //
        // - Works when there is exactly ONE drawer section in the layout
        // - It does NOT require sections.length === 2 anymore; it can handle 3+,
        //   as long as there is only one drawer bay.
        // - Uses #drawerWidthTwoSection (inches) as the requested drawer-bay width.
        function applyTwoSectionDrawerOverride(model, sectionsOverride) {
            const sections = sectionsOverride || model.sections || [];
            if (!sections || !sections.length) return;

            const twoInput = document.getElementById("drawerWidthTwoSection");
            if (!twoInput) return;

            // Only do anything if the user has actually edited this field
            if (!drawerOverrideFlags || !drawerOverrideFlags.twoSection) return;

            let requested = Number(twoInput.value);
            if (!requested || !isFinite(requested)) return;

            // Find which section is the drawer bay
            const drawerIndex = sections.findIndex(sec => sec.role === "drawer");
            if (drawerIndex === -1) {
                // no drawer bay â†’ nothing to override
                return;
            }

            // We conceptually treat this as TWO big zones:
            //   - the drawer bay (one section)
            //   - the "other" bay (all remaining sections merged)
            //
            // but we keep the other bay split into however many sections it already has,
            // just scaled to fit.

            const lastIndex = sections.length - 1;

            // Full span across ALL sections
            const leftEdgeIn = sections[0].xIn;
            const rightEdgeIn = sections[lastIndex].xIn + sections[lastIndex].widthIn;
            let totalSpanIn = rightEdgeIn - leftEdgeIn;

            if (!isFinite(totalSpanIn) || totalSpanIn <= 0) return;

            // Enforce min-width rules for the two conceptual bays
            const min = (typeof MIN_SECTION_WIDTH === "number") ? MIN_SECTION_WIDTH : 8.5;

            if (requested < min) requested = min;
            if (requested > totalSpanIn - min) {
                requested = totalSpanIn - min;
            }

            const otherTotal = totalSpanIn - requested;

            const drawerSec = sections[drawerIndex];

            // Gather "other" sections (everything that is not the drawer bay)
            const otherSections = sections.filter((_, i) => i !== drawerIndex);
            if (!otherSections.length) return;

            // Sum their existing widths so we can preserve relative proportions
            const totalOtherOldWidth = otherSections.reduce((sum, s) => sum + s.widthIn, 0);
            if (!isFinite(totalOtherOldWidth) || totalOtherOldWidth <= 0) return;

            // Rebuild positions/widths so everything still tiles left-to-right
            if (drawerIndex === 0) {
                // drawer bay on the LEFT
                drawerSec.xIn = leftEdgeIn;
                drawerSec.widthIn = requested;

                let cursor = leftEdgeIn + requested;

                // scale all "other" sections into the remaining bay
                for (let i = 0; i < otherSections.length; i++) {
                    const s = otherSections[i];

                    // proportional width
                    let w;
                    if (i === otherSections.length - 1) {
                        // last one: absorb any rounding error
                        w = (leftEdgeIn + totalSpanIn) - cursor;
                    } else {
                        const frac = s.widthIn / totalOtherOldWidth;
                        w = otherTotal * frac;
                    }

                    s.xIn = cursor;
                    s.widthIn = w;
                    cursor += w;
                }

            } else if (drawerIndex === lastIndex) {
                // drawer bay on the RIGHT
                let cursor = leftEdgeIn;

                const othersCount = otherSections.length;
                for (let i = 0; i < othersCount; i++) {
                    const s = otherSections[i];

                    let w;
                    if (i === othersCount - 1) {
                        // last "other" section takes whatever is left before the drawer bay
                        w = (leftEdgeIn + totalSpanIn) - (leftEdgeIn + otherTotal);
                    } else {
                        const frac = s.widthIn / totalOtherOldWidth;
                        w = otherTotal * frac;
                    }

                    s.xIn = cursor;
                    s.widthIn = w;
                    cursor += w;
                }

                // now place drawer section at the far right
                drawerSec.xIn = leftEdgeIn + otherTotal;
                drawerSec.widthIn = requested;

            } else {
                // drawer bay in the middle (super edge-case for this feature),
                // we can either bail or handle it in a more complex way.
                // For now, we bail to avoid creating weird layouts.
                return;
            }
        }



        function computeSections(model) {
            const { widthIn, frame, sinkCount, layoutPreset } = model;

            const legWidthIn = frame?.legWidthIn ?? FRAME_DEFAULTS.legWidthIn;
            const stileWidthInRaw = frame?.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn;
            const removeStiles = model.removeStiles;   // flag: stiles removed

            // === drawer width controls coming from the model ===
            const drawerControls = model.drawerControls || {};
            const singleDw = drawerControls.singleDrawerWidthIn || 0;
            const outerDw = drawerControls.outerDrawerWidthIn || 0;
            const centerDw = drawerControls.centerDrawerWidthIn || 0;

            // interior between legs
            const interiorStartIn = legWidthIn;
            const interiorEndIn = widthIn - legWidthIn;
            const interiorWidthIn = interiorEndIn - interiorStartIn;
            if (interiorWidthIn <= 0) return [];

            // --- pick layout (just for roles + sectionCount) -------------------
            const allLayouts = getLayoutsFor(
                widthIn,
                sinkCount,
                model.sinkPosition || "center"
            );

            const defaultSectionCount = getDefaultSectionCount(widthIn, sinkCount);

            let chosenLayout = null;

            if (layoutPreset) {
                chosenLayout = allLayouts.find(l => l.id === layoutPreset) || null;
            }

            if (!chosenLayout) {
                chosenLayout =
                    allLayouts.find(l => l.isDefault) ||
                    allLayouts[0] ||
                    null;
            }

            let sectionCount;
            let roles = [];

            if (chosenLayout) {
                sectionCount = chosenLayout.sectionCount;
                roles = chosenLayout.roles.slice();

                // keep the <select> in sync with any fallback we chose
                const layoutSel = document.getElementById("layoutPreset");
                if (layoutSel && layoutSel.value !== chosenLayout.id) {
                    layoutSel.value = chosenLayout.id;
                }
            } else {
                // extreme edge case â€“ no layouts at all
                sectionCount = defaultSectionCount;
                roles = new Array(sectionCount).fill("door");
            }

            // gaps between sections (face-frame stiles) -------------------------
            const gaps = Math.max(sectionCount - 1, 0);
            const gapWidthIn = removeStiles ? 0 : stileWidthInRaw;

            const availableFaceWidthIn = interiorWidthIn - gaps * gapWidthIn;
            if (availableFaceWidthIn <= 0) return [];

            // base equal width for all sections
            const baseWidthIn = availableFaceWidthIn / sectionCount;

            // ================================================================
            // EARLY EXIT MODE:
            // If this vanity *could* have all sections equal at >= 20"
            // and the user has NOT overridden drawer widths, then
            // just make all sections equal and return.
            // ================================================================
            const hasSink = (sinkCount > 0);
            const equalSectionWidthIn = baseWidthIn;

            const canUseEqualSections =
                hasSink &&
                sectionCount > 1 &&
                equalSectionWidthIn >= DEFAULT_MIN_SINK_SECTION_WIDTH &&  // 20"
                !drawerOverrideFlags.single &&
                !drawerOverrideFlags.outer &&
                !drawerOverrideFlags.center;

            if (canUseEqualSections) {
                const sections = [];
                let xIn = interiorStartIn;

                for (let i = 0; i < sectionCount; i++) {
                    sections.push({
                        index: i,
                        xIn,
                        widthIn: equalSectionWidthIn,
                        role: roles[i] || "door"
                    });

                    xIn += equalSectionWidthIn;
                    if (i < sectionCount - 1) {
                        xIn += gapWidthIn;  // same stile width / 0 if removeStiles
                    }
                }
                applyDrawerWidthOverrides(model, sections);
                return sections;
            }


            // -------------------------------------------------------------------
            // Start with equal widths
            // -------------------------------------------------------------------
            let widths = new Array(sectionCount).fill(baseWidthIn);

            // which sections are drawers?
            const drawerIndices = [];
            roles.forEach((role, i) => {
                if (role === "drawer") drawerIndices.push(i);
            });

            const hasSinks = (sinkCount && sinkCount > 0);
            const anyDrawerOverride =
                drawerOverrideFlags.single ||
                drawerOverrideFlags.outer ||
                drawerOverrideFlags.center;

            // ============================================================
            // SINK-FIRST DEFAULT LAYOUT (no drawer overrides)
            // ============================================================
            if (hasSinks && sectionCount >= 2 && !anyDrawerOverride) {
                // 1) Build a provisional equal-width layout so we can ask
                //    "which sections get sinks?" using your existing logic.
                const provisionalSections = [];
                let runX0 = interiorStartIn;
                for (let i = 0; i < sectionCount; i++) {
                    const wIn = baseWidthIn;
                    provisionalSections.push({
                        index: i,
                        xIn: runX0,
                        widthIn: wIn,
                        role: roles[i] || "door"
                    });
                    runX0 += wIn;
                    if (i < sectionCount - 1) {
                        runX0 += gapWidthIn;
                    }
                }

                const sinkIndices = computeSinkSectionIndices({
                    ...model,
                    sections: provisionalSections
                });

                if (sinkIndices && sinkIndices.length) {
                    const nSinks = sinkIndices.length;
                    const nNonSinks = sectionCount - nSinks;

                    if (nNonSinks > 0) {
                        // How big can sinks be, while keeping drawers >= MIN_DRAWER_WIDTH?
                        const maxSinkWidth =
                            (availableFaceWidthIn - nNonSinks * MIN_DRAWER_WIDTH) / nSinks;

                        if (maxSinkWidth >= MIN_SINK_SECTION_WIDTH) {
                            // Target 20" by default, but never exceed what's feasible.
                            let sinkWidth = DEFAULT_MIN_SINK_SECTION_WIDTH; // 20"
                            if (sinkWidth > maxSinkWidth) sinkWidth = maxSinkWidth;

                            const remaining = availableFaceWidthIn - sinkWidth * nSinks;
                            const nonSinkWidth = remaining / nNonSinks;

                            const sinkSet = new Set(sinkIndices);
                            widths = widths.map((_, idx) =>
                                sinkSet.has(idx) ? sinkWidth : nonSinkWidth
                            );
                        }
                        // else: geometry is too tight to enforce 20"/15.5" nicely
                        //       (tiny / weird combos). In that case we just keep
                        //       the equal widths we started with. This is effectively
                        //       your "<24" exception in practice.
                    } else {
                        // all sections are sinks â€“ just make them equal
                        const per = availableFaceWidthIn / nSinks;
                        const sinkSet = new Set(sinkIndices);
                        widths = widths.map((_, idx) =>
                            sinkSet.has(idx) ? per : 0
                        );
                    }
                }
            }

            // ============================================================
            // DRAWER WIDTH LOGIC
            //
            // Apply ONLY when:
            //   - we have drawers, AND
            //   - either there are no sinks, OR the user has overridden
            //     the drawer widths (single / outer / center).
            // ============================================================
            if (drawerIndices.length && (!(hasSinks && sectionCount >= 2 && !anyDrawerOverride))) {

                // helper to snap to 1/4" and guard nonsense
                function normalizeDrawer(val) {
                    let v = Number(val);
                    if (!v || !isFinite(v) || v <= 0) return 0;
                    v = Math.round(v * 4) / 4;
                    if (v < MIN_DRAWER_WIDTH) v = MIN_DRAWER_WIDTH;
                    return v;
                }

                // -------------------------------------------------------
                // 3-SECTION: single drawer width control
                //   - if no sink overrides: we let user change drawers
                //     and keep door/sink bays >= MIN_SINK_SECTION_WIDTH.
                // -------------------------------------------------------
                if (sectionCount === 3) {
                    let dw = normalizeDrawer(singleDw);

                    // if user hasn't set anything yet (dw = 0), choose default = baseWidthIn
                    if (!dw) {
                        dw = baseWidthIn;

                        const input = document.getElementById("drawerWidthSingle");
                        if (input && !input.value) {
                            input.value = Math.round(dw * 4) / 4;
                        }
                    }

                    if (dw) {
                        const drawerCount = drawerIndices.length;
                        const doorCount = sectionCount - drawerCount;

                        // If we have sinks and at least one non-drawer section,
                        // clamp drawer width so the door/sink bays can't shrink
                        // below MIN_SINK_SECTION_WIDTH.
                        if (sinkCount > 0 && doorCount > 0) {
                            // door width = (availableFaceWidthIn - drawerCount * dw) / doorCount
                            // We want: doorWidth >= MIN_SINK_SECTION_WIDTH
                            // â†’ dw <= (availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH) / drawerCount
                            const maxDrawerTotal = availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH;

                            if (maxDrawerTotal > 0) {
                                const maxDwFromSink = maxDrawerTotal / drawerCount;
                                if (dw > maxDwFromSink) {
                                    dw = maxDwFromSink;
                                }
                            }
                        }

                        // global drawer minimum still applies
                        if (dw < MIN_DRAWER_WIDTH) {
                            dw = MIN_DRAWER_WIDTH;
                        }

                        // snap and sync the UI field with the clamped value
                        dw = Math.round(dw * 4) / 4;
                        const input = document.getElementById("drawerWidthSingle");
                        if (input) {
                            input.value = dw;
                        }

                        // --- now recompute widths using this clamped drawer width ---
                        const drawerTotal = dw * drawerCount;
                        const remaining = availableFaceWidthIn - drawerTotal;

                        if (doorCount > 0 && remaining > 0) {
                            const doorW = remaining / doorCount;
                            if (doorW > 0) {
                                drawerIndices.forEach(i => { widths[i] = dw; });
                                for (let i = 0; i < sectionCount; i++) {
                                    if (!drawerIndices.includes(i)) {
                                        widths[i] = doorW;
                                    }
                                }
                            }
                        }
                    }
                }

                // -------------------------------------------------------
                // 5-SECTION: outer + center drawer controls
                //   - still respects sink minimums but now ONLY when
                //     user is actually editing drawers.
                // -------------------------------------------------------
                if (sectionCount === 5) {
                    let outer = normalizeDrawer(outerDw);
                    let center = normalizeDrawer(centerDw);

                    // default if user hasn't touched them yet
                    if (!outer && !center) {
                        outer = baseWidthIn;
                        center = baseWidthIn;

                        const outerInput = document.getElementById("drawerWidthOuter");
                        if (outerInput && !outerInput.value) {
                            outerInput.value = Math.round(outer * 4) / 4;
                        }
                        const centerInput = document.getElementById("drawerWidthCenter");
                        if (centerInput && !centerInput.value) {
                            centerInput.value = Math.round(center * 4) / 4;
                        }
                    }

                    // if one is missing, fall back to equal
                    if (!outer) outer = baseWidthIn;
                    if (!center) center = baseWidthIn;

                    const outerDrawerIdx = drawerIndices.filter(
                        i => i === 0 || i === sectionCount - 1
                    );
                    const centerDrawerIdx = drawerIndices.filter(
                        i => !outerDrawerIdx.includes(i)
                    );

                    const nOuter = outerDrawerIdx.length;
                    const nCenter = centerDrawerIdx.length;

                    let drawerTotal = nOuter * outer + nCenter * center;
                    const drawerCount = nOuter + nCenter;
                    const doorCount = sectionCount - drawerCount;

                    // If we have sinks and at least one non-drawer section,
                    // clamp the *edited* drawer group so door/sink bays never
                    // drop below MIN_SINK_SECTION_WIDTH.
                    if (sinkCount > 0 && doorCount > 0) {
                        // doorWidth = (availableFaceWidthIn - drawerTotal) / doorCount
                        // We want: doorWidth >= MIN_SINK_SECTION_WIDTH
                        // â†’ drawerTotal <= availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH
                        const maxDrawerTotal =
                            availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH;

                        if (maxDrawerTotal > 0 && drawerTotal > maxDrawerTotal) {
                            // see which field the user actually touched last
                            if (lastDrawerEdited === "outer" && nOuter > 0) {
                                // nOuter * outer + nCenter * center <= maxDrawerTotal
                                // â†’ outer <= (maxDrawerTotal - nCenter * center) / nOuter
                                const allowedForOuter = maxDrawerTotal - nCenter * center;
                                let maxOuter = allowedForOuter / nOuter;
                                if (maxOuter < MIN_DRAWER_WIDTH) maxOuter = MIN_DRAWER_WIDTH;
                                outer = maxOuter;
                            } else if (lastDrawerEdited === "center" && nCenter > 0) {
                                // nOuter * outer + nCenter * center <= maxDrawerTotal
                                // â†’ center <= (maxDrawerTotal - nOuter * outer) / nCenter
                                const allowedForCenter = maxDrawerTotal - nOuter * outer;
                                let maxCenter = allowedForCenter / nCenter;
                                if (maxCenter < MIN_DRAWER_WIDTH) maxCenter = MIN_DRAWER_WIDTH;
                                center = maxCenter;
                            } else {
                                // fallback: scale both (rare edge-case when we don't know)
                                const scaleFactor = maxDrawerTotal / drawerTotal;
                                outer *= scaleFactor;
                                center *= scaleFactor;
                            }

                            drawerTotal = nOuter * outer + nCenter * center;
                        }
                    }

                    // global drawer minimum still applies
                    if (outer < MIN_DRAWER_WIDTH) outer = MIN_DRAWER_WIDTH;
                    if (center < MIN_DRAWER_WIDTH) center = MIN_DRAWER_WIDTH;

                    // snap & sync UI fields with clamped values
                    outer = Math.round(outer * 4) / 4;
                    center = Math.round(center * 4) / 4;

                    const outerInput = document.getElementById("drawerWidthOuter");
                    if (outerInput) outerInput.value = outer;

                    const centerInput = document.getElementById("drawerWidthCenter");
                    if (centerInput) centerInput.value = center;

                    // recompute with final drawer widths
                    const finalDrawerTotal = nOuter * outer + nCenter * center;
                    const remaining = availableFaceWidthIn - finalDrawerTotal;

                    if (doorCount > 0 && remaining > 0) {
                        const doorW = remaining / doorCount;
                        if (doorW > 0) {
                            outerDrawerIdx.forEach(i => { widths[i] = outer; });
                            centerDrawerIdx.forEach(i => { widths[i] = center; });
                            for (let i = 0; i < sectionCount; i++) {
                                if (!drawerIndices.includes(i)) {
                                    widths[i] = doorW;
                                }
                            }
                        }
                    }
                }
            }

            // -------------------------------------------------------------------
            // Build final sections array with the chosen widths
            // -------------------------------------------------------------------
            const sections = [];
            let xIn = interiorStartIn;

            for (let i = 0; i < sectionCount; i++) {
                const wIn = widths[i];

                sections.push({
                    index: i,
                    xIn,
                    widthIn: wIn,
                    role: roles[i] || "door"
                });

                xIn += wIn;
                if (i < sectionCount - 1) {
                    xIn += gapWidthIn;
                }
            }

            // Rebuild x-positions now that widths are final
            let runX = interiorStartIn;
            for (let i = 0; i < sections.length; i++) {
                const sec = sections[i];
                sec.xIn = runX;
                runX += sec.widthIn;

                if (i < sections.length - 1) {
                    runX += gapWidthIn;  // same stile width / 0 if removeStiles
                }
            }

            // Final tweak: 2-section off-center drawer override (if active)
            applyTwoSectionDrawerOverride(model, sections);


            return sections;
        }



        function getDefaultSectionCount(widthIn, sinkCount) {
            // clamp sinkCount to 0â€“2
            const s = Math.max(0, Math.min(2, sinkCount || 0));

            // 17â€“42"  â†’ 1 section
            if (widthIn < 42) return 1;

            // 42â€“90" â†’ 3 sections by default
            if (widthIn < 90) return 3;

            // 90â€“115" â†’ special rules:
            //  - single sink â†’ default 3 sections
            //  - 0 or 2 sinks â†’ default 5 sections
            if (widthIn <= 115) {
                if (s === 1) return 3;
                return 5;
            }

            // 115â€“130" â†’ 5 sections
            if (widthIn < 130) return 5;

            // 130"+ â†’ 7 sections
            return 7;
        }

        // âš ï¸ VISIBILITY ONLY
        // This function must NEVER write drawer input values.
        // Drawer width inputs are synced ONLY in syncDrawerInputsFromSections().

        function updateDrawerWidthFieldsVisibility(model) {
            const singleWrap = document.getElementById("drawerWidthSingleField");
            const outerWrap = document.getElementById("drawerWidthOuterField");
            const centerWrap = document.getElementById("drawerWidthCenterField");
            const twoSectionWrap = document.getElementById("drawerWidthTwoSectionField"); // NEW

            if (!singleWrap || !outerWrap || !centerWrap || !twoSectionWrap) return;

            const sections = model.sections || [];
            const sectionCount = sections.length;

            // default: hide everything
            singleWrap.style.display = "none";
            outerWrap.style.display = "none";
            centerWrap.style.display = "none";
            if (twoSectionWrap) twoSectionWrap.style.display = "none";

            if (!sectionCount) return;

            const drawerSections = sections.filter(sec => sec.role === "drawer");
            const drawerCount = drawerSections.length;

            // no drawers at all â†’ nothing to adjust
            if (!drawerCount) return;

            const allDrawers = drawerCount === sectionCount;

            // CASE 2: 2-SECTION layouts with exactly ONE drawer section
            //         â†’ dedicated 2-section drawer width control
            if (sectionCount === 2 && drawerCount === 1) {
                if (twoSectionWrap) twoSectionWrap.style.display = "";
                return;
            }


            // 3-section "classic" mixed layouts â†’ single field
            if (sectionCount === 3 && !allDrawers) {
                singleWrap.style.display = "";
                return;
            }

            // 3-section all-drawer or 5-section layouts â†’ outer + center
            if (sectionCount === 5 || (sectionCount === 3 && allDrawers)) {
                outerWrap.style.display = "";
                centerWrap.style.display = "";
                return;
            }

            // fallback: single field if we ever hit a weird case with drawers
            if (drawerCount > 0) {
                singleWrap.style.display = "";
            }
        }

        function syncDrawerInputsFromSections(model) {
            // block first-load sync so it does not corrupt drawer widths

            // Guard: drawer inputs must never be blank when visible
            // If this trips, someone broke the sync contract

            const anyVisible =
                document.getElementById("drawerWidthSingleField")?.style.display !== "none" ||
                document.getElementById("drawerWidthOuterField")?.style.display !== "none" ||
                document.getElementById("drawerWidthCenterField")?.style.display !== "none" ||
                document.getElementById("drawerWidthTwoSectionField")?.style.display !== "none";

            if (anyVisible) {
                const inputs = [
                    document.getElementById("drawerWidthSingle"),
                    document.getElementById("drawerWidthOuter"),
                    document.getElementById("drawerWidthCenter"),
                    document.getElementById("drawerWidthTwoSection")
                ].filter(Boolean);

                inputs.forEach(input => {
                    if (input.value === "") {
                        // Ignore blank fields that are not currently user-active
                        return;
                    }

                });
            }


            const sections = model.sections || [];
            const sectionCount = sections.length;
            if (!sectionCount) return;

            const singleInput = document.getElementById("drawerWidthSingle");
            const outerInput = document.getElementById("drawerWidthOuter");
            const centerInput = document.getElementById("drawerWidthCenter");
            const twoSectionInput = document.getElementById("drawerWidthTwoSection");

            if (!singleInput && !outerInput && !centerInput && !twoSectionInput) return;

            function snapQuarter(val) {
                if (!val || !isFinite(val)) return 0;
                return Math.round(val * 4) / 4;
            }

            const drawerSecs = sections.filter(sec => sec.role === "drawer");
            const drawerCount = drawerSecs.length;
            const allDrawers = drawerCount === sectionCount;

            // 2-section layouts with exactly ONE drawer section
            // â†’ sync #drawerWidthTwoSection from that drawer, unless user overrode it
            if (
                sectionCount === 2 &&
                twoSectionInput &&
                (!drawerOverrideFlags.twoSection || !initialDrawDone)
            ) {

                const drawerSecs = sections.filter(sec => sec.role === "drawer");
                if (drawerSecs.length === 1) {
                    const w = snapQuarter(drawerSecs[0].widthIn);
                    if (w > 0) {
                        twoSectionInput.value = w;
                    }
                }
            }


            // === 3-SECTION classic mixed â†’ single ================================
            if (sectionCount === 3 && !allDrawers) {
                if (!singleInput) return;
                if (drawerOverrideFlags.single && initialDrawDone) return;


                if (!drawerSecs.length) return;
                const w = snapQuarter(drawerSecs[0].widthIn);
                if (w > 0) singleInput.value = w;
                return;
            }

            // === 3-SECTION all drawers or 5-SECTION â†’ outer + center =============
            if (sectionCount === 5 || (sectionCount === 3 && allDrawers)) {
                const drawers = sections
                    .map((sec, idx) => ({ sec, idx }))
                    .filter(d => d.sec.role === "drawer");

                if (!drawers.length) return;

                // outer drawers (index 0 and last)
                if (outerInput && (!drawerOverrideFlags.outer || !initialDrawDone)) {

                    const outerDrawers = drawers.filter(
                        d => d.idx === 0 || d.idx === sectionCount - 1
                    );
                    if (outerDrawers.length) {
                        const w = snapQuarter(outerDrawers[0].sec.widthIn);
                        if (w > 0) outerInput.value = w;
                    }
                }

                // center drawers (any drawer that's not outer)
                if (centerInput && (!drawerOverrideFlags.center || !initialDrawDone)) {

                    const centerDrawers = drawers.filter(
                        d => d.idx !== 0 && d.idx !== sectionCount - 1
                    );
                    if (centerDrawers.length) {
                        const w = snapQuarter(centerDrawers[0].sec.widthIn);
                        if (w > 0) centerInput.value = w;
                    }
                }
            }
        }



        // Which section counts are allowed at this width?
        function getAllowedSectionCounts(widthIn) {
            if (widthIn < 42) return [1];        // tiny vanities
            if (widthIn < 89) return [3];        // normal range â†’ 3 only
            if (widthIn <= 115) return [3, 5];   // wide, but still able to be 3 *or* 5
            if (widthIn < 130) return [5];       // bigger â†’ 5 only
            return [7];                          // monsters â†’ 7 sections
        }

        function getLayoutsFor(widthIn, sinkCount, sinkPosition) {
            const layouts = [];
            const s = Math.max(0, Math.min(2, sinkCount || 0)); // clamp 0â€“2
            const pos = sinkPosition || "center";
            const allowedCounts = getAllowedSectionCounts(widthIn);
            const defaultCount = getDefaultSectionCount(widthIn, s);

            function addLayout(sectionCount, id, label, roles, isDefaultForThisCount) {
                layouts.push({
                    id,
                    label,
                    roles,
                    sectionCount,
                    isDefault: isDefaultForThisCount && sectionCount === defaultCount
                });
            }

            // =========================================================
            // SPECIAL CASE: OFF-CENTER SINGLE SINK
            //
            // Only for:
            //   - exactly 1 sink
            //   - sinkPosition is left or right
            //   - width between 30" and 115"
            //
            // For these, we *replace* the normal layout catalog with:
            //   width < 58" â†’ 2-section only
            //   58â€“76"      â†’ 2- and 3-section options
            //   >76"        â†’ 3-section only
            //
            // **Key rule weâ€™re enforcing now:**
            //   Whenever 2-section off-center layouts exist,
            //   the default is ALWAYS the mixed layout:
            //     - left sink  â†’ door(s) / drawers
            //     - right sink â†’ drawers / door(s)
            // =========================================================
            const offCenterSingle =
                s === 1 &&
                pos !== "center" &&
                widthIn >= 30 &&
                widthIn <= 115;

            if (offCenterSingle) {
                // Off-center single sink:
                //  - 2 sections allowed from 30â€“76"
                //  - 3 sections allowed from 58â€“115"
                //  - 58â€“76" has BOTH 2- and 3-section options
                const allow2 = (widthIn >= 30 && widthIn <= 76);
                const allow3 = (widthIn >= 58 && widthIn <= 115);

                // We still care about default section count for 3-section choices:
                const defaultCountOff = allow3 ? 3 : 2;

                // ---------- 2-SECTION OFF-CENTER OPTIONS -------------------------
                if (allow2) {
                    // pure doors & pure drawers are NEVER default
                    addLayout(
                        2,
                        "off-four-doors",        // â†’ ['door', 'door']
                        "door(s)",
                        ["door", "door"],
                        false
                    );
                    addLayout(
                        2,
                        "off-all-drawers",       // â†’ ['drawer', 'drawer']
                        "all drawers",
                        ["drawer", "drawer"],
                        false
                    );

                    // âœ… HARD RULE: mixed pattern is ALWAYS the default
                    if (pos === "left") {
                        // sink on the left â†’ left bay is the door section
                        layouts.push({
                            id: "off-doors-drawers",
                            label: "door(s) / drawers",
                            roles: ["door", "drawer"],
                            sectionCount: 2,
                            isDefault: true
                        });
                    } else if (pos === "right") {
                        // sink on the right â†’ right bay is the door section
                        layouts.push({
                            id: "off-drawers-doors",
                            label: "drawers / door(s)",
                            roles: ["drawer", "door"],
                            sectionCount: 2,
                            isDefault: true
                        });
                    }
                }

                // ---------- 3-SECTION OFF-CENTER OPTIONS -------------------------
                if (allow3) {
                    // Common 3-sec "all drawers" option
                    addLayout(
                        3,
                        "off-all-drawers",             // â†’ ['drawer','drawer','drawer']
                        "all drawers",
                        ["drawer", "drawer", "drawer"],
                        false
                    );

                    if (pos === "left") {
                        // sink on the left â†’ left section is door bay
                        addLayout(
                            3,
                            "off-doors-drawers-drawers", // â†’ ['door','drawer','drawer']
                            "door(s) / drawers / drawers",
                            ["door", "drawer", "drawer"],
                            defaultCountOff === 3        // default when 3-section is the preferred count
                        );
                    } else if (pos === "right") {
                        // sink on the right â†’ right section is door bay
                        addLayout(
                            3,
                            "off-drawers-drawers-doors", // â†’ ['drawer','drawer','door']
                            "drawers / drawers / door(s)",
                            ["drawer", "drawer", "door"],
                            defaultCountOff === 3        // default when 3-section is the preferred count
                        );
                    }
                }

                // If we successfully built any, de-duplicate and sort, then return.
                if (layouts.length) {
                    // de-duplicate labels & keep the "isDefault" one where applicable
                    const byLabel = new Map();
                    layouts.forEach(layout => {
                        const existing = byLabel.get(layout.label);
                        if (!existing) {
                            byLabel.set(layout.label, layout);
                        } else if (!existing.isDefault && layout.isDefault) {
                            byLabel.set(layout.label, layout);
                        }
                    });

                    const uniqueLayouts = Array.from(byLabel.values());
                    uniqueLayouts.sort((a, b) => {
                        if (a.isDefault && !b.isDefault) return -1;
                        if (!a.isDefault && b.isDefault) return 1;
                        if (a.sectionCount !== b.sectionCount) return a.sectionCount - b.sectionCount;
                        return 0;
                    });

                    return uniqueLayouts;
                }
                // If somehow nothing got built, we fall through to the normal catalog.
            }

            // =========================================================
            // NORMAL CASE: CENTERED or MULTI-SINK
            // (your existing catalog)
            // =========================================================
            allowedCounts.forEach(sectionCount => {
                // 1 SECTION --------------------------------------------------------
                if (sectionCount === 1) {
                    // 0 or 1 sink â†’ same visual choices
                    if (s === 0 || s === 1) {
                        addLayout(1, "1_doors", "door(s)", ["door"], true);
                        addLayout(1, "1_all-drawers", "all drawers", ["drawer"], false);
                    } else if (s === 2) {
                        // not really a thing, but fall back to doors
                        addLayout(1, "1_doors", "door(s)", ["door"], true);
                    }
                }

                // 3 SECTIONS -------------------------------------------------------
                if (sectionCount === 3) {
                    if (s === 0) {
                        addLayout(3, "3_dr-d-dr",
                            "drawers / door(s) / drawers",
                            ["drawer", "door", "drawer"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_d-dr-d",
                            "door(s) / drawers / door(s)",
                            ["door", "drawer", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(3, "3_dr-d-dr",
                            "drawers / door(s) / drawers",
                            ["drawer", "door", "drawer"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(3, "3_d-dr-d",
                            "door(s) / drawers / door(s)",
                            ["door", "drawer", "door"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }

                // 5 SECTIONS -------------------------------------------------------
                if (sectionCount === 5) {
                    if (s === 0) {
                        addLayout(5, "5_dr-d-dr-d-dr",
                            "drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                        addLayout(5, "5_d-dr-d-dr-d",
                            "door(s) / drawers / door(s) / drawers / door(s)",
                            ["door", "drawer", "door", "drawer", "door"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(5, "5_dr-dr-d-dr-dr",
                            "drawers / drawers / door(s) / drawers / drawers",
                            ["drawer", "drawer", "door", "drawer", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(5, "5_dr-d-dr-d-dr",
                            "drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }

                // 7 SECTIONS -------------------------------------------------------
                if (sectionCount === 7) {
                    if (s === 0) {
                        addLayout(7, "7_mixed",
                            "drawers / door(s) / drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(7, "7_center-door",
                            "drawers / door(s) / drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(7, "7_double-door",
                            "drawers / drawers / door(s) / drawers / door(s) / drawers / drawers",
                            ["drawer", "drawer", "door", "drawer", "door", "drawer", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }
            });

            // If nothing was built (very edge-case), fall back to a simple all-doors layout
            if (!layouts.length) {
                const fallbackCount = getDefaultSectionCount(widthIn, s);
                const roles = new Array(fallbackCount).fill("door");
                layouts.push({
                    id: "fallback_doors",
                    label: "door(s)",
                    roles,
                    sectionCount: fallbackCount,
                    isDefault: true
                });
            }

            // ðŸ”¹ Remove duplicate labels (e.g. multiple "door(s)" or "all drawers")
            // If there are duplicates, keep the one marked as default; otherwise keep the first.
            const byLabel = new Map();
            layouts.forEach(layout => {
                const existing = byLabel.get(layout.label);
                if (!existing) {
                    byLabel.set(layout.label, layout);
                } else if (!existing.isDefault && layout.isDefault) {
                    byLabel.set(layout.label, layout);
                }
            });

            const uniqueLayouts = Array.from(byLabel.values());

            // Put the "default" layout first, then sort by section count for readability
            uniqueLayouts.sort((a, b) => {
                if (a.isDefault && !b.isDefault) return -1;
                if (!a.isDefault && b.isDefault) return 1;
                if (a.sectionCount !== b.sectionCount) return a.sectionCount - b.sectionCount;
                return 0;
            });

            return uniqueLayouts;
        }



        function updateLayoutOptions() {
            const layoutSel = document.getElementById("layoutPreset");
            if (!layoutSel) return;

            const widthIn = Number(document.getElementById("width")?.value) || 0;
            const sinkCount = Number(document.getElementById("sinkCount")?.value) || 0;
            const sinkPosition = document.getElementById("sinkPosition")?.value || "center";

            // no width yet â†’ show a single placeholder option
            if (!widthIn) {
                layoutSel.innerHTML = "";
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "layout";
                layoutSel.appendChild(opt);
                return;
            }

            const layouts = getLayoutsFor(widthIn, sinkCount, sinkPosition);
            const current = layoutSel.value;

            layoutSel.innerHTML = "";

            layouts.forEach(o => {
                const opt = document.createElement("option");
                opt.value = o.id;
                opt.textContent = o.label;
                layoutSel.appendChild(opt);
            });

            // keep current selection if it is still valid
            const stillValid = layouts.some(o => o.id === current);
            if (stillValid) {
                layoutSel.value = current;
            } else if (layouts.length) {
                layoutSel.value = layouts[0].id;
            }
        }

        function updateSinkCountOptions() {
            const sinkSel = document.getElementById("sinkCount");
            const widthInput = document.getElementById("width");
            if (!sinkSel || !widthInput) return;

            const rawWidth = Number(widthInput.value) || 0;

            // find the "2" option inside sinkCount
            const optDouble = Array.from(sinkSel.options).find(o => o.value === "2");
            if (!optDouble) return;

            const canHaveDouble = rawWidth >= MIN_DOUBLE_SINK_WIDTH_IN;

            if (canHaveDouble) {
                optDouble.disabled = false;
            } else {
                // gray it out
                optDouble.disabled = true;

                // if user was on "2", bump them down to something valid
                if (sinkSel.value === "2") {
                    // if vanity is at least "normal single-sink territory", default to 1
                    if (rawWidth >= 24) {
                        sinkSel.value = "1";
                    } else {
                        sinkSel.value = "0";
                    }
                }
            }
        }


        // now we start a new function (works correctly)
        function clearSvg(svg) {
            while (svg.firstChild) svg.removeChild(svg.firstChild);
        }

        function drawVanityOutline(svg, model) {
            const { widthIn, heightIn, scale, floating, toeKickHeightIn } = model;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const leftX = ox;
            const rightX = ox + cabW;

            const topY = oy;

            // bottom should be ABOVE the toe kick, not at full height
            const toeKickPx = floating ? 0 : (toeKickHeightIn * px);
            const caseBottomY = oy + cabH - toeKickPx;

            function line(x1, y1, x2, y2) {
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                l.setAttribute("x1", x1);
                l.setAttribute("y1", y1);
                l.setAttribute("x2", x2);
                l.setAttribute("y2", y2);
                l.setAttribute("stroke", "#000");
                l.setAttribute("stroke-width", "0.5");
                svg.appendChild(l);
            }

            // Top outline
            line(leftX, topY, rightX, topY);

            // Left side
            line(leftX, topY, leftX, caseBottomY);

            // Right side
            line(rightX, topY, rightX, caseBottomY);
        }


        function drawLegs(svg, model) {
            const { heightIn, scale, frame } = model;
            if (!frame || !frame.legs || frame.legs.length === 0) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const legWpx = frame.legWidthIn * px;
            const legBottomY = model.cabinetBottomY ?? (oy + heightIn * px);
            const legHpx = Math.max(legBottomY - oy, 0);


            frame.legs.forEach(leg => {
                const x = ox + leg.xIn * px;
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", oy);
                rect.setAttribute("width", legWpx);
                rect.setAttribute("height", legHpx);
                rect.setAttribute("fill", "none");
                rect.setAttribute("stroke", "#000");
                rect.setAttribute("stroke-width", STROKE);
                svg.appendChild(rect);
            });
        }

        function drawTopRail(svg, model) {
            const { widthIn, scale, frame, removeTopRail } = model;
            if (!frame || removeTopRail) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabWpx = widthIn * px;
            const legWpx = frame.legWidthIn * px;

            const railHpx = frame.topRailHeightIn * px;

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", ox + legWpx);
            rect.setAttribute("y", oy);
            rect.setAttribute("width", cabWpx - legWpx * 2);
            rect.setAttribute("height", railHpx);
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", STRUCTURE_COLOR);
            rect.setAttribute("stroke-width", STROKE);
            svg.appendChild(rect);
        }

        function drawBottomRail(svg, model) {
            const { widthIn, scale, frame, removeBottomRail } = model;
            if (!frame || removeBottomRail) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const cabWpx = widthIn * px;
            const legWpx = frame.legWidthIn * px;

            // Get case opening bounds â€” authoritative
            const { openBottomY } = computeCaseOpeningVertical(model);

            const railHpx = frame.bottomRailHeightIn * px;

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", ox + legWpx);
            rect.setAttribute("y", openBottomY);
            rect.setAttribute("width", cabWpx - legWpx * 2);
            rect.setAttribute("height", railHpx);
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", STRUCTURE_COLOR);
            rect.setAttribute("stroke-width", STROKE);
            svg.appendChild(rect);
        }

        // âš ï¸ INTERNAL GEOMETRY HELPER
        // Do NOT call this directly from drawing functions.
        // Always access via computeGeometry(model).

        function computeCaseOpeningVertical(model) {
            const {
                heightIn,
                toeKickHeightIn,
                frame,
                floating,
                scale,
                removeTopRail,
                removeBottomRail,
                shelfBelow,
                shelfSpaceIn,
                shelfThicknessIn
            } = model;

            const px = scale.inchToPx;
            const oy = scale.originY;
            const cabHpx = heightIn * px;

            // Absolute cabinet bottom
            const cabBottomY = oy + cabHpx;

            // -------------------------------------------------------------
            // TOE KICK
            // -------------------------------------------------------------
            const toeKickPx = floating ? 0 : ((toeKickHeightIn || 4) * px);

            // Start with usable interior bottom
            let caseBottomY = cabBottomY - toeKickPx;

            // -------------------------------------------------------------
            // SHELF (single source of truth)
            // -------------------------------------------------------------
            const shelfGapPx = (shelfSpaceIn || DEFAULT_SHELF_SPACE_IN) * px;
            const shelfThPx = shelfBelow
                ? (shelfThicknessIn || 0.75) * px
                : null;

            let shelfBottomY = null;
            let shelfTopY = null;

            if (shelfBelow) {
                shelfBottomY = caseBottomY;
                shelfTopY = shelfBottomY - shelfThPx;

                // Remove shelf + gap from usable opening
                caseBottomY -= (shelfThPx + shelfGapPx);
            }

            // -------------------------------------------------------------
            // RAILS
            // -------------------------------------------------------------
            const topRailHpx = (!removeTopRail && frame?.topRailHeightIn)
                ? frame.topRailHeightIn * px
                : 0;

            const bottomRailHpx = (!removeBottomRail && frame?.bottomRailHeightIn)
                ? frame.bottomRailHeightIn * px
                : 0;

            // -------------------------------------------------------------
            // OPENING SPAN
            // -------------------------------------------------------------
            const openTopY = oy + topRailHpx;
            const openBottomY = removeBottomRail
                ? caseBottomY
                : caseBottomY - bottomRailHpx;

            return {
                // authoritative opening
                openTopY,
                openBottomY,

                // cabinet structure
                cabBottomY,
                caseBottomY,
                toeKickPx,

                // rails
                topRailHpx,
                bottomRailHpx,

                // shelf
                shelfTopY,
                shelfBottomY,
                shelfThicknessPx: shelfThPx
            };
        }


        // âœ… SINGLE SOURCE OF TRUTH FOR ALL CABINET GEOMETRY
        // Drawing code must ONLY read geometry from here.

        function computeGeometry(model) {
            const vertical = computeCaseOpeningVertical(model);

            return {
                vertical: {
                    ...vertical,
                    shelfTopY: vertical.shelfTopY ?? null,
                    shelfBottomY: vertical.shelfBottomY ?? null,
                    shelfThicknessPx: vertical.shelfThicknessPx ?? null
                }
            };
        }



        function drawSectionStiles(svg, model) {
            const {
                sections,
                frame,
                scale,
                removeStiles
            } = model;

            // nothing to draw, or user turned them off
            if (!sections || sections.length < 2 || !frame || removeStiles) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const stileWidthIn = frame.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn;
            const stileWpx = stileWidthIn * px;

            const geom = computeGeometry(model);
            const { openTopY, openBottomY } = geom.vertical;

            const stileHeight = Math.max(openBottomY - openTopY, 0);
            if (stileHeight <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            // one stile per internal section gap:
            // section i runs from sec.xIn .. sec.xIn + sec.widthIn
            // the gap (for the stile) starts at that right edge and is exactly stileWidthIn wide.
            for (let i = 0; i < sections.length - 1; i++) {
                const sec = sections[i];

                // start of the gap between this section and the next
                const gapStartIn = sec.xIn + sec.widthIn;
                const rectX = ox + gapStartIn * px;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", rectX);
                r.setAttribute("y", openTopY);
                r.setAttribute("width", stileWpx);
                r.setAttribute("height", stileHeight);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", STRUCTURE_COLOR);
                r.setAttribute("stroke-width", STROKE);
                svg.appendChild(r);
            }
        }

        function ensureSectionOverride(model, idx) {
            if (!model.sectionOverrides) {
                model.sectionOverrides = {};
            }

            if (!model.sectionOverrides[idx]) {
                model.sectionOverrides[idx] = {
                    drawerCount: null,
                    doorLeaves: null,
                    drawerDimsHidden: false,   // ðŸ‘ˆ default: show dims when override exists
                    interiorShelf: false       // ðŸ‘ˆ default: OFF
                };
            }

        }


        // =======================================================
        // GLOBAL helper used by ALL patch functions
        // =======================================================
        function patchRectCentered(svg, cx, cy, w, h) {

            // Controls the gap between the patch and the rail/stile edge.
            // Increase for shorter patches, decrease for longer.
            const INSET = 0.30;

            const isVertical = h >= w;

            let finalW = w;
            let finalH = h;

            if (isVertical) {
                finalH = Math.max(1, h - INSET * 2);
            } else {
                finalW = Math.max(1, w - INSET * 2);
            }

            const x = cx - finalW / 2;
            const y = cy - finalH / 2;

            const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            r.setAttribute("x", x);
            r.setAttribute("y", y);
            r.setAttribute("width", finalW);
            r.setAttribute("height", finalH);
            r.setAttribute("fill", "#fff");
            r.setAttribute("stroke", "none");

            svg.appendChild(r);
        }

        function drawFrameJointPatches(svg, model) {
            if (!svg || !model || !model.scale || !model.frame) return;

            const {
                widthIn,
                frame,
                scale,
                sections = [],
                removeStiles,
                removeTopRail,
                removeBottomRail
            } = model;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabWpx = widthIn * px;
            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const stileWpx = (frame.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn) * px;

            const stroke = (typeof STROKE === "number" ? STROKE : 0.7);
            const CROSS_THICK = stroke * 2; // the small dimension of patches

            const hasTopRail =
                !removeTopRail &&
                frame.topRailHeightIn &&
                frame.topRailHeightIn > 0;

            const hasBottomRail =
                !removeBottomRail &&
                frame.bottomRailHeightIn &&
                frame.bottomRailHeightIn > 0;

            const geom = computeGeometry(model);
            const { openTopY, openBottomY } = geom.vertical;


            // ======================================================
            // STILE JOINT PATCHES
            // ======================================================
            if (!removeStiles && sections.length > 1 && stileWpx > 0) {
                const pillH = CROSS_THICK;
                const pillW = stileWpx;

                for (let i = 0; i < sections.length - 1; i++) {
                    const sec = sections[i];
                    const gapStartIn = sec.xIn + sec.widthIn;
                    const stileX = ox + gapStartIn * px;
                    const cx = stileX + stileWpx / 2;

                    if (hasTopRail) {
                        patchRectCentered(svg, cx, openTopY, pillW, pillH);
                    }
                    if (hasBottomRail) {
                        patchRectCentered(svg, cx, openBottomY, pillW, pillH);
                    }
                }
            }

            // ======================================================
            // TOP RAIL PATCHES (vertical)
            // ======================================================
            if (hasTopRail) {
                const railH = frame.topRailHeightIn * px;
                const cxL = ox + legWpx;
                const cxR = ox + cabWpx - legWpx;
                const cy = oy + railH / 2;

                patchRectCentered(svg, cxL, cy, CROSS_THICK, railH);
                patchRectCentered(svg, cxR, cy, CROSS_THICK, railH);
            }

            // ======================================================
            // BOTTOM RAIL PATCHES (vertical)
            // ======================================================
            if (hasBottomRail) {
                const railH = frame.bottomRailHeightIn * px;
                const cy = openBottomY + railH / 2;
                const cxL = ox + legWpx;
                const cxR = ox + cabWpx - legWpx;

                patchRectCentered(svg, cxL, cy, CROSS_THICK, railH);
                patchRectCentered(svg, cxR, cy, CROSS_THICK, railH);
            }

            // ======================================================
            // DRAWER RAIL PATCHES (vertical)
            // ======================================================
            const hasDrawer = sections.some(s => s.role === "drawer");
            if (!hasDrawer) return;

            const openingH = openBottomY - openTopY;
            if (openingH <= 0) return;

            sections.forEach((sec, sectionIndex) => {
                if (sec.role !== "drawer") return;

                const faceLeft = ox + sec.xIn * px;
                const faceRight = faceLeft + sec.widthIn * px;

                // ðŸ”’ MUST match the exact layout used to DRAW the drawers
                const layout = getFinalDrawerLayoutForSection(
                    model,
                    sectionIndex,
                    openingH
                );

                if (!layout || layout.mode === "none" || layout.railHeightPx <= 0) return;

                const railH = layout.railHeightPx;
                let curY = openTopY;

                for (let i = 0; i < layout.drawerCount; i++) {
                    curY += layout.heightsPx[i];

                    const place =
                        (layout.mode === "all" && i < layout.drawerCount - 1) ||
                        (layout.mode === "top" && i === 0 && layout.drawerCount > 1);

                    if (place) {
                        const cy = curY + railH / 2;
                        patchRectCentered(svg, faceLeft, cy, CROSS_THICK, railH);
                        patchRectCentered(svg, faceRight, cy, CROSS_THICK, railH);

                        curY += railH; // step past the rail
                    }
                }
            });
        }

        function drawShelf(svg, model) {
            const geom = computeGeometry(model).vertical;
            if (!model.shelfBelow) return;
            if (geom.shelfTopY == null || geom.shelfThicknessPx == null) return;

            const { scale, frame, widthIn } = model;
            const px = scale.inchToPx;
            const ox = scale.originX;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const cabWpx = widthIn * px;

            const shelfRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shelfRect.setAttribute("x", ox + legWpx);
            shelfRect.setAttribute("y", geom.shelfTopY);
            shelfRect.setAttribute("width", cabWpx - legWpx * 2);
            shelfRect.setAttribute("height", geom.shelfThicknessPx);
            shelfRect.setAttribute("fill", "none");
            shelfRect.setAttribute("stroke", STRUCTURE_COLOR);
            shelfRect.setAttribute("stroke-width", STROKE);

            svg.appendChild(shelfRect);
        }



        function drawShelfPatches(svg, model) {
            const geom = computeGeometry(model).vertical;


            if (!model.shelfBelow) return;
            if (geom.shelfTopY == null || geom.shelfThicknessPx == null) return;

            const shelfH = geom.shelfThicknessPx;


            const { scale, frame, widthIn } = model;
            const px = scale.inchToPx;
            const ox = scale.originX;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const cabWpx = widthIn * px;

            const stroke = (typeof STROKE === "number" ? STROKE : 0.7);
            const CROSS_THICK = stroke * 2.0;


            const cxL = ox + legWpx;
            const cxR = ox + cabWpx - legWpx;
            const cy = model.shelfTopY + shelfH / 2;

            patchRectCentered(svg, cxL, cy, CROSS_THICK, shelfH);
            patchRectCentered(svg, cxR, cy, CROSS_THICK, shelfH);
        }


        // Compute per-row drawer heights (in pixels) for a 3-drawer stack
        // based on the top-drawer preset ("equal" or numeric inches).
        function computeDrawerRowHeightsPx(openingHeightPx, px, topDrawerOption) {
            const drawerCount = 3;

            // fallback: equal stack
            if (!topDrawerOption || topDrawerOption === "equal") {
                const h = openingHeightPx / drawerCount;
                return [h, h, h];
            }

            const asNumber = parseFloat(topDrawerOption);
            if (!isFinite(asNumber) || asNumber <= 0) {
                const h = openingHeightPx / drawerCount;
                return [h, h, h];
            }

            let topPx = asNumber * px;

            // keep lower drawers from collapsing
            const MIN_ROW_IN = 2.0;                // 2" minimum per lower drawer
            const minRowPx = MIN_ROW_IN * px;

            if (topPx > openingHeightPx - 2 * minRowPx) {
                topPx = openingHeightPx - 2 * minRowPx;
            }

            const remaining = openingHeightPx - topPx;
            const midPx = remaining / 2;
            const botPx = remaining / 2;

            return [topPx, midPx, botPx];
        }

        // Compute drawer row heights AND account for horizontal rails between drawers
        function computeDrawerLayout(
            openingHeightPx,
            px,
            topDrawerOption,
            railsMode,
            railHeightIn,
            model            // ðŸ‘ˆ ADD MODEL
        ) {
            // -----------------------------------------
            // 1) Decide BASE drawer count (intent)
            // -----------------------------------------
            const shelfBelow = !!model?.shelfBelow;

            let drawerCount = shelfBelow ? 2 : 3;

            // -----------------------------------------
            // 2) Compute raw drawer heights
            // -----------------------------------------
            let heights;

            if (drawerCount === 3) {
                heights = computeDrawerRowHeightsPx(openingHeightPx, px, topDrawerOption);
            } else {
                const equalHpx = openingHeightPx / 2;
                heights = [equalHpx, equalHpx];
            }

            // -----------------------------------------
            // 3) Enforce minimum drawer face height
            // -----------------------------------------
            const MIN_FACE_IN = 5;
            const minRowIn = Math.min(...heights.map(hpx => hpx / px));

            if (!isFinite(minRowIn) || minRowIn < MIN_FACE_IN) {
                drawerCount = 2;
                const equalHpx = openingHeightPx / 2;
                heights = [equalHpx, equalHpx];
            }

            // -----------------------------------------
            // 4) Rails setup
            // -----------------------------------------
            let mode = railsMode || "none";
            let railIn = railHeightIn;
            if (!isFinite(railIn) || railIn <= 0) railIn = DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            const railPx = railIn * px;

            let railsCount = 0;
            if (mode === "top") {
                railsCount = drawerCount > 1 ? 1 : 0;
            } else if (mode === "all") {
                railsCount = Math.max(drawerCount - 1, 0);
            }

            const totalRailPx = railPx * railsCount;

            // -----------------------------------------
            // 5) Bail out if rails donâ€™t fit
            // -----------------------------------------
            if (
                mode === "none" ||
                totalRailPx <= 0 ||
                totalRailPx >= openingHeightPx * 0.9
            ) {
                return {
                    drawerCount,
                    heightsPx: heights,
                    railCount: 0,
                    railHeightPx: 0,
                    mode: "none"
                };
            }

            // -----------------------------------------
            // 6) Shrink drawer faces to make room for rails
            // -----------------------------------------
            const scaleFactor = (openingHeightPx - totalRailPx) / openingHeightPx;
            const scaledHeights = heights.map(h => h * scaleFactor);

            return {
                drawerCount,
                heightsPx: scaledHeights,
                railCount: railsCount,
                railHeightPx: railPx,
                mode
            };
        }

        function getDrawerCountForSection(model, sectionIndex, defaultCount) {
            const o = model.sectionOverrides?.[sectionIndex];
            if (!o || typeof o.drawerCount !== "number") {
                return defaultCount;
            }
            return Math.max(1, Math.round(o.drawerCount));
        }

        function getDoorLeafRulesForSection(sec) {
            const openingIn = sec.widthIn;

            // hard rules
            let minLeaves = 1;
            let maxLeaves = 1;

            if (openingIn >= 20 && openingIn <= 26) {
                minLeaves = 1;
                maxLeaves = 2;
            } else if (openingIn > 26) {
                minLeaves = 2;
                maxLeaves = 2;
            }

            return { minLeaves, maxLeaves };
        }


        function drawSectionFronts(svg, model) {
            const { sections, scale } = model;
            if (!sections || sections.length === 0) return;

            const doorStyle = model.doorStyle || "shaker";
            const drawerStyle = model.drawerStyle || "slab";
            const drawerRailsMode = model.drawerRailsMode || "none";
            const drawerRailHeightIn = model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const topDrawerOption = model.topDrawerHeightPreset || "equal";

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const openingHeight = Math.max(openBottomY - openTopY, 0);
            if (openingHeight <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            // =========================
            // FACE RECT HELPER
            // =========================
            function drawFaceRect(x, y, w, h) {
                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", x);
                r.setAttribute("y", y);
                r.setAttribute("width", w);
                r.setAttribute("height", h);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", STRUCTURE_COLOR);
                r.setAttribute("stroke-width", STROKE);
                svg.appendChild(r);
                return r;
            }

            // =========================
            // SHAKER PANELS
            // =========================
            function addShakerPanels(x, y, w, h, railIn, kind) {
                const railPx = railIn * px;
                const inner1X = x + railPx;
                const inner1Y = y + railPx;
                const inner1W = w - 2 * railPx;
                const inner1H = h - 2 * railPx;
                if (inner1W <= 0 || inner1H <= 0) return;

                drawFaceRect(inner1X, inner1Y, inner1W, inner1H);

                if (kind === "double") {
                    const gapPx = 0.375 * px;
                    drawFaceRect(
                        inner1X + gapPx,
                        inner1Y + gapPx,
                        inner1W - 2 * gapPx,
                        inner1H - 2 * gapPx
                    );
                }
            }

            function resolveDrawerStyleForRow(baseStyle, rowIndex) {
                if (baseStyle === "slab-shaker") return rowIndex === 0 ? "slab" : "shaker";
                if (baseStyle === "slab-double-shaker") return rowIndex === 0 ? "slab" : "double-shaker";
                return baseStyle;
            }

            function computeEffectiveDrawerRails(style, faceHeightPx, px) {
                if (style === "slab") return { kind: "slab", railIn: 0 };

                const faceHeightIn = faceHeightPx / px;
                const minRailIn = 1.5;
                const minPanelIn = 2.0;

                if (faceHeightIn < 2 * minRailIn + minPanelIn) {
                    return { kind: "slab", railIn: 0 };
                }

                const maxRail = (faceHeightIn - minPanelIn) / 2;
                const railIn = Math.max(minRailIn, Math.min(2.0, maxRail));
                return { kind: style === "double-shaker" ? "double" : "single", railIn };
            }

            function drawDrawerFaceDimsForSection(
                svg,
                model,
                sectionIndex,
                x,
                topY,
                widthPx,
                openingHeightPx,
                layout
            ) {

                // ---------------------------------------------
                // GLOBAL REDUNDANCY CHECK â€” override dims only
                // ---------------------------------------------
                const sections = model.sections || [];
                const drawerSections = sections
                    .map((sec, idx) => ({ sec, idx }))
                    .filter(o => o.sec.role === "drawer");

                // if only one drawer section, override dims are meaningless
                if (drawerSections.length <= 1) return;

                // compute effective drawer counts for all drawer sections
                const fullOpeningHeightPx =
                    computeCaseOpeningVertical(model).openBottomY -
                    computeCaseOpeningVertical(model).openTopY;

                const counts = drawerSections.map(({ idx }) => {
                    const baseLayout = computeDrawerLayout(
                        fullOpeningHeightPx,
                        model.scale.inchToPx,
                        model.topDrawerHeightPreset || "equal",
                        model.drawerRailsMode || "none",
                        model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                        model
                    );

                    return getDrawerCountForSection(
                        model,
                        idx,
                        baseLayout.drawerCount
                    );
                });

                // if all drawer counts are equal, override dims add no info
                const allEqual = counts.every(c => c === counts[0]);
                if (allEqual) return;

                const overrides = model?.sectionOverrides || (typeof sectionOverrides !== "undefined" ? sectionOverrides : {});
                const o = overrides?.[sectionIndex];

                const format = model._formatInchesFraction || formatInchesFraction;

                // must have an override
                if (!o || typeof o.drawerCount !== "number") return;

                // --------------------------------------------------
                // DETERMINE TRUE DEFAULT DRAWER COUNT
                // --------------------------------------------------
                const baseLayout = computeDrawerLayout(
                    openingHeightPx,
                    model.scale.inchToPx,
                    model.topDrawerHeightPreset || "equal",
                    model.drawerRailsMode || "none",
                    model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                    model
                );

                const defaultCount = baseLayout.drawerCount;

                // ðŸ”‘ if override matches default â†’ DO NOT show override dims
                if (o.drawerCount === defaultCount) return;

                // user explicitly hid them
                if (o.drawerDimsHidden) return;

                const ns = "http://www.w3.org/2000/svg";
                const px = model.scale.inchToPx;

                // visual style â€” subtle
                const DIM_COLOR = "#94a3b8"; // slate-400
                const FONT_SIZE = 8;

                // centered within THIS SECTION
                const dimX = x + widthPx / 2;

                let curY = topY;

                layout.heightsPx.forEach((hPx, i) => {
                    const y1 = curY;
                    const y2 = curY + hPx;

                    const midY = y1 + hPx / 2;

                    const label = document.createElementNS(ns, "text");
                    label.setAttribute("x", dimX);
                    label.setAttribute("y", midY);
                    label.setAttribute("font-size", FONT_SIZE);
                    label.setAttribute("text-anchor", "middle");
                    label.setAttribute("dominant-baseline", "middle");
                    label.setAttribute("fill", DIM_COLOR);
                    label.setAttribute("fill-opacity", "0.6");
                    label.textContent = `${format(hPx / px)}"`;
                    svg.appendChild(label);

                    curY += hPx;

                    // skip rails visually
                    if (layout.railHeightPx > 0) {
                        if (
                            (layout.mode === "all" && i < layout.drawerCount - 1) ||
                            (layout.mode === "top" && i === 0)
                        ) {
                            curY += layout.railHeightPx;
                        }
                    }
                });
            }


            function drawDrawerStack(x, y, w, h, baseDrawerStyle, sectionIndex) {

                // ðŸ”‘ SINGLE SOURCE OF TRUTH
                const layout = getFinalDrawerLayoutForSection(
                    model,
                    sectionIndex,
                    h
                );

                let curY = y;

                drawDrawerFaceDimsForSection(
                    svg,
                    model,
                    sectionIndex,
                    x,
                    y,
                    w,
                    h,
                    layout
                );

                layout.heightsPx.forEach((drawerH, i) => {
                    const rowStyle = resolveDrawerStyleForRow(baseDrawerStyle, i);
                    drawFaceRect(x, curY, w, drawerH);

                    if (rowStyle !== "slab") {
                        const eff = computeEffectiveDrawerRails(rowStyle, drawerH, model.scale.inchToPx);
                        if (eff.railIn > 0) {
                            addShakerPanels(x, curY, w, drawerH, eff.railIn, eff.kind);
                        }
                    }

                    curY += drawerH;

                    // ðŸ”’ rails between drawers ONLY
                    if (
                        layout.railHeightPx > 0 &&
                        (
                            (layout.mode === "all" && i < layout.drawerCount - 1) ||
                            (layout.mode === "top" && i === 0 && layout.drawerCount > 1)
                        )
                    ) {
                        drawFaceRect(x, curY, w, layout.railHeightPx);
                        curY += layout.railHeightPx;
                    }
                });
            }



            // =====================================================
            // MAIN LOOP
            // =====================================================
            sections.forEach((sec, idx) => {
                const isSelected = idx === selectedSectionIndex;

                const faceX = ox + sec.xIn * px;
                const faceW = sec.widthIn * px;
                const faceTop = openTopY;
                const faceH = openingHeight;

                // ------------------------
                // DRAW CONTENT
                // ------------------------
                if (sec.role === "drawer") {
                    drawDrawerStack(faceX, faceTop, faceW, faceH, drawerStyle, idx);
                } else {
                    drawFaceRect(faceX, faceTop, faceW, faceH);
                    const o = sectionOverrides?.[idx];

                    const openingIn = sec.widthIn;

                    // ----------------------------------
                    // INTERIOR SHELF (VISUAL ONLY)
                    // ----------------------------------
                    if (o?.interiorShelf === true) {

                        const SHELF_GAP_IN = 0.75; // 3/4"
                        const gapPx = SHELF_GAP_IN * px;

                        const midY = faceTop + faceH / 2;

                        const y1 = midY - gapPx / 2;
                        const y2 = midY + gapPx / 2;

                        [y1, y2].forEach(y => {
                            const l = document.createElementNS(ns, "line");
                            l.setAttribute("x1", faceX);
                            l.setAttribute("x2", faceX + faceW);

                            l.setAttribute("y1", y);
                            l.setAttribute("y2", y);

                            // match dimension styling
                            l.setAttribute("stroke", DIM_COLOR);
                            l.setAttribute("stroke-width", 0.3);

                            l.setAttribute("stroke-dasharray", "6 3");


                            svg.appendChild(l);
                        });
                    }



                    // ----------------------------------
                    // DOOR LEAF RESOLUTION + CLAMPING
                    // ----------------------------------

                    // geometry allowance
                    const canHaveOne = openingIn <= 26;
                    const canHaveTwo = openingIn >= 20;

                    // default from geometry
                    let doorLeaves = canHaveTwo ? 2 : 1;

                    // user override (intent)
                    if (o && typeof o.doorLeaves === "number") {
                        doorLeaves = o.doorLeaves;
                    }

                    // clamp to geometry (DO NOT mutate override)
                    if (doorLeaves === 2 && !canHaveTwo) {
                        doorLeaves = 1;
                    }
                    if (doorLeaves === 1 && !canHaveOne) {
                        doorLeaves = 2;
                    }

                    const useDouble = doorLeaves === 2;



                    if (useDouble) {
                        const cx = faceX + faceW / 2;
                        const split = document.createElementNS(ns, "line");
                        split.setAttribute("x1", cx);
                        split.setAttribute("y1", faceTop);
                        split.setAttribute("x2", cx);
                        split.setAttribute("y2", faceTop + faceH);
                        split.setAttribute("stroke", STRUCTURE_COLOR);
                        split.setAttribute("stroke-width", STROKE);
                        svg.appendChild(split);
                    }

                    if (doorStyle !== "slab") {
                        const kind = doorStyle === "double-shaker" ? "double" : "single";
                        const railIn = 2.0;

                        if (useDouble) {
                            const w2 = faceW / 2;
                            addShakerPanels(faceX, faceTop, w2, faceH, railIn, kind);
                            addShakerPanels(faceX + w2, faceTop, w2, faceH, railIn, kind);
                        } else {
                            addShakerPanels(faceX, faceTop, faceW, faceH, railIn, kind);
                        }
                    }
                }

                // ------------------------
                // SELECTION OVERLAY (doors + drawers)
                // ------------------------
                if (isSelected) {
                    const sel = document.createElementNS(ns, "rect");
                    sel.setAttribute("x", faceX);
                    sel.setAttribute("y", faceTop);
                    sel.setAttribute("width", faceW);
                    sel.setAttribute("height", faceH);
                    sel.setAttribute("fill", "none");
                    sel.setAttribute("stroke", "#3b82f6");
                    sel.setAttribute("stroke-width", 1.5);
                    sel.setAttribute("pointer-events", "none");
                    sel.classList.add("section-selected");
                    svg.appendChild(sel);
                }

            });
        }


        function drawSectionHitTargets(svg, model) {
            const { sections, scale } = model;
            if (!sections || !sections.length) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const height = Math.max(openBottomY - openTopY, 0);
            if (height <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            sections.forEach((sec, index) => {
                const x = ox + sec.xIn * px;
                const w = sec.widthIn * px;

                if (w <= 0) return;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", x);
                r.setAttribute("y", openTopY);
                r.setAttribute("width", w);
                r.setAttribute("height", height);

                // invisible but interactive
                r.setAttribute("fill", "transparent");
                r.setAttribute("pointer-events", "all");

                let hoverOverlay = null;

                r.addEventListener("mouseenter", () => {
                    if (selectedSectionIndex !== null) return;

                    const overlay = document.createElementNS(ns, "rect");
                    overlay.setAttribute("x", x);
                    overlay.setAttribute("y", openTopY);
                    overlay.setAttribute("width", w);
                    overlay.setAttribute("height", height);
                    overlay.setAttribute("fill", "#3b82f6");
                    overlay.setAttribute("fill-opacity", "0.10");
                    overlay.setAttribute("pointer-events", "none");

                    svg.appendChild(overlay);
                    hoverOverlay = overlay;
                });

                r.addEventListener("mouseleave", () => {
                    if (hoverOverlay) {
                        hoverOverlay.remove();
                        hoverOverlay = null;
                    }
                });


                r.addEventListener("click", (e) => {
                    e.stopPropagation();

                    // no selection â†’ select
                    if (selectedSectionIndex === null) {
                        selectedSectionIndex = index;
                        updateDrawing();
                        return;
                    }

                    // clicking same section â†’ do nothing
                    if (selectedSectionIndex === index) return;

                    // clicking different section â†’ clear selection
                    selectedSectionIndex = null;
                    updateDrawing();
                });



                svg.appendChild(r);
            });
        }

        function drawSectionControlsOverlay(svg, model) {

            const { sections, scale } = model;
            if (selectedSectionIndex == null) return;
            if (!sections || !sections[selectedSectionIndex]) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const openingHeight = openBottomY - openTopY;
            if (openingHeight <= 0) return;

            const sec = sections[selectedSectionIndex];

            const faceX = ox + sec.xIn * px;
            const faceW = sec.widthIn * px;
            const faceTop = openTopY;

            const ns = "http://www.w3.org/2000/svg";

            // --------------------------------------------------
            // SECTION CONTROL BUTTONS (no side effects yet)
            // --------------------------------------------------
            const buttons = [];

            if (sec.role === "drawer") {
                const current =
                    sectionOverrides[selectedSectionIndex]?.drawerCount ?? 3;

                buttons.push({ id: "add-drawer", label: "add drawer" });

                if (current > 1) {
                    buttons.push({ id: "remove-drawer", label: "remove drawer" });
                }

                const dimsHidden = sectionOverrides[selectedSectionIndex]?.drawerDimsHidden;
                buttons.push({
                    id: "toggle-drawer-dims",
                    label: dimsHidden ? "show dims" : "hide dims"
                });

            }


            if (sec.role === "door") {
                const { minLeaves, maxLeaves } = getDoorLeafRulesForSection(sec);

                // determine current leaf count from drawing state
                // default = geometry-based
                let currentLeaves = (sec.widthIn >= 20 ? 2 : 1);

                // if an override exists, trust it
                const o = sectionOverrides[selectedSectionIndex];
                if (o && typeof o.doorLeaves === "number") {
                    currentLeaves = o.doorLeaves;
                }

                // show ONLY valid transitions
                if (currentLeaves === 1 && maxLeaves === 2) {
                    buttons.push({ id: "make-two-doors", label: "make two doors" });
                }

                if (currentLeaves === 2 && minLeaves === 1) {
                    buttons.push({ id: "make-one-door", label: "make one door" });
                }
                // -----------------------------
                // INTERIOR SHELF TOGGLE
                // -----------------------------
                // âŒ hide interior shelf option when global shelfBelow is enabled
                if (!model.shelfBelow) {
                    const hasShelf =
                        sectionOverrides[selectedSectionIndex]?.interiorShelf === true;

                    buttons.push({
                        id: "toggle-interior-shelf",
                        label: hasShelf ? "remove interior shelf" : "add interior shelf"
                    });
                }


            }




            // --------------------------------------------------
            // CREATE TEXT FIRST (to measure size)
            // --------------------------------------------------
            const textNodes = [];
            let maxTextW = 0;
            let lineH = 0;

            buttons.forEach(btn => {
                const t = document.createElementNS(ns, "text");
                t.textContent = btn.label;
                t.setAttribute("font-size", 12);
                t.setAttribute("font-family", "Raleway, sans-serif");
                t.setAttribute("fill", "#111");
                t.setAttribute("visibility", "hidden");
                svg.appendChild(t);

                const bb = t.getBBox();
                maxTextW = Math.max(maxTextW, bb.width);
                lineH = Math.max(lineH, bb.height);

                textNodes.push({ btn, text: t, bb });
            });


            const PADDING_X = 12;
            const PADDING_Y = 10;
            const GAP_Y = 6;

            const menuW = maxTextW + PADDING_X * 2;
            const menuH =
                buttons.length * lineH +
                (buttons.length - 1) * GAP_Y +
                PADDING_Y * 2;


            // --------------------------------------------------
            // HORIZONTAL PLACEMENT
            // --------------------------------------------------
            const isLast = selectedSectionIndex === sections.length - 1;
            const placeRight = !isLast;

            let menuX = placeRight
                ? faceX + faceW + 8
                : faceX - menuW - 8;

            // Clamp inside cabinet bounds
            const cabLeft = ox;
            const cabRight = ox + model.widthIn * px;

            if (menuX + menuW > cabRight) {
                menuX = cabRight - menuW;
            }
            if (menuX < cabLeft) {
                menuX = cabLeft;
            }

            // --------------------------------------------------
            // VERTICAL PLACEMENT
            // --------------------------------------------------
            let menuY = faceTop + 6;

            const maxY = openBottomY - menuH;
            if (menuY > maxY) {
                menuY = maxY;
            }



            // --------------------------------------------------
            // POSITION TEXT
            // --------------------------------------------------
            let curY = menuY + PADDING_Y;

            textNodes.forEach(({ btn, text, bb }) => {
                const btnH = lineH + 6;

                // button background
                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", menuX);
                r.setAttribute("y", curY);
                r.setAttribute("width", menuW);
                r.setAttribute("height", btnH);
                r.setAttribute("rx", 3);
                r.setAttribute("fill", "#e6f0ff");      // ðŸ”¹ light blue default
                r.setAttribute("stroke", "#3b82f6");    // ðŸ”¹ section outline blue
                r.setAttribute("stroke-width", "1");
                r.style.cursor = "pointer";

                // hover
                r.addEventListener("mouseenter", () => {
                    r.setAttribute("fill", "#d6e6ff");  // slightly stronger blue
                });
                r.addEventListener("mouseleave", () => {
                    r.setAttribute("fill", "#e6f0ff");  // back to default blue
                });



                // click
                r.addEventListener("click", (e) => {
                    e.stopPropagation();

                    if (!sectionOverrides[selectedSectionIndex]) {
                        sectionOverrides[selectedSectionIndex] = {};
                    }

                    const o = sectionOverrides[selectedSectionIndex];

                    // -----------------------------
                    // ADD DRAWER
                    // -----------------------------
                    if (btn.id === "add-drawer") {
                        const current = getDrawerCountForSection(
                            model,
                            selectedSectionIndex,
                            3
                        );
                        o.drawerCount = current + 1;
                        updateDrawing();
                        return;
                    }

                    // -----------------------------
                    // REMOVE DRAWER
                    // -----------------------------
                    if (btn.id === "remove-drawer") {
                        const current = getDrawerCountForSection(
                            model,
                            selectedSectionIndex,
                            3
                        );

                        if (current <= 1) return;

                        const next = current - 1;
                        const baseCount = model.shelfBelow ? 2 : 3;

                        if (next === baseCount) {
                            delete o.drawerCount;
                        } else {
                            o.drawerCount = next;
                        }

                        updateDrawing();
                        return;

                    }

                    // -----------------------------
                    // DOOR LEAF CONTROLS
                    // -----------------------------
                    if (btn.id === "make-one-door") {
                        o.doorLeaves = 1;
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "make-two-doors") {
                        o.doorLeaves = 2;
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "toggle-drawer-dims") {
                        o.drawerDimsHidden = !o.drawerDimsHidden;
                        updateDrawing();
                        return;
                    }
                    if (btn.id === "toggle-interior-shelf") {
                        o.interiorShelf = !o.interiorShelf;
                        updateDrawing();
                        return;
                    }


                });

                svg.appendChild(r);



                // text
                text.setAttribute("x", menuX + 10);
                text.setAttribute("y", curY + btnH / 2 + bb.height / 2 - 1);
                text.setAttribute("visibility", "visible");
                text.setAttribute("pointer-events", "none");

                svg.appendChild(text); // âœ… MOVE TEXT ABOVE BUTTON RECT


                curY += btnH + GAP_Y;
            });

        }


        // ===========================================================
        // PATCH 5 â€” Throttled Update Drawing (Corrected Version)
        // ===========================================================



        function computeRunModel() {
            // For now, exactly one object: the existing vanity
            return {
                objects: [
                    {
                        id: "obj-1",
                        type: "vanity",
                        model: computeModel()
                    }
                ]
            };
        }

        function getActiveDrawingSvg() {
            const isMobile = window.matchMedia("(max-width: 768px)").matches;

            if (isMobile) {
                return document.getElementById("mobileVanityDrawing");
            }

            return document.getElementById("vanityDrawing");
        }

        function computeDrawingScale(svg, model) {
            const {
                widthIn,
                heightIn
            } = model;

            const svgRect = svg.getBoundingClientRect();
            const svgW = svgRect.width;
            const svgH = svgRect.height;

            // === USER-TUNABLE KNOBS (IN INCHES) ===
            const MARGIN_TOP_IN = 10;     // space above sink dims
            const MARGIN_BOTTOM_IN = 8;   // space below cabinet + width dim
            const MARGIN_SIDE_IN = 6;

            // Base px per inch (visual preference)
            const BASE_PX_PER_INCH = 6.0;

            // Cabinet bounds (in inches)
            const contentWIn = widthIn + MARGIN_SIDE_IN * 2;
            const contentHIn = heightIn + MARGIN_TOP_IN + MARGIN_BOTTOM_IN;

            // Fit scale so NOTHING clips
            const fitPxPerInch = Math.min(
                svgW / contentWIn,
                svgH / contentHIn
            );

            // Final scale (never exceed base unless SVG is huge)
            const px = Math.min(BASE_PX_PER_INCH, fitPxPerInch);

            // Center cabinet inside SVG
            const originX =
                (svgW - widthIn * px) / 2;

            const originY =
                MARGIN_TOP_IN * px;

            return {
                inchToPx: px,
                originX,
                originY
            };
        }

        let _drawPending = false;

        function updateDrawing() {
            if (_drawPending) return;
            _drawPending = true;

            requestAnimationFrame(() => {
                _drawPending = false;

                // âœ… Never draw on page 1â€“2 (matches your rule)
                const activePageId = document.querySelector(".page.active")?.id || "";
                const shouldDraw = (activePageId !== "page1" && activePageId !== "page2");

                // keep the mobile drawing wrapper in sync with the page
                updateMobileDrawingVisibility();

                if (!shouldDraw) {
                    // optional: clear both SVGs so no stale drawing lingers
                    const desktopSvg = document.getElementById("vanityDrawing");
                    if (desktopSvg) desktopSvg.innerHTML = "";

                    const mobileSvg = document.getElementById("mobileVanityDrawing");
                    if (mobileSvg) mobileSvg.innerHTML = "";

                    return;
                }

                const model = computeModel();
                if (!model) return;

                // ðŸ”’ UI sync happens ONCE per model, not per draw
                updateDrawerWidthFieldsVisibility(model);
                syncDrawerInputsFromSections(model);
                updateStileAndRailControlsVisibility(model);

                const runModel = computeRunModel();
                if (!runModel) return;

                // =====================================================
                // ðŸ”‘ Draw into the ACTIVE SVG, even if draw code
                // still hard-codes "vanityDrawing"
                // =====================================================
                const activeSvg = getActiveDrawingSvg();
                if (!activeSvg) return;

                const desktopSvg = document.getElementById("vanityDrawing");
                const mobileSvg = document.getElementById("mobileVanityDrawing");

                const wasMobile = (activeSvg === mobileSvg);

                // If mobile is active, temporarily alias its id to "vanityDrawing"
                // so existing draw code continues to work without edits.
                let restoreDesktopId = false;

                if (wasMobile) {
                    if (desktopSvg && desktopSvg !== activeSvg) {
                        desktopSvg.id = "vanityDrawing_desktop";
                        restoreDesktopId = true;
                    }
                    activeSvg.id = "vanityDrawing";
                }

                doActualRunDrawing(runModel);

                // restore ids
                if (wasMobile) {
                    activeSvg.id = "mobileVanityDrawing";
                    if (restoreDesktopId && desktopSvg) {
                        desktopSvg.id = "vanityDrawing";
                    }
                }

                updatePriceDisplay(runModel.objects[0].model);
                updatePriceDisplay(model);
            });
        }

        function drawVanityAtX(svg, model, offsetX) {
            const originalX = model.scale.originX;

            // shift drawing origin
            model.scale.originX = originalX + offsetX;

            // ðŸ”’ EXACT SAME DRAW CALLS AS NORMAL VANITY
            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);

            // restore origin
            model.scale.originX = originalX;
        }

        function doActualRunDrawing(runModel) {
            const svg = getActiveDrawingSvg();
            if (!svg) return;

            clearSvg(svg);

            // ðŸ”’ APPLY VIEWPORT SCALE (ONCE)
            runModel.objects.forEach(obj => {
                if (obj.model) {
                    obj.model.scale = computeDrawingScale(svg, obj.model);
                }
            });

            const basePx = runModel.objects[0]?.model?.scale?.inchToPx;
            if (!basePx) return;


            // -------------------------------
            // 2) DETERMINE TALLEST OBJECT
            // -------------------------------
            let tallestHeightIn = 0;

            runModel.objects.forEach(obj => {
                if (obj.type === "vanity" && obj.model?.heightIn) {
                    tallestHeightIn = Math.max(tallestHeightIn, obj.model.heightIn);
                }
            });

            // -------------------------------
            // 3) HEIGHT-FIRST RULE (scale clamp)
            // -------------------------------
            const MAX_DRAWING_HEIGHT_PX = 700;

            let effectivePx = basePx;

            // temporary gutters for scale decision (will recompute later)
            const TEMP_TOP_GUTTER_PX = 12 * basePx;
            const TEMP_BOTTOM_GUTTER_PX = 10 * basePx;

            const rawHeightPx =
                tallestHeightIn * basePx +
                TEMP_TOP_GUTTER_PX +
                TEMP_BOTTOM_GUTTER_PX;

            if (rawHeightPx > MAX_DRAWING_HEIGHT_PX) {
                effectivePx = basePx * (MAX_DRAWING_HEIGHT_PX / rawHeightPx);
            }

            // -------------------------------
            // 4) GUTTERS (NOW USING effectivePx)
            // -------------------------------
            // sink dims go 7" ABOVE cabinet top
            // we lock this permanently
            const SINK_DIM_OFFSET_IN = 7;

            const LEFT_GUTTER_PX = 10 * effectivePx;
            const RIGHT_GUTTER_PX = 14 * effectivePx;

            const TOP_GUTTER_PX =
                (SINK_DIM_OFFSET_IN + 5) * effectivePx; // +3" hard safety buffer

            const BOTTOM_GUTTER_PX = 10 * effectivePx;

            // -------------------------------
            // 5) DRAW OBJECTS (HORIZONTAL FLOW)
            // -------------------------------
            let cursorX = 0;
            const GAP_PX = 24;

            runModel.objects.forEach(obj => {
                if (obj.type !== "vanity") return;

                obj.model.scale.inchToPx = effectivePx;
                obj.model.scale.originX = LEFT_GUTTER_PX;
                obj.model.scale.originY = TOP_GUTTER_PX;

                drawVanityAtX(svg, obj.model, cursorX);

                cursorX += obj.model.widthIn * effectivePx + GAP_PX;
            });

            // -------------------------------
            // 6) FINAL VIEWPORT SIZE
            // -------------------------------
            const totalWidth =
                cursorX +
                LEFT_GUTTER_PX +
                RIGHT_GUTTER_PX;

            const totalHeight =
                tallestHeightIn * effectivePx +
                TOP_GUTTER_PX +
                BOTTOM_GUTTER_PX;

            svg.setAttribute(
                "viewBox",
                `0 0 ${totalWidth} ${totalHeight}`
            );

            svg.removeAttribute("width");
            svg.removeAttribute("height");
        }



        // DRAW PIPELINE
        // Order matters. Geometry is computed once per frame.
        // Drawing functions must NOT recompute layout or geometry.

        function doActualDrawing(model) {
            const svg = document.getElementById("vanityDrawing");
            if (!svg || !model) return;

            clearSvg(svg);


            // =====================================================
            // MAKEUP DESK BRANCH (DRAW ROUTING ONLY)
            // =====================================================
            if (model.makeupDeskEnabled === true) {
                drawVanityWithMakeupDesk(svg, model);
                return; // ðŸ”’ IMPORTANT: do not fall through
            }

            // =====================================================
            // NORMAL VANITY (UNCHANGED)
            // =====================================================
            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);
        }

        function drawVanityWithMakeupDesk(svg, model) {
            // TEMP: for now, draw EXACTLY the same as a normal vanity
            // This guarantees no regressions while we scaffold.

            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);
        }




        // Decide which sections host sinks based on sinkCount and sinkPosition.
        // Optional second arg lets us run this on a fresh sections array
        // before model.sections has been assigned.
        function computeSinkSectionIndices(model, sectionsOverride) {
            const sections = sectionsOverride || model.sections || [];
            if (!sections.length) return [];

            const sinkCount = model.sinkCount || 0;
            if (!sinkCount) return [];

            const widthIn = model.widthIn || 0;
            const rawPos = model.sinkPosition || "center";

            const lastIndex = sections.length - 1;
            const clampIdx = (idx) => {
                if (idx < 0) return 0;
                if (idx > lastIndex) return lastIndex;
                return idx;
            };

            // === SINGLE SINK =====================================================
            if (sinkCount === 1) {
                // Off-center is only meaningful for:
                //  - exactly 1 sink
                //  - width between 30" and 115"
                const offCenterAllowed =
                    widthIn >= 30 &&
                    widthIn <= 115;

                let sinkPosition = rawPos;
                if (!offCenterAllowed) {
                    sinkPosition = "center";
                }

                let idx;
                if (sinkPosition === "left") {
                    // always first section
                    idx = 0;
                } else if (sinkPosition === "right") {
                    // always last section
                    idx = lastIndex;
                } else {
                    // "center" (or anything else) â†’ pick a center-ish section
                    // For odd counts (3, 5, 7, â€¦) this is the true middle.
                    // For even counts (2, 4, â€¦) this biases slightly left.
                    idx = Math.floor(lastIndex / 2);
                }

                idx = clampIdx(idx);
                return [idx];
            }

            // === DOUBLE SINKS ====================================================
            if (sinkCount === 2) {
                // Build door + drawer section lists with x-centers
                const doorSecs = [];
                const drawerSecs = [];

                sections.forEach((sec, i) => {
                    const centerX = sec.xIn + sec.widthIn / 2;
                    if (sec.role === "door" || sec.role === "sink") {
                        doorSecs.push({ i, x: centerX });
                    } else if (sec.role === "drawer") {
                        drawerSecs.push({ i, x: centerX });
                    }
                });

                // Helper: sort by x ascending
                const byX = (a, b) => a.x - b.x;

                // 1) If we have at least two DOOR sections â†’ use the outermost doors
                //    (e.g. in drawer / door / drawer / door / drawer, this gives sections 2 & 4)
                if (doorSecs.length >= 2) {
                    const sorted = [...doorSecs].sort(byX);
                    return [sorted[0].i, sorted[sorted.length - 1].i];
                }

                // 2) Exactly one door section + some drawers:
                //    pair that door with the FURTHEST drawer bay
                if (doorSecs.length === 1 && drawerSecs.length >= 1) {
                    const d = doorSecs[0];
                    const others = drawerSecs.filter(s => s.i !== d.i);
                    if (others.length) {
                        let best = others[0];
                        let bestDist = Math.abs(others[0].x - d.x);
                        for (let k = 1; k < others.length; k++) {
                            const dist = Math.abs(others[k].x - d.x);
                            if (dist > bestDist) {
                                bestDist = dist;
                                best = others[k];
                            }
                        }
                        return [d.i, best.i].sort((a, b) => a - b);
                    }
                    // if somehow no "others", fall back to outermost drawers
                }

                // 3) No door sections at all â†’ all drawers; use outermost drawers
                if (drawerSecs.length >= 2) {
                    const sorted = [...drawerSecs].sort(byX);
                    return [sorted[0].i, sorted[sorted.length - 1].i];
                }

                // 4) Horrible edge case: not enough info, fall back to 0 & last
                return [0, lastIndex];
            }

            // Other sink counts: nothing to place for now
            return [];
        }



        function drawSinkOutlines(svg, model) {
            const { sections = [], sinkCount = 0, scale } = model;
            if (!sections.length || !sinkCount || !scale) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;
            const ns = "http://www.w3.org/2000/svg";

            const cabTopY = oy;

            // Sinks sit 1/4" below the top
            const SINK_TOP_OFFSET_IN = 0.25;
            const SIDE_MARGIN_IN = 0.25;  // small buffer from section edges

            const sinkTopY = cabTopY + SINK_TOP_OFFSET_IN * px;

            // Decide bowl size from the *section* width: always 15 / 18 / 20
            function pickBowlWidthForSection(secWidthIn) {
                const usable = Math.max(secWidthIn - 2 * SIDE_MARGIN_IN, 0);

                if (usable >= 20) return 20;       // biggest
                if (usable >= 17) return 18;       // mid
                return 15;                         // smallest
            }

            function pickBowlHeight(bowlIn) {
                // you can tweak these, but keep them discrete as well
                if (bowlIn === 15) return 6.0;
                if (bowlIn === 18) return 6.5;
                return 7.0; // for 20"
            }

            const sinkIndices = computeSinkSectionIndices(model);

            sinkIndices.forEach(idx => {
                const sec = sections[idx];
                if (!sec) return;

                const bowlWidthIn = pickBowlWidthForSection(sec.widthIn);
                const bowlHeightIn = pickBowlHeight(bowlWidthIn);

                const sinkWidthPx = bowlWidthIn * px;
                const sinkHeightPx = bowlHeightIn * px;

                const centerIn = sec.xIn + sec.widthIn / 2;
                const centerX = ox + centerIn * px;
                const sinkLeftX = centerX - sinkWidthPx / 2;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", sinkLeftX);
                r.setAttribute("y", sinkTopY);
                r.setAttribute("width", sinkWidthPx);
                r.setAttribute("height", sinkHeightPx);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", SINK_COLOR);
                r.setAttribute("stroke-width", SINK_STROKE);
                r.setAttribute("stroke-dasharray", SINK_DASH);
                svg.appendChild(r);
            });
        }

        // --- 1/16" fraction formatter (local to sink dims) ---
        function formatInchesFraction(val) {
            const negative = val < 0;
            let v = Math.abs(val);

            let sixteenths = Math.round(v * 16);
            const whole = Math.floor(sixteenths / 16);
            let rem = sixteenths % 16;

            if (rem === 0) {
                const base = String(whole);
                return negative ? "-" + base : base;
            }

            function gcd(a, b) {
                while (b !== 0) {
                    const t = a % b;
                    a = b;
                    b = t;
                }
                return a;
            }

            let denom = 16;
            const g = gcd(rem, denom);
            rem /= g;
            denom /= g;

            const frac = `${rem}/${denom}`;
            let result = whole === 0 ? frac : `${whole} ${frac}`;
            return negative ? "-" + result : result;
        }


        function drawSinkDimensions(svg, model) {
            const { sections = [], sinkCount = 0, scale, widthIn } = model;
            if (!sections.length || !sinkCount || !scale || !widthIn) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const ns = "http://www.w3.org/2000/svg";

            const cabW = widthIn * px;
            const leftX = ox;
            const rightX = ox + cabW;
            const cabTopY = oy;

            const ALIGN_FUDGE = 0.5;

            // knob: how far above the top of the cabinet (in drawing inches)
            const SINK_DIM_OFFSET_IN = 7;          // â† change this to move sink dim chain

            const sinkDimY = cabTopY - SINK_DIM_OFFSET_IN * px - ALIGN_FUDGE;


            // draw the little V-shaped arrowheads like in your CAD screenshot
            function drawArrowHead(x, y, dir) {
                // dir = +1 (arrow points right) or -1 (arrow points left)
                const len = 4;   // arrow reach
                const spread = 2;

                const line1 = document.createElementNS(ns, "line");
                line1.setAttribute("x1", x);
                line1.setAttribute("y1", y);
                line1.setAttribute("x2", x + dir * len);
                line1.setAttribute("y2", y - spread);
                line1.setAttribute("stroke", SINK_COLOR);
                line1.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(line1);

                const line2 = document.createElementNS(ns, "line");
                line2.setAttribute("x1", x);
                line2.setAttribute("y1", y);
                line2.setAttribute("x2", x + dir * len);
                line2.setAttribute("y2", y + spread);
                line2.setAttribute("stroke", SINK_COLOR);
                line2.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(line2);
            }

            function createDimSegment(x1, x2, labelText) {
                const midX = (x1 + x2) / 2;

                // dashed blue base line
                const line = document.createElementNS(ns, "line");
                line.setAttribute("x1", x1);
                line.setAttribute("y1", sinkDimY);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", sinkDimY);
                line.setAttribute("stroke", SINK_COLOR);
                line.setAttribute("stroke-width", SINK_STROKE);
                line.setAttribute("stroke-dasharray", SINK_DASH);
                svg.appendChild(line);

                // arrowheads: start points inward toward the segment
                const dir = x2 >= x1 ? 1 : -1;
                drawArrowHead(x1, sinkDimY, dir);      // arrow at start
                drawArrowHead(x2, sinkDimY, -dir);     // arrow at end

                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", midX);
                text.setAttribute("y", sinkDimY - 9);
                text.setAttribute("font-size", "10");
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("fill", SINK_COLOR);
                text.textContent = labelText;
                svg.appendChild(text);
            }

            // figure out centers with sinks
            const sinkIndices = computeSinkSectionIndices(model);
            if (!sinkIndices.length) return;

            const centersIn = sinkIndices.map(idx => {
                const sec = sections[idx];
                return sec.xIn + sec.widthIn / 2;
            }).sort((a, b) => a - b);

            if (centersIn.length === 1) {
                // single sink: leftâ†’center, centerâ†’right
                const c = centersIn[0];
                const xC = ox + c * px;

                const leftDistIn = c;
                const rightDistIn = widthIn - c;

                createDimSegment(
                    leftX - ALIGN_FUDGE,
                    xC - ALIGN_FUDGE,
                    `${formatInchesFraction(leftDistIn)}"`
                );


                createDimSegment(
                    xC - ALIGN_FUDGE,
                    rightX - ALIGN_FUDGE,
                    `${formatInchesFraction(rightDistIn)}"`
                );
            } else {
                // double sink: use outermost centers
                const c1 = centersIn[0];
                const c2 = centersIn[centersIn.length - 1];

                const xC1 = ox + c1 * px;
                const xC2 = ox + c2 * px;

                const leftDistIn = c1;
                const betweenIn = c2 - c1;
                const rightDistIn = widthIn - c2;

                // left end â†’ left sink center
                createDimSegment(
                    leftX - ALIGN_FUDGE,
                    xC1 - ALIGN_FUDGE,
                    `${formatInchesFraction(leftDistIn)}"`
                );

                // between sink centers
                createDimSegment(
                    xC1 - ALIGN_FUDGE,
                    xC2 - ALIGN_FUDGE,
                    `${formatInchesFraction(betweenIn)}"`
                );

                // right sink center â†’ right end
                createDimSegment(
                    xC2 - ALIGN_FUDGE,
                    rightX - ALIGN_FUDGE,
                    `${formatInchesFraction(rightDistIn)}"`
                );
            }

            // vertical blue centerlines: 3" tall, centered on the sink dim line
            const halfCenterLine = (3 * px) / 2;

            sinkIndices.forEach(idx => {
                const sec = sections[idx];
                if (!sec) return;

                const centerIn = sec.xIn + sec.widthIn / 2;
                const centerX = ox + centerIn * px;

                const vTop = sinkDimY - halfCenterLine;
                const vBot = sinkDimY + halfCenterLine;

                const centerLine = document.createElementNS(ns, "line");
                centerLine.setAttribute("x1", centerX);
                centerLine.setAttribute("y1", vTop);
                centerLine.setAttribute("x2", centerX);
                centerLine.setAttribute("y2", vBot);
                centerLine.setAttribute("stroke", SINK_COLOR);
                centerLine.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(centerLine);
            });
        }

        function drawBottomDetail(svg, model) {
            const {
                widthIn,
                heightIn,
                toeKickHeightIn,
                scale,
                frame,
                bottomDetail,
                floating,
                floatingGapIn = 0,
                shelfBelow
            } = model;

            if (!frame || !scale) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;

            const cabBottomYFull = oy + cabH;
            const floorX1 = ox + legWpx;
            const floorX2 = ox + cabW - legWpx;

            const ns = "http://www.w3.org/2000/svg";

            // âœ… READ geometry (never compute or mutate here)
            const geom = computeGeometry(model).vertical;
            const {
                shelfTopY,
                shelfBottomY,
                shelfThicknessPx
            } = geom;

            // -------------------------------------------------------
            // FLOATING MODE
            // -------------------------------------------------------
            if (floating) {
                let gapIn = floatingGapIn;
                if (!gapIn || !isFinite(gapIn) || gapIn < 0) {
                    gapIn = FLOAT_TOP_HEIGHT_IN - heightIn;
                    if (gapIn < 0) gapIn = 0;
                }

                const floorY = cabBottomYFull + gapIn * px;
                const extendPx = 20;

                const floorLine = document.createElementNS(ns, "line");
                floorLine.setAttribute("x1", ox - extendPx);
                floorLine.setAttribute("y1", floorY);
                floorLine.setAttribute("x2", ox + cabW + extendPx);
                floorLine.setAttribute("y2", floorY);
                floorLine.setAttribute("stroke", DIM_COLOR);
                floorLine.setAttribute("stroke-width", DIM_STROKE);
                floorLine.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.insertBefore(floorLine, svg.firstChild);

                const label = document.createElementNS(ns, "text");
                label.setAttribute("x", (floorX1 + floorX2) / 2);
                label.setAttribute("y", floorY - 2 * px);
                label.setAttribute("font-size", "10");
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("dominant-baseline", "middle");
                label.textContent = "floating";
                svg.appendChild(label);

                return;
            }

            // -------------------------------------------------------
            // NON-FLOATING
            // -------------------------------------------------------
            const floorY = cabBottomYFull;

            const openTopY =
                shelfBelow && shelfBottomY != null
                    ? shelfBottomY
                    : cabBottomYFull - ((toeKickHeightIn || 4) * px);

            const labelY = floorY + (openTopY - floorY) / 2;

            // -------------------------------------------------------
            // OPEN BELOW
            // -------------------------------------------------------
            if (bottomDetail === "open-below") {
                const extendPx = 20;

                const floorLine = document.createElementNS(ns, "line");
                floorLine.setAttribute("x1", ox - extendPx);
                floorLine.setAttribute("y1", floorY);
                floorLine.setAttribute("x2", ox + cabW + extendPx);
                floorLine.setAttribute("y2", floorY);
                floorLine.setAttribute("stroke", DIM_COLOR);
                floorLine.setAttribute("stroke-width", DIM_STROKE);
                floorLine.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.insertBefore(floorLine, svg.firstChild);

                const label = document.createElementNS(ns, "text");
                label.setAttribute("x", (floorX1 + floorX2) / 2);
                label.setAttribute("y", labelY);
                label.setAttribute("font-size", "10");
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("dominant-baseline", "middle");
                label.textContent = "open below";
                svg.appendChild(label);

                return;
            }

            // -------------------------------------------------------
            // TOE KICK (DEFAULT)
            // -------------------------------------------------------
            const floorLine = document.createElementNS(ns, "line");
            floorLine.setAttribute("x1", floorX1);
            floorLine.setAttribute("y1", floorY);
            floorLine.setAttribute("x2", floorX2);
            floorLine.setAttribute("y2", floorY);
            floorLine.setAttribute("stroke", STRUCTURE_COLOR);
            floorLine.setAttribute("stroke-width", STROKE);
            svg.appendChild(floorLine);

            const label = document.createElementNS(ns, "text");
            label.setAttribute("x", (floorX1 + floorX2) / 2);
            label.setAttribute("y", labelY);
            label.setAttribute("font-size", "10");
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("dominant-baseline", "middle");
            label.textContent = `${toeKickHeightIn}" toe kick`;
            svg.appendChild(label);
        }



        // DRAW-ONLY FUNCTION
        // Must not modify model or compute geometry.
        // Reads from computeGeometry(model) only.

        function drawSimpleDimensions(svg, model) {
            const {
                widthIn,
                heightIn,
                scale,
                sections = [],
                frame = {},
                removeStiles,
                toeKickHeightIn
            } = model;

            const px = scale.inchToPx;

            const geom = computeGeometry(model);
            const { openTopY, openBottomY, cabBottomY } = geom.vertical;

            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const leftX = ox;
            const rightX = ox + cabW;
            const cabTopY = oy;


            const ns = "http://www.w3.org/2000/svg";

            // tiny visual alignment nudge so dims line up perfectly
            const ALIGN_FUDGE = 0.5;

            // inch-based offsets
            const off2p5Px = 1.5 * px;   // 2.5" in pixels
            const off6Px = 5.0 * px;   // 6" in pixels (overall width)

            // --- helpers ---------------------------------------------------
            const createDimLine = (x1, y1, x2, y2) => {
                const l = document.createElementNS(ns, "line");
                l.setAttribute("x1", x1);
                l.setAttribute("y1", y1);
                l.setAttribute("x2", x2);
                l.setAttribute("y2", y2);
                l.setAttribute("stroke", DIM_COLOR);
                l.setAttribute("stroke-width", DIM_STROKE);
                l.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.appendChild(l);
            };

            const createText = (x, y, text, anchor = "middle") => {
                const t = document.createElementNS(ns, "text");
                t.setAttribute("x", x);
                t.setAttribute("y", y);
                t.setAttribute("font-size", "10"); // dim font
                t.setAttribute("text-anchor", anchor);          // <- use param
                t.setAttribute("dominant-baseline", "middle");
                t.setAttribute("fill", DIM_COLOR);
                t.textContent = text;
                svg.appendChild(t);
            };


            // round to nearest 1/16" and format as fraction
            function formatInchesFraction(val) {
                const negative = val < 0;
                let v = Math.abs(val);

                // nearest 1/16
                let sixteenths = Math.round(v * 16); // integer
                const whole = Math.floor(sixteenths / 16);
                let rem = sixteenths % 16;

                if (rem === 0) {
                    // pure whole number
                    const base = String(whole);
                    return negative ? "-" + base : base;
                }

                // reduce fraction rem/16
                function gcd(a, b) {
                    while (b !== 0) {
                        const t = a % b;
                        a = b;
                        b = t;
                    }
                    return a;
                }

                let denom = 16;
                const g = gcd(rem, denom);
                rem /= g;
                denom /= g;

                const frac = `${rem}/${denom}`;
                let result;
                if (whole === 0) {
                    result = frac;
                } else {
                    // e.g. 26 3/16
                    result = `${whole} ${frac}`;
                }

                return negative ? "-" + result : result;
            }

            // dashed vertical tick centered on dim line
            const createVerticalTick = (x, dimY) => {
                const tickLen = 6;
                const half = tickLen / 2;
                const pattern = "2 2";

                const up = document.createElementNS(ns, "line");
                up.setAttribute("x1", x);
                up.setAttribute("y1", dimY - half);
                up.setAttribute("x2", x);
                up.setAttribute("y2", dimY);
                up.setAttribute("stroke", DIM_COLOR);
                up.setAttribute("stroke-width", DIM_STROKE);
                up.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(up);

                const dn = document.createElementNS(ns, "line");
                dn.setAttribute("x1", x);
                dn.setAttribute("y1", dimY);
                dn.setAttribute("x2", x);
                dn.setAttribute("y2", dimY + half);
                dn.setAttribute("stroke", DIM_COLOR);
                dn.setAttribute("stroke-width", DIM_STROKE);
                dn.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(dn);
            };

            // dashed horizontal tick centered on dim line
            const createHorizontalTick = (dimX, y) => {
                const tickLen = 6;
                const half = tickLen / 2;
                const pattern = "2 2";

                const left = document.createElementNS(ns, "line");
                left.setAttribute("x1", dimX - half);
                left.setAttribute("y1", y);
                left.setAttribute("x2", dimX);
                left.setAttribute("y2", y);
                left.setAttribute("stroke", DIM_COLOR);
                left.setAttribute("stroke-width", DIM_STROKE);
                left.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(left);

                const right = document.createElementNS(ns, "line");
                right.setAttribute("x1", dimX);
                right.setAttribute("y1", y);
                right.setAttribute("x2", dimX + half);
                right.setAttribute("y2", y);
                right.setAttribute("stroke", DIM_COLOR);
                right.setAttribute("stroke-width", DIM_STROKE);
                right.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(right);
            };

            // === OVERALL WIDTH (below the floor line) =============================
            // knob: how far below the floor line (in drawing inches)
            const OVERALL_WIDTH_OFFSET_IN = 4;      // â† change this number to move it

            const overallWidthY = cabBottomY + OVERALL_WIDTH_OFFSET_IN * px + ALIGN_FUDGE;
            const dimLeftX = leftX - ALIGN_FUDGE;
            const dimRightX = rightX - ALIGN_FUDGE;

            createDimLine(dimLeftX, overallWidthY, dimRightX, overallWidthY);
            createVerticalTick(dimLeftX, overallWidthY);
            createVerticalTick(dimRightX, overallWidthY);

            // text sits just below the dim line
            createText(
                dimLeftX + cabW / 2,
                overallWidthY + 10,
                `${formatInchesFraction(widthIn)}"`
            );


            // === SECTION WIDTHS (2.5" above cabinet) =============================
            if (sections && sections.length > 0) {
                const sectionLineY = cabTopY - off2p5Px - ALIGN_FUDGE;

                sections.forEach(sec => {
                    const leftIn = sec.xIn;
                    const rightIn = sec.xIn + sec.widthIn;
                    const faceWidthIn = rightIn - leftIn;
                    if (faceWidthIn <= 0) return;

                    const leftPx = ox + leftIn * px - ALIGN_FUDGE;
                    const rightPx = ox + rightIn * px - ALIGN_FUDGE;

                    createDimLine(leftPx, sectionLineY, rightPx, sectionLineY);
                    createVerticalTick(leftPx, sectionLineY);
                    createVerticalTick(rightPx, sectionLineY);

                    const midX = leftPx + (rightPx - leftPx) / 2;
                    createText(
                        midX,
                        sectionLineY - 8,
                        `${formatInchesFraction(faceWidthIn)}"`
                    );
                });
            }


            // === OVERALL HEIGHT (left side, 2.5" away) ===========================
            const dimTopY = cabTopY - ALIGN_FUDGE;
            const dimBottomY = cabBottomY - ALIGN_FUDGE;
            const dimXLeftSide = leftX - off2p5Px - ALIGN_FUDGE;

            createDimLine(dimXLeftSide, dimTopY, dimXLeftSide, dimBottomY);
            createHorizontalTick(dimXLeftSide, dimTopY);
            createHorizontalTick(dimXLeftSide, dimBottomY);

            // 1" text gap from the dim line (in drawing inches)
            const labelGapIn = 1;
            const labelX = dimXLeftSide - labelGapIn * px;

            createText(
                labelX,
                dimTopY + cabH / 2,
                `${formatInchesFraction(heightIn)}"`,
                "end" // right-align text at labelX
            );




            // === DRAWER FACE HEIGHTS (right side, 2.5" away) ====================
            const hasDrawerSection = sections.some(sec => sec.role === "drawer");

            if (hasDrawerSection) {

                const openingHeightPx = openBottomY - openTopY;

                if (openingHeightPx > 0) {
                    const drawerDimX = rightX + off2p5Px + ALIGN_FUDGE;
                    const topDrawerOption = model.topDrawerHeightPreset || "equal";

                    const drawerRailsMode = model.drawerRailsMode || "none";
                    const drawerRailHeightIn = model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN;

                    // ---------------------------------------------
                    // STANDARD DRAWER DIMS â€” authoritative count
                    // ---------------------------------------------
                    const drawerSections = sections
                        .map((sec, idx) => ({ sec, idx }))
                        .filter(o => o.sec.role === "drawer");

                    // base drawer count MUST match section drawing logic
                    const baseCount = model.shelfBelow ? 2 : 3;

                    let effectiveCount = baseCount;

                    // if multiple drawer sections, they must agree
                    if (drawerSections.length) {
                        const counts = drawerSections.map(({ idx }) =>
                            getDrawerCountForSection(model, idx, baseCount)
                        );

                        // only adopt override when all sections match
                        if (counts.every(c => c === counts[0])) {
                            effectiveCount = counts[0];
                        }
                        // ---------------------------------------------
                        // CLAMP to match drawDrawerStack() behavior
                        // (prevents "4 labels but only 3 drawers drawn")
                        // ---------------------------------------------
                        const MIN_FACE_IN = 5;
                        const openingIn = openingHeightPx / px;
                        const maxDrawers = Math.max(1, Math.floor(openingIn / MIN_FACE_IN));
                        effectiveCount = Math.max(1, Math.min(effectiveCount, maxDrawers));

                    }

                    // rebuild heights using the SAME opening height
                    const layout = getFinalDrawerLayoutForSection(
                        model,
                        drawerSections[0]?.idx ?? 0,
                        openingHeightPx
                    );



                    const drawerCount = layout.drawerCount;
                    const heights = layout.heightsPx;
                    const railPx = layout.railHeightPx;

                    let curY = openTopY - ALIGN_FUDGE;

                    for (let i = 0; i < drawerCount; i++) {
                        const segHpx = heights[i] ?? (openingHeightPx / drawerCount);
                        const y1 = curY;
                        const y2 = curY + segHpx;

                        // dim for this drawer face only
                        createDimLine(drawerDimX, y1, drawerDimX, y2);
                        createHorizontalTick(drawerDimX, y1);
                        createHorizontalTick(drawerDimX, y2);

                        const midY = y1 + (y2 - y1) / 2;
                        const segHin = segHpx / px;

                        const textOffsetPx = 1 * px;

                        createText(
                            drawerDimX + textOffsetPx,
                            midY,
                            `${formatInchesFraction(segHin)}"`,
                            "start"
                        );

                        curY += segHpx;

                        // skip over rails so the dim chain visually leaves the 1" gaps
                        if (railPx > 0) {
                            if (drawerRailsMode === "all" && i < drawerCount - 1) {
                                curY += railPx;
                            } else if (drawerRailsMode === "top" && i === 0 && drawerCount > 1) {
                                curY += railPx;
                            }
                        }
                    }
                }
            }


            // === TOE KICK / OPEN-BELOW HEIGHT (right side, below drawers) ==========
            if (!model.floating && toeKickHeightIn && toeKickHeightIn > 0) {
                // same X as drawer height dims
                const dimX = rightX + off2p5Px + ALIGN_FUDGE;

                const toeKickPx = toeKickHeightIn * px;
                const floorY = cabBottomY - ALIGN_FUDGE;   // bottom of cabinet
                const topY = floorY - toeKickPx;         // top of toe-kick/open-below space

                // vertical dim line
                createDimLine(dimX, topY, dimX, floorY);
                createHorizontalTick(dimX, topY);
                createHorizontalTick(dimX, floorY);

                // text 1" away from the dim line
                const labelOffsetPx = 1 * px;
                const midY = topY + (floorY - topY) / 2;

                createText(
                    dimX + labelOffsetPx,
                    midY,
                    `${formatInchesFraction(toeKickHeightIn)}"`,
                    "start"
                );
            }

            // === SHELF OPENING HEIGHT (right side, above shelf) ====================
            if (model.shelfBelow && !model.floating) {

                const shelfTopY = geom.shelfTopY;
                const openTopY = geom.openTopY;

                if (shelfTopY != null && shelfTopY > openTopY) {

                    const dimX = rightX + off2p5Px + ALIGN_FUDGE;

                    createDimLine(dimX, openTopY, dimX, shelfTopY);
                    createHorizontalTick(dimX, openTopY);
                    createHorizontalTick(dimX, shelfTopY);

                    const shelfOpeningIn = (shelfTopY - openTopY) / px;
                    const midY = (openTopY + shelfTopY) / 2;
                    const textOffsetPx = 1 * px;

                    createText(
                        dimX + textOffsetPx,
                        midY,
                        `${formatInchesFraction(shelfOpeningIn)}"`,
                        "start"
                    );
                }
            }


            // === SHELF SPACE DIMENSION (right side, between shelf and bottom rail) ===
            if (model.shelfBelow && !model.floating) {

                const px = scale.inchToPx;
                const shelfTopY = geom.vertical.shelfTopY;
                const bottomRailBottomY = geom.vertical.openBottomY + (geom.vertical.bottomRailHpx || 0);


                // coordinates
                const dimX = rightX + off2p5Px + ALIGN_FUDGE;  // same as drawer + toe kick dims
                const floorY = cabBottomY - ALIGN_FUDGE;

                // draw line
                createDimLine(dimX, bottomRailBottomY, dimX, shelfTopY);
                createHorizontalTick(dimX, bottomRailBottomY);
                createHorizontalTick(dimX, shelfTopY);

                // label 1" to the right of the dim line
                const textOffsetPx = 1 * px;
                const midY = (bottomRailBottomY + shelfTopY) / 2;


                createText(
                    dimX + textOffsetPx,
                    midY,
                    `${formatInchesFraction(model.shelfSpaceIn)}"`,
                    "start"
                );
            }
        }


        function syncBottomHeightLabelAndLimits() {
            const bottomSel = document.getElementById("bottomDetail");
            const toeInput = document.getElementById("toeKickHeight");
            const label = document.getElementById("toeKickLabel");

            if (!bottomSel || !toeInput || !label) return;

            const mode = bottomSel.value;

            if (mode === "toe-kick") {
                label.textContent = "toe kick height (in)";
                toeInput.min = 2.5;
                toeInput.max = 7;

                // if current value is out of toe-kick range, reset to default 4"
                let v = Number(toeInput.value);
                if (!v || v < 2.5 || v > 7) {
                    toeInput.value = 4;
                }
            } else {
                label.textContent = "open below height (in)";
                toeInput.min = 2.5;
                toeInput.max = 24;

                // leave value as-is if present; otherwise start at 4"
                let v = Number(toeInput.value);
                if (!v) toeInput.value = 4;
            }
        }

        function updateBottomControlsVisibility() {
            const floatingSel = document.getElementById("floating");
            const bottomField = document.getElementById("bottomDetailField");
            const heightField = document.getElementById("bottomHeightField");

            if (!floatingSel || !bottomField || !heightField) return;

            const isFloating = floatingSel.value === "true";

            // hide both controls when floating
            if (isFloating) {
                bottomField.style.display = "none";
                heightField.style.display = "none";
            } else {
                bottomField.style.display = "";
                heightField.style.display = "";
            }
        }

        function enforceMinWidth() {
            const widthInput = document.getElementById("width");
            const widthError = document.getElementById("widthError");
            if (!widthInput || !widthError) return;

            let v = Number(widthInput.value);

            // If empty or NaN, clear the error and bail (user hasn't really entered anything yet)
            if (!v && v !== 0) {
                widthError.textContent = "";
                return;
            }

            if (v < MIN_WIDTH_IN) {
                // clamp to 18" and show an error
                widthInput.value = MIN_WIDTH_IN;
                widthError.textContent = `minimum width is ${MIN_WIDTH_IN}"`;
            } else {
                // valid â†’ clear message
                widthError.textContent = "";
            }
        }

        function applyDoorDrawerPreset(preset) {
            const doorSel = document.getElementById("doorStyle");
            const drawerSel = document.getElementById("drawerStyle");
            if (!doorSel || !drawerSel) return;

            switch (preset) {
                case "slab":
                    doorSel.value = "slab";
                    drawerSel.value = "slab";
                    break;

                case "shaker":
                    doorSel.value = "shaker";
                    drawerSel.value = "shaker";
                    break;

                case "double-shaker":
                    doorSel.value = "double-shaker";
                    drawerSel.value = "double-shaker";
                    break;

                case "slab-shaker":
                    // doors = shaker, drawers = slab top + shaker combo
                    doorSel.value = "shaker";
                    drawerSel.value = "slab-shaker";
                    break;

                case "slab-double-shaker":
                    // doors = double shaker, drawers = slab top + double shaker combo
                    doorSel.value = "double-shaker";
                    drawerSel.value = "slab-double-shaker";
                    break;

                default:
                    // safety fallback â€“ do nothing
                    break;
            }
        }

        function updateSinkPositionVisibility() {
            const widthField = document.getElementById("width");
            const sinkCountEl = document.getElementById("sinkCount");
            const sinkPosWrap = document.getElementById("sinkPositionField");
            const sinkPosSel = document.getElementById("sinkPosition");

            if (!widthField || !sinkCountEl || !sinkPosWrap) return;

            const widthIn = Number(widthField.value) || 0;
            const sinkCount = Number(sinkCountEl.value) || 0;

            // only show when:
            //  - exactly 1 sink
            //  - width between 30" and 115"
            const show =
                sinkCount === 1 &&
                widthIn >= 30 &&
                widthIn <= 115;

            sinkPosWrap.style.display = show ? "" : "none";

            // when hidden, force value back to "center" so model stays sane
            if (!show && sinkPosSel) {
                sinkPosSel.value = "center";
            }
        }

        function updateMobileDrawingVisibility() {
            const drawingWrap = document.getElementById("mobile-drawing");
            if (!drawingWrap) return;

            // âœ… don't rely on currentPageIndex (it was undefined in your tests)
            const activePageId = document.querySelector(".page.active")?.id || "page1";

            // hide on page1 + page2 only
            const hide = (activePageId === "page1" || activePageId === "page2");

            drawingWrap.style.display = hide ? "none" : "block";
        }



        function getFinalDrawerLayoutForSection(model, sectionIndex, openingHpx) {
            const px = model.scale.inchToPx;

            const base = computeDrawerLayout(
                openingHpx,
                px,
                model.topDrawerHeightPreset || "equal",
                model.drawerRailsMode || "none",
                model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                model
            );

            // apply override
            const overridden = getDrawerCountForSection(
                model,
                sectionIndex,
                base.drawerCount
            );

            // clamp by min face height
            const MIN_FACE_IN = 5;
            const maxDrawers = Math.floor((openingHpx / px) / MIN_FACE_IN);
            const finalCount = Math.max(1, Math.min(overridden, maxDrawers));

            // force drawer count
            base.drawerCount = finalCount;

            // force rail count
            if (base.mode === "all") {
                base.railCount = Math.max(finalCount - 1, 0);
            } else if (base.mode === "top") {
                base.railCount = finalCount > 1 ? 1 : 0;
            } else {
                base.railCount = 0;
            }

            // recompute heights AFTER rails, preserving top drawer intent
            const totalRailPx = base.railHeightPx * base.railCount;
            const usablePx = openingHpx - totalRailPx;

            // apply top drawer logic only when 3+ drawers
            if (finalCount >= 3) {
                const rawHeights = computeDrawerRowHeightsPx(
                    usablePx,
                    px,
                    model.topDrawerHeightPreset || "equal"
                );

                // safety clamp in case preset returns wrong count
                if (rawHeights.length === finalCount) {
                    base.heightsPx = rawHeights;
                } else {
                    base.heightsPx = Array(finalCount).fill(usablePx / finalCount);
                }
            } else {
                // 1â€“2 drawers â†’ always equal
                base.heightsPx = Array(finalCount).fill(usablePx / finalCount);
            }


            return base;
        }


        function updateStileAndRailControlsVisibility(model) {
            const sections = model.sections || [];
            const sectionCount = sections.length;
            const isSingleSection = sectionCount === 1;

            const removeStilesField = document.getElementById("removeStilesField");
            const removeStilesSel = document.getElementById("removeStiles");
            const stileWidthField = document.getElementById("frameStileWidthField");

            const railsModeField = document.getElementById("drawerRailsModeField");
            const railsModeSel = document.getElementById("drawerRailsMode");
            const railHeightField = document.getElementById("drawerRailHeightField");

            if (!removeStilesField || !stileWidthField || !railsModeField || !railsModeSel || !railHeightField) {
                return;
            }

            if (isSingleSection) {
                // 1-section vanity: no stiles UI, rails allowed
                removeStilesField.style.display = "none";
                stileWidthField.style.display = "none";

                railsModeField.style.display = "";
                const mode = railsModeSel.value || "none";
                railHeightField.style.display = (mode === "none") ? "none" : "";
                return;
            }

            // multi-section vanity
            removeStilesField.style.display = "";

            const stilesRemoved = removeStilesSel && removeStilesSel.value === "true";

            // ðŸ”’ HARD RULE:
            // multi-section + no stiles â†’ rails MUST be none
            if (!isSingleSection && stilesRemoved) {
                if (railsModeSel.value !== "none") {
                    railsModeSel.value = "none";
                }
            }


            // stile width visible only when stiles are present
            stileWidthField.style.display = stilesRemoved ? "none" : "";

            const drawerRailsNote = document.getElementById("drawerRailsNote");
            if (drawerRailsNote) {
                drawerRailsNote.style.display =
                    (!isSingleSection && stilesRemoved && railsModeBeforeStilesOff !== "none")
                        ? "block"
                        : "none";
            }


            // rails controls only meaningful when we have stiles
            if (stilesRemoved) {
                railsModeField.style.display = "none";
                railHeightField.style.display = "none";
            } else {
                railsModeField.style.display = "";
                const mode = railsModeSel.value || "none";
                railHeightField.style.display = (mode === "none") ? "none" : "";
            }
        }

        function updatePriceDisplay(model) {
            const price = computeCurrentPrice(model);
            const formatted = `$${price.toLocaleString()}`;

            const breakdownValue = document.getElementById("currentPrice");
            if (breakdownValue) {
                breakdownValue.textContent = formatted;
            }

            const priceValue = document.getElementById("price-value");
            if (priceValue) {
                priceValue.textContent = formatted;
            }
        }

        function openPriceModal(model) {
            const modal = document.getElementById("price-modal");
            const content = document.getElementById("price-breakdown-content");

            if (!modal || !content) return;

            const breakdown = computePriceBreakdown(model);

            let html = `
        <div class="price-line">
            <span>base price</span>
            <span>$${breakdown.base.toLocaleString()}</span>
        </div>
    `;

            if (breakdown.extras.length) {
                breakdown.extras.forEach(item => {
                    html += `
                <div class="price-line extra">
                    <span>${item.label}</span>
                    <span>+$${item.amount.toLocaleString()}</span>
                </div>
            `;
                });
            }

            html += `
        <div class="price-line price-total">
            <span>total</span>
            <span>$${breakdown.total.toLocaleString()}</span>
        </div>
    `;

            content.innerHTML = html;
            modal.classList.remove("hidden");
        }

        function updateMakeupDeskControlsVisibility() {
            const enabledSel = document.getElementById("makeupDeskEnabled");
            const posField = document.getElementById("makeupDeskPositionField");
            const widthField = document.getElementById("makeupDeskWidthField");
            const heightField = document.getElementById("makeupDeskHeightField");

            if (!enabledSel || !posField || !widthField || !heightField) return;

            const on = enabledSel.value === "yes";

            posField.style.display = on ? "block" : "none";
            widthField.style.display = on ? "block" : "none";
            heightField.style.display = on ? "block" : "none";
        }


        function setupDrawingEngine() {
            ensureSvgSetup();

            // =====================================================
            // 1) APPLY ALL DEFAULT VALUES BEFORE ANYTHING ELSE
            // =====================================================

            const legInput = document.getElementById("frameLegWidth");
            const stileInput = document.getElementById("frameStileWidth");
            const topRailInput = document.getElementById("frameTopRailHeight");
            const bottomRailInput = document.getElementById("frameBottomRailHeight");
            const toeInput = document.getElementById("toeKickHeight");
            const bottomSel = document.getElementById("bottomDetail");

            const drawerRailHeightField = document.getElementById("drawerRailHeightField");
            const drawerRailsNote = document.getElementById("drawerRailsNote");


            if (legInput && !legInput.value) legInput.value = FRAME_DEFAULTS.legWidthIn;
            if (stileInput && !stileInput.value) stileInput.value = FRAME_DEFAULTS.stileWidthIn;
            if (topRailInput && !topRailInput.value) topRailInput.value = FRAME_DEFAULTS.topRailHeightIn;
            if (bottomRailInput && !bottomRailInput.value) bottomRailInput.value = FRAME_DEFAULTS.bottomRailHeightIn;

            if (toeInput) {
                if (!toeInput.value) toeInput.value = 4;
                toeInput.step = 0.25;
            }

            function syncDrawerRailsUI() {
                if (!drawerRailsModeSel || !drawerRailHeightField) return;
                const mode = drawerRailsModeSel.value || "none";

                // show height field only when rails are on
                drawerRailHeightField.style.display = (mode === "none" ? "none" : "");

                // the blue note is only for the moment we *kill* rails because of stiles,
                // so normal mode changes should hide it.
                if (drawerRailsNote && mode !== "none") {
                    drawerRailsNote.style.display = "none";
                }
            }


            // rails between drawers: defaults
            const drawerRailsModeSel = document.getElementById("drawerRailsMode");
            const drawerRailHeightInput = document.getElementById("drawerRailHeightIn");

            if (drawerRailsModeSel && !drawerRailsModeSel.value) {
                drawerRailsModeSel.value = "none";
            }
            if (drawerRailHeightInput && !drawerRailHeightInput.value) {
                drawerRailHeightInput.value = String(DEFAULT_DRAWER_RAIL_HEIGHT_IN);
            }



            const shelfBelowSel = document.getElementById("shelfBelow");
            const shelfSpaceInput = document.getElementById("shelfSpaceIn");

            // defaults
            if (shelfBelowSel && !shelfBelowSel.value) {
                shelfBelowSel.value = "no";
            }
            if (shelfSpaceInput && !shelfSpaceInput.value) {
                shelfSpaceInput.value = 8;
            }

            function updateShelfControlsVisibility() {
                const fld = document.getElementById("shelfSpaceField");
                const thickFld = document.getElementById("shelfThicknessField");
                if (!fld || !thickFld) return;

                const shelfBelow = shelfBelowSel.value === "yes";
                fld.style.display = shelfBelow ? "block" : "none";
                thickFld.style.display = shelfBelow ? "block" : "none";
            }


            // ðŸ”¥ CALL IT ONCE so page loads correctly
            updateShelfControlsVisibility();

            // ðŸ”¥ RUN IT AGAIN every time the dropdown changes
            shelfBelowSel.addEventListener("change", () => {
                updateShelfControlsVisibility();
                updateDrawing();
            });

            const makeupDeskEnabledSel = document.getElementById("makeupDeskEnabled");
            const makeupDeskPositionSel = document.getElementById("makeupDeskPosition");
            const makeupDeskWidthInput = document.getElementById("makeupDeskWidth");
            const makeupDeskHeightInput = document.getElementById("makeupDeskHeight");

            if (makeupDeskEnabledSel && !makeupDeskEnabledSel.value) {
                makeupDeskEnabledSel.value = "no";
            }
            if (makeupDeskPositionSel && !makeupDeskPositionSel.value) {
                makeupDeskPositionSel.value = "center";
            }
            if (makeupDeskWidthInput && !makeupDeskWidthInput.value) {
                makeupDeskWidthInput.value = 26;
            }
            if (makeupDeskHeightInput && !makeupDeskHeightInput.value) {
                makeupDeskHeightInput.value = 4;
            }


            // =====================================================
            // 2) SYNC ALL DEPENDENT UI
            // =====================================================
            syncBottomHeightLabelAndLimits();

            // These MUST run NOW, BEFORE first draw.
            updateLayoutOptions();
            updateBottomControlsVisibility();
            updateSinkCountOptions();
            updateSinkPositionVisibility();
            syncDrawerRailsUI();
            updateMakeupDeskControlsVisibility();


            const presetSel = document.getElementById("doorDrawerPreset");
            if (presetSel && presetSel.value) {
                applyDoorDrawerPreset(presetSel.value);
            }


            // =====================================================
            // 3) RESET DRAWER OVERRIDE FLAGS FOR A CLEAN START
            // =====================================================
            drawerOverrideFlags.single = false;
            drawerOverrideFlags.outer = false;
            drawerOverrideFlags.center = false;
            drawerOverrideFlags.twoSection = false;  // ðŸ‘ˆ new

            const singleInput = document.getElementById("drawerWidthSingle");
            const outerInput = document.getElementById("drawerWidthOuter");
            const centerInput = document.getElementById("drawerWidthCenter");
            const twoSectionInput = document.getElementById("drawerWidthTwoSection"); // ðŸ‘ˆ new

            if (singleInput) singleInput.value = "";
            if (outerInput) outerInput.value = "";
            if (centerInput) centerInput.value = "";
            if (twoSectionInput) twoSectionInput.value = ""; // ðŸ‘ˆ new



            // âš ï¸ ARCHITECTURE RULE:
            // UI â†’ computeModel â†’ computeGeometry â†’ draw
            // Never skip layers.

            // =====================================================
            // 4) ATTACH LISTENERS ONLY AFTER UI IS READY
            // =====================================================
            const ids = [
                "width",
                "height",
                "depth",
                "floating",
                "sinkCount",
                "sinkPosition",
                "toeKickHeight",
                "bottomDetail",
                "frameLegWidth",
                "frameTopRailHeight",
                "frameBottomRailHeight",
                "frameStileWidth",
                "removeTopRail",
                "removeBottomRail",
                "removeStiles",
                "layoutPreset",
                "visibleSides",
                "doorDrawerPreset",
                "doorStyle",
                "drawerStyle",
                "topDrawerHeightPreset",
                "drawerWidthSingle",
                "drawerWidthOuter",
                "drawerWidthCenter",
                "drawerWidthTwoSection",
                "shelfBelow",
                "shelfSpaceIn",
                "shelfThickness",
                // ðŸ”¹ NEW:
                "drawerRailsMode",
                "drawerRailHeightIn",
                "makeupDeskEnabled",
                "makeupDeskPosition",
                "makeupDeskWidth",
                "makeupDeskHeight"

            ];





            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;

                const handler = (evt) => {
                    if (id === "drawerWidthSingle") {
                        drawerOverrideFlags.single = true;
                        lastDrawerEdited = "single";
                    } else if (id === "drawerWidthOuter") {
                        drawerOverrideFlags.outer = true;
                        lastDrawerEdited = "outer";
                    } else if (id === "drawerWidthCenter") {
                        drawerOverrideFlags.center = true;
                        lastDrawerEdited = "center";
                    } else if (id === "drawerWidthTwoSection") {
                        drawerOverrideFlags.twoSection = true;
                        lastDrawerEdited = "twoSection";
                    }
                    if (id === "drawerRailsMode") {
                        syncDrawerRailsUI();
                    }
                    if (id === "makeupDeskEnabled") {
                        updateMakeupDeskControlsVisibility();
                    }


                    // layout changes reset drawer overrides
                    if (
                        id === "width" ||
                        id === "sinkCount" ||
                        id === "layoutPreset" ||
                        id === "sinkPosition"
                    ) {
                        drawerOverrideFlags.single = false;
                        drawerOverrideFlags.outer = false;
                        drawerOverrideFlags.center = false;
                        drawerOverrideFlags.twoSection = false;

                        if (singleInput) singleInput.value = "";
                        if (outerInput) outerInput.value = "";
                        if (centerInput) centerInput.value = "";
                        const twoInput = document.getElementById("drawerWidthTwoSection");
                        if (twoInput) twoInput.value = "";
                    }


                    // width / sinkCount / sinkPosition all affect which layouts are valid
                    if (id === "width" || id === "sinkCount" || id === "sinkPosition") {
                        updateLayoutOptions();
                    }

                    // ONLY width affects which sink counts are allowed
                    if (id === "width") {
                        updateSinkCountOptions();
                    }

                    // show/hide the sink-position dropdown when width or sinkCount changes
                    if (id === "width" || id === "sinkCount") {
                        updateSinkPositionVisibility();
                    }

                    if (id === "bottomDetail") {
                        syncBottomHeightLabelAndLimits();
                    }

                    if (id === "removeStiles") {
                        const stileWidthField = document.getElementById("frameStileWidthField");
                        const drawerRailsNote = document.getElementById("drawerRailsNote");
                        const drawerRailsModeSel = document.getElementById("drawerRailsMode");
                        const drawerRailHeightField = document.getElementById("drawerRailHeightField");

                        const turningStilesOff = (evt.target.value === "true");

                        if (turningStilesOff) {
                            // what rails mode did we have *before* killing it?
                            const prevMode = drawerRailsModeSel ? drawerRailsModeSel.value : "none";
                            const hadRailsBefore = prevMode === "top" || prevMode === "all";

                            // remember it globally so we can restore later
                            railsModeBeforeStilesOff = hadRailsBefore ? prevMode : "none";

                            // hide stile width field
                            if (stileWidthField) stileWidthField.style.display = "none";

                            // kill rails in the UI (drawing will follow because computeModel reads this)
                            if (drawerRailsModeSel) {
                                drawerRailsModeSel.value = "none";
                            }
                            if (drawerRailHeightField) {
                                drawerRailHeightField.style.display = "none";
                            }

                            // show blue note only if we actually had rails before
                            if (drawerRailsNote) {
                                drawerRailsNote.style.display = hadRailsBefore ? "block" : "none";
                            }

                            // keep rails UI in sync
                            if (typeof syncDrawerRailsUI === "function") {
                                syncDrawerRailsUI();
                            }
                        } else {
                            // turning stiles back ON
                            if (stileWidthField) stileWidthField.style.display = "";
                            if (drawerRailsNote) drawerRailsNote.style.display = "none";

                            if (drawerRailsModeSel) {
                                // only restore if we truly had rails before
                                if (railsModeBeforeStilesOff === "top" || railsModeBeforeStilesOff === "all") {
                                    drawerRailsModeSel.value = railsModeBeforeStilesOff;
                                    if (drawerRailHeightField) {
                                        drawerRailHeightField.style.display = "";
                                    }
                                } else {
                                    // there were no rails originally â†’ stay at none
                                    drawerRailsModeSel.value = "none";
                                    if (drawerRailHeightField) {
                                        drawerRailHeightField.style.display = "none";
                                    }
                                }
                            }

                            if (typeof syncDrawerRailsUI === "function") {
                                syncDrawerRailsUI();
                            }
                        }

                        // IMPORTANT: do NOT `return` here.
                        // We want to still fall through to the `updateDrawing();` at the bottom.
                    }



                    if (id === "floating") {
                        updateBottomControlsVisibility();
                    }

                    if (id === "shelfBelow") {
                        updateShelfControlsVisibility();
                    }

                    if (id === "shelfSpaceIn") {
                        // clamp 6â€“12 and snap the field
                        if (shelfSpaceInput) {
                            let v = Number(shelfSpaceInput.value);
                            if (!v || !isFinite(v)) v = 8;
                            if (v < 6) v = 6;
                            if (v > 12) v = 12;
                            shelfSpaceInput.value = v;
                        }
                    }

                    if (id === "toeKickHeight") {
                        let v = Number(toeInput.value);
                        if (!v) v = 4;

                        if (v < 2.5) v = 2.5;
                        if (v > 24) v = 24;
                        toeInput.value = v;

                        if (bottomSel.value === "toe-kick" && v > 7) {
                            bottomSel.value = "open-below";
                            syncBottomHeightLabelAndLimits();
                        }
                    }

                    // ðŸ”¹ NEW: when preset changes, sync door + drawer styles
                    if (id === "doorDrawerPreset") {
                        applyDoorDrawerPreset(evt.target.value);
                    }
                    // only enforce the 18" minimum *after* they're done typing
                    if (id === "width" && evt.type === "change") {
                        enforceMinWidth();
                    }

                    updateDrawing();
                };

                el.addEventListener("input", handler);
                el.addEventListener("change", handler);
            });


            // =====================================================
            // GLOBAL CLICK â€” clear section selection
            // =====================================================
            document.addEventListener("click", (e) => {
                // --- price modal open/close ---
                const modal = document.getElementById("price-modal");
                if (modal) {
                    if (e.target.closest("#price-button")) {
                        const model = computeModel();
                        openPriceModal(model);
                        return;
                    }

                    if (
                        e.target.classList.contains("price-modal-backdrop") ||
                        e.target.classList.contains("price-modal-close")
                    ) {
                        modal.classList.add("hidden");
                        return;
                    }
                }

                // --- clear section selection when clicking outside hit targets ---
                if (selectedSectionIndex !== null) {
                    selectedSectionIndex = null;
                    updateDrawing();
                }
            });




            // =====================================================
            // 5) FINAL â€” FIRST DRAW MUST HAPPEN AFTER ALL SETUP
            // =====================================================
            initialDrawDone = true;
            updateDrawing();
            syncGlobalNavState();

            // ðŸ”‘ FORCE nav visibility for initial page
            updateGlobalNavVisibility("page1");
            setDrawingPanelVisibility("page1");
            updateMobileDrawingVisibility();





        }

        function setupFinishPage() {
            const finishType = document.getElementById("finishType");

            // These now refer to *all fields* with those classes
            const woodFields = document.querySelectorAll(".wood-field");
            const paintFields = document.querySelectorAll(".paint-field");

            const paintFinish = document.getElementById("paintFinish");
            const customColorField = document.getElementById("customColorField");
            const primerColorField = document.getElementById("primerColorField");

            if (!finishType) return;

            // Helper to show/hide groups
            function setDisplay(nodes, value) {
                nodes.forEach(n => n.style.display = value);
            }

            // MAIN FINISH SWITCH
            finishType.addEventListener("change", () => {
                const val = finishType.value;

                // hide everything first
                setDisplay(woodFields, "none");
                setDisplay(paintFields, "none");

                // show only the category
                if (val === "wood") {
                    setDisplay(woodFields, "flex");
                }
                if (val === "paint") {
                    setDisplay(paintFields, "flex");
                }

                // always hide subfields
                if (customColorField) customColorField.style.display = "none";
                if (primerColorField) primerColorField.style.display = "none";
            });

            // PAINT FINISH SUB OPTIONS
            if (paintFinish) {
                paintFinish.addEventListener("change", () => {
                    const val = paintFinish.value;

                    if (customColorField) customColorField.style.display = "none";
                    if (primerColorField) primerColorField.style.display = "none";

                    if (val === "custom") {
                        customColorField.style.display = "flex";
                    }
                    if (val === "primed") {
                        primerColorField.style.display = "flex";
                    }
                });
            }
        }

        window.addEventListener("load", setupFinishPage);

        // =====================================================
        // MOBILE PINCH + PAN FOR DRAWING (CSS TRANSFORM ONLY)
        // =====================================================

        let mobileScale = 1;
        let mobileTranslateX = 0;
        let mobileTranslateY = 0;

        let lastTouchDist = null;
        let lastTouchMid = null;

        function applyMobileTransform() {
            const svg = getActiveDrawingSvg();   // âœ… transform the active svg
            if (!svg) return;

            svg.style.transform =
                `translate(${mobileTranslateX}px, ${mobileTranslateY}px) scale(${mobileScale})`;
        }



        function getTouchDistance(t1, t2) {
            const dx = t2.clientX - t1.clientX;
            const dy = t2.clientY - t1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchMidpoint(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }

        function setupMobileDrawingGestures() {
            const svg = document.getElementById("mobileVanityDrawing"); // gestures only on mobile svg
            if (!svg) return;

            // only enable on mobile widths
            if (window.innerWidth > 768) return;

            svg.addEventListener("touchstart", (e) => {
                if (e.touches.length === 2) {
                    lastTouchDist = getTouchDistance(e.touches[0], e.touches[1]);
                    lastTouchMid = getTouchMidpoint(e.touches[0], e.touches[1]);
                }
            }, { passive: false });

            svg.addEventListener("touchmove", (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();

                    const newDist = getTouchDistance(e.touches[0], e.touches[1]);
                    const newMid = getTouchMidpoint(e.touches[0], e.touches[1]);

                    const scaleDelta = newDist / lastTouchDist;
                    mobileScale *= scaleDelta;

                    // clamp scale
                    mobileScale = Math.max(0.5, Math.min(3, mobileScale));

                    // pan relative to midpoint movement
                    mobileTranslateX += newMid.x - lastTouchMid.x;
                    mobileTranslateY += newMid.y - lastTouchMid.y;

                    lastTouchDist = newDist;
                    lastTouchMid = newMid;

                    applyMobileTransform();
                }
            }, { passive: false });

            svg.addEventListener("touchend", () => {
                lastTouchDist = null;
                lastTouchMid = null;
            });
        }


        window.addEventListener("load", () => {
            setupDrawingEngine();
            setupMobileNavHandlers();
            setupMobileDrawingGestures();
        });


    </script>

    <!-- PRICE BREAKDOWN MODAL -->
    <div id="price-modal" class="price-modal hidden">
        <div class="price-modal-backdrop"></div>

        <div class="price-modal-card">
            <h3>price breakdown</h3>

            <div id="price-breakdown-content"></div>

            <button class="price-modal-close">close</button>
        </div>
    </div>


</body>

</html>
