<!-- TURNERROSSA VANITY BUILDER 2.0 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Turnerrossa Vanity Builder 2.0</title>

    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- =========================================================== -->
    <!-- === SECTION: GLOBAL CSS (DESKTOP + MOBILE)                === -->
    <!-- =========================================================== -->
    <style>
        /* =========================================================
       GLOBAL BASE
    ========================================================= */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Raleway', sans-serif;
        }

        body {
            background: #ffffff;

            color: #222;
            overflow-x: hidden;
            /* prevent sideways scroll */
        }

        :root {
            --desktop-drawing-height: 520px;
            /* <-- DESKTOP DRAWING SIZE DIAL */
        }

        /* =========================================================
       FIELD SYSTEM
    ========================================================= */
        .field-row {
            display: flex;
            flex-wrap: wrap;
            gap: 18px 24px;
            margin-bottom: 18px;
        }

        .field {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-width: 140px;
            max-width: 320px;
        }

        .field.sm {
            max-width: 120px;
        }

        .field.md {
            max-width: 240px;
        }

        .field.lg {
            max-width: 360px;
        }

        .field label {
            margin-bottom: 6px;
            font-size: 14px;
            text-transform: lowercase;
            white-space: nowrap;
            /* prevent wrapping */
        }

        /* allow wrapping for labels that include help icons */
        .field label.label-with-help {
            white-space: normal;
            flex-wrap: wrap;
        }


        /* =========================================================
   HELP ICON + TOOLTIP + MODAL
========================================================= */
        .label-with-help {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .help-icon {
            width: 18px;
            height: 18px;
            border-radius: 999px;

            background: transparent;
            /* no fill */
            border: 1px solid #1a73e8;
            /* thin blue outline */
            color: #1a73e8;
            /* same blue for ? */

            font-size: 12px;
            font-weight: 600;
            font-style: normal;
            line-height: 1;

            display: inline-flex;
            align-items: center;
            justify-content: center;

            cursor: pointer;
            padding: 0;
        }




        /* modal shell */
        .help-modal.hidden {
            display: none;
        }

        .help-modal {
            position: fixed;
            inset: 0;
            z-index: 99999;
        }

        .help-modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
        }

        .help-modal-card {
            position: relative;
            max-width: 420px;
            width: calc(100% - 28px);
            margin: 90px auto;
            background: #fff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        }

        .help-modal-title {
            font-size: 16px;
            font-weight: 600;
            text-transform: lowercase;
            margin: 0 0 10px 0;
        }

        .help-modal-body {
            font-size: 13px;
            color: #374151;
            line-height: 1.4;

            text-align: center;
            /* center under image */
            margin: 0;
        }


        .help-modal-img {
            width: 100%;
            height: auto;
            border-radius: 12px;
            margin: 10px 0 10px 0;
            border: 1px solid #e5e7eb;
            display: none;
            /* shown only when we have an image */
        }

        .help-modal-close {
            margin-top: 12px;
            width: 100%;
            height: 40px;
            border-radius: 10px;
            border: 1px solid #d1d5db;
            background: #f3f4f6;
            color: #111827;
            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
        }

        /* help modal: allow scrolling when content is tall */
        .help-modal-card {
            max-height: 75vh;
            overflow-y: auto;
        }

        /* gallery layout */
        .help-gallery {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .help-style {
            text-align: center;
        }

        .help-style-img {
            width: 100%;
            height: auto;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            display: block;
            margin: 0 auto 8px auto;
        }

        .help-style-title {
            font-size: 14px;
            font-weight: 600;
            text-transform: lowercase;
            margin-bottom: 6px;
        }

        .help-style-notes {
            margin: 0 auto;
            padding-left: 18px;
            text-align: left;
            max-width: 360px;
            color: #374151;
            font-size: 13px;
            line-height: 1.35;
        }

        .help-style-link {
            display: inline-block;
            text-align: center;
            color: #1a73e8;
            text-decoration: underline;
            font-size: 13px;
            margin-top: 4px;
        }

        /* center modal title */
        .help-modal-title {
            text-align: center;
        }

        /* style titles above each image */
        .help-style-title {
            text-align: left;
            font-size: 14px;
            font-weight: 600;
            text-transform: lowercase;
            margin-bottom: 6px;
        }

        /* keep bullet lists consistent */
        .help-style-notes {
            margin: 0 auto;
            padding-left: 18px;
            max-width: 360px;
            text-align: left;
            font-size: 13px;
            line-height: 1.35;
        }

        /* stacked action buttons inside help modal */
        .help-modal-action {
            display: flex;
            align-items: center;
            justify-content: center;

            width: 100%;
            height: 40px;

            border-radius: 10px;
            border: 1px solid #d1d5db;
            background: #f3f4f6;
            color: #111827;

            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
            text-decoration: none;

            margin-top: 10px;
        }

        /* primary action (view more examples) */
        .help-modal-action-primary {
            background: #ffffff;
        }



        .field input,
        .field select {
            padding: 9px 12px;
            border-radius: 10px;
            /* â¬… slightly softer like inputs */
            border: 1px solid #d1d5db;
            /* softer gray */
            font-size: 14px;
            width: 100%;
            background-color: #fff;
            appearance: none;
            /* ðŸ”‘ removes native boxy UI */
            -webkit-text-fill-color: #222;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        /* placeholder styling (page 2 width/height/depth) */
        .field input::placeholder {
            color: #9ca3af;
            /* light gray */
            font-style: italic;
            font-size: 12px;
            /* smaller than input text */
        }

        /* Safari/iOS */
        .field input::-webkit-input-placeholder {
            color: #9ca3af;
            font-style: italic;
            font-size: 12px;
        }

        /* ðŸ”’ Override webkit text fill so placeholder color actually applies */
        .field input::placeholder {
            -webkit-text-fill-color: #9ca3af;
        }

        .field input::-webkit-input-placeholder {
            -webkit-text-fill-color: #9ca3af;
        }


        .field select {
            background-image:
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' stroke='%23666' stroke-width='2' viewBox='0 0 24 24'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 14px;
            padding-right: 36px;
            /* room for arrow */
        }

        .field input:focus,
        .field select:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 1px rgba(26, 115, 232, 0.2);
        }


        .field-note {
            font-size: 11px;
            color: #1373d6;
            margin-top: 4px;
            display: none;
            /* hidden by default */
        }

        .field-error {
            min-height: 14px;
            margin-top: 4px;
            font-size: 11px;
            color: #c0483a;
        }

        /* keep dimension labels on one line and inputs same width */
        .dimension-field label[for="height"] {
            white-space: nowrap;
        }

        .dimension-field input#width,
        .dimension-field input#height,
        .dimension-field input#depth {
            min-width: 240px;
        }

        /* Page 5: align dynamic rows like other pages */
        #page5 .field-row {
            align-items: flex-end;
        }

        #page5 .field-card {
            margin-bottom: 32px;
        }

        /* selection highlight */
        .section-selected {
            stroke: #3b82f6;
            stroke-width: 2;
        }

        /* =========================================================
       DESKTOP LAYOUT
    ========================================================= */
        #desktop-layout {
            display: flex;
            width: 100%;
            min-height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 180px;
            background: #ffffff;
            border-right: 1px solid #e5e5e5;
            padding-top: 30px;
            position: fixed;
            top: 0;
            bottom: 0;
            overflow-y: auto;
        }

        #sidebar .nav-item {
            padding: 12px 16px;
            font-size: 15px;
            text-transform: lowercase;
            cursor: pointer;
            color: #444;
            border-left: 3px solid transparent;
        }

        #sidebar .nav-item:hover {
            background: #f1f3f5;
        }

        #sidebar .nav-item.active {
            background: #e9ebee;
            border-left: 3px solid #1a73e8;
            color: #000;
            font-weight: 600;
        }

        /* Main page area */
        #page-container {
            margin-left: 180px;
            padding: 30px;
            width: calc(100% - 180px);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* hide per-page nav bars; global nav is used */
        .page .nav-buttons {
            display: none;
        }

        /* =========================================================
       FIELD CARD UI
    ========================================================= */
        .field-card {
            background: #fff;
            padding: 22px 24px;
            margin-bottom: 32px;
            border-radius: 14px;
            box-shadow: 0px 3px 12px rgba(0, 0, 0, 0.05);
        }

        .field-card h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 18px;
            text-transform: lowercase;
        }

        /* =========================================================
       NAV BUTTONS (shared styles)
    ========================================================= */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .nav-split {
            justify-content: space-between;
        }

        .nav-left,
        .nav-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background: #1a73e8;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
        }

        .nav-buttons button:disabled {
            background: #b0b0b0;
        }

        .nav-buttons .back {
            background: #999;
        }

        /* =========================================================
       PRICE UI
    ========================================================= */
        .price-wrapper {
            position: relative;
            margin-right: auto;
        }

        .price-breakdown {
            position: absolute;
            bottom: 48px;
            left: 0;
            width: 280px;
            background: #ffffff;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
            z-index: 50;
        }

        .price-breakdown.hidden {
            display: none;
        }

        .price-breakdown h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 6px;
        }

        .price-line {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .price-line.extra {
            padding-left: 10px;
        }

        .price-total {
            font-weight: 600;
            border-top: 1px solid #e5e7eb;
            padding-top: 6px;
            margin-top: 8px;
        }

        .price-button {
            background: #1a73e8;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
            display: flex;
            align-items: center;
        }

        .price-button:hover {
            background: #15803d;
        }

        .price-button:active {
            background: #15803d;
        }

        .price-value {
            font-weight: 700;
            margin-left: 6px;
        }

        /* =========================================================
       PRICE MODAL OVERLAY
    ========================================================= */
        .price-modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .price-modal.hidden {
            display: none;
        }

        .price-modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
        }

        .price-modal-card {
            position: relative;
            background: #ffffff;
            max-width: 360px;
            width: calc(100% - 32px);
            margin: 80px auto;
            border-radius: 14px;
            padding: 20px 22px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        }

        .price-modal-card h3 {
            margin: 0 0 14px 0;
            font-size: 18px;
            font-weight: 600;
            text-transform: lowercase;
        }

        .price-modal-close {
            margin-top: 16px;
            width: 100%;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            background: #1a73e8;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        /* =========================================================
       DRAWING PANEL (DESKTOP SVG)
    ========================================================= */
        #drawing-panel {
            padding: 20px;
            margin-top: 40px;
            border-radius: 14px;

            display: none;
            /* shown on page 3+ via JS */
            min-height: 420px;
            height: auto;
            overflow-x: auto;
            overflow-y: hidden;
            background: #fff;
            border: 1px solid #e6e8ee;
            outline: none;

            width: 100%;
            box-sizing: border-box;
        }





        #drawing-panel #vanityDrawing {
            display: block;
            width: auto;
            height: var(--desktop-drawing-height);
            max-height: 70vh;
            background: #fff;
            position: relative;
            z-index: 1;
            margin-left: auto;
            margin-right: auto;

        }


        /* Drawing gestures: allow pinch/pan ONLY on drawing (not the form) */
        #vanityDrawing {
            touch-action: none;
            /* your pinch logic depends on this */
            transform-origin: center center;
        }

        /* =========================================================
   MOBILE DRAWING BAR â€” DEFAULT (DESKTOP: HIDDEN)
   ========================================================= */
        #mobile-drawing-bar {
            display: none !important;
            /* desktop hidden */
        }


        @media (max-width: 768px) {

            /* 3 buttons: prevent text cutoff on small phones */
            #mobile-drawing-bar {
                gap: 8px;
                padding: 8px;
            }

            .mobile-drawing-btn {
                color: #222;
                /* â¬… force text color */
                -webkit-appearance: none;
                /* â¬… stop iOS styling */
                appearance: none;
                font-size: clamp(11px, 3.2vw, 14px);
                padding: 0 8px;
                white-space: nowrap;
            }

            /* MINIMIZED: shrink the whole shell to bar-height (removes the white gap) */
            body.drawing-minimized #mobile-drawing-shell {
                height: 54px !important;
            }

            body.drawing-minimized #mobile-drawing-shell #drawing-panel {
                display: none !important;
                /* hide drawing completely */
            }

            /* keep the bar visible */
            body.drawing-minimized #mobile-drawing-shell #mobile-drawing-bar {
                display: flex !important;
            }

            /* form reserves only the bar height now */
            body.drawing-minimized #page-container {
                padding-bottom: 70px !important;
            }
        }

        /* =========================================================
   MOBILE ONLY: show drawing bar + make back/next full width
========================================================= */
        @media (max-width: 768px) {

            /* hide desktop price button on mobile (we use "view price") */
            #global-nav #price-button {
                display: none !important;
            }

            /* make global back/next full width + equal size */
            #global-nav {
                gap: 10px;
            }

            #global-nav .nav-left,
            #global-nav .nav-right {
                flex: 1;
            }

            #global-nav .nav-left button,
            #global-nav .nav-right button {
                width: 100%;
                justify-content: center;
                text-align: center;
            }
        }





        /* =========================================================
   MOBILE MINI-APP (kept hidden for now)
========================================================= */
        #mobile-app.hidden {
            display: none;
        }

        #mobile-app {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            z-index: 9999;
            display: flex;
            flex-direction: column;
        }

        #mobile-header {
            height: 52px;
            display: flex;
            align-items: center;
            padding: 0 14px;
            border-bottom: 1px solid #eaeaea;
        }

        #mobile-step-container {
            flex: 1;
            padding: 18px;
            overflow-y: auto;
        }

        #mobile-drawing {
            height: 230px;
            border-top: 1px solid #eaeaea;
            padding: 10px;
            background: rgba(0, 120, 255, 0.18) !important;
            /* debug */
            outline: 2px solid rgba(0, 120, 255, 0.9) !important;
            /* debug */
        }

        #mobile-drawing::before {
            content: "MOBILE DRAWING";
            display: block;
            font-size: 12px;
            padding: 4px 6px;
        }

        #mobileVanityDrawing {
            width: 100%;
            height: 100%;
        }

        #mobile-nav {
            display: flex;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid #ddd;
            background: #fff;
        }

        .mobile-nav-btn {
            flex: 1;
            padding: 14px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #f7f7f7;
        }

        .mobile-nav-btn.primary {
            background: #000;
            color: #fff;
            border-color: #000;
        }


        /* MOBILE: prevent page-level pinch zoom; allow gestures only inside drawing area */
        @media (max-width: 768px) {

            html,
            body {
                touch-action: pan-y;
            }

            /* drawing panel: allow panning + pinch inside the panel */
            #drawing-panel {
                touch-action: pan-x pan-y;
            }

            /* svg: allow custom pinch handler */
            #drawing-panel #vanityDrawing {
                touch-action: none;
            }
        }

        /* =========================================================
   MOBILE OVERRIDES
   (We are showing the "real app" on mobile for now)
========================================================= */
        @media (max-width: 768px) {

            /* remove sidebar + reclaim full width */
            #sidebar {
                display: none !important;
            }

            #page-container {
                margin-left: 0 !important;
                width: 100% !important;
                max-width: 100% !important;

                padding: 16px !important;
                padding-bottom: 260px !important;
                /* space for fixed drawing shell */
            }

            /* make fields go full width on small screens */
            .field-row {
                flex-direction: column !important;
                gap: 14px !important;
            }

            .field {
                max-width: none !important;
                min-width: 0 !important;
                width: 100% !important;
            }

            .field.sm,
            .field.md,
            .field.lg {
                max-width: none !important;
            }

            /* =========================
       MOBILE DRAWING SHELL
    ========================= */

            /* shell is what gets pinned */
            #mobile-drawing-shell {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;

                width: 100%;
                max-width: 100%;
                box-sizing: border-box;

                height: auto;
                display: flex;
                flex-direction: column;

                z-index: 2600;
                background: #fff;
                border-top: 1px solid #eaeaea;
            }


            /* bar sits OUTSIDE the panel, attached to its top */
            #mobile-drawing-shell #mobile-drawing-bar {
                display: flex !important;
                gap: 8px;
                padding: 8px 10px;
                background: #fff;
                border-bottom: 1px solid #eaeaea;
            }


            /* buttons */
            #mobile-drawing-shell #mobile-drawing-bar .mobile-drawing-btn {
                flex: 1;
                height: 32px;
                border-radius: 10px;
                border: 1px solid #d1d5db;
                background: #fff;
                font-size: 14px;
                cursor: pointer;
                text-transform: lowercase;
                color: #222;
                /* â¬… force text color */
                -webkit-appearance: none;
                /* â¬… stop iOS styling */
                appearance: none;
                /* prevent text cutoff */
                font-size: clamp(11px, 3.2vw, 14px);
                padding: 0 8px;
                white-space: nowrap;
            }


            #mobile-drawing-shell #drawing-panel {
                position: relative;
                width: 100%;
                box-sizing: border-box;

                height: 33vh;
                min-height: 220px;

                margin: 0;
                padding: 10px;

                border: none;
                /* â¬… override desktop border */
                border-radius: 0;
                /* â¬… override desktop rounding */
                background: #fff;

                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
            }


            /* svg uses full panel height */
            #mobile-drawing-shell #drawing-panel #vanityDrawing {
                height: 100%;
                width: auto;
                display: block;
                margin-left: auto;
                margin-right: auto;

                touch-action: none !important;
                pointer-events: auto;
            }

            /* keep the mini-app hidden for now */
            #mobile-app {
                display: none;
            }
        }

        /* close pill hidden by default (only shown in mobile expanded mode) */
        #mobile-expand-close {
            display: none !important;
        }




        /* =========================================================
   EXPANDED DRAWING MODE (mobile only)
========================================================= */
        @media (max-width: 768px) {
            body.drawing-expanded {
                overflow: hidden;
            }

            /* full screen takeover */
            body.drawing-expanded #drawing-panel {
                position: fixed !important;
                inset: 0 !important;
                z-index: 5000 !important;
                background: #fff !important;
                padding: 0 !important;
                margin: 0 !important;

                display: flex !important;
                align-items: center !important;
                justify-content: center !important;

                overflow: hidden !important;
                width: 100dvw !important;
                height: 100dvh !important;

            }

            /* hide the normal mobile bar while expanded */
            body.drawing-expanded #mobile-drawing-bar {
                display: none !important;
            }

            body.drawing-expanded #global-nav {
                display: none !important;
            }


            /* the SVG: rotate + center + start fully in view */
            body.drawing-expanded #drawing-panel #vanityDrawing {
                width: 100dvw !important;
                height: 100dvh !important;

                max-width: none !important;
                max-height: none !important;

                display: block !important;

                touch-action: none !important;
                pointer-events: auto !important;
            }


            /* close pill (only visible while expanded) */
            #mobile-expand-close {
                display: none !important;
            }

            body.drawing-expanded #mobile-expand-close {
                display: flex !important;
                position: fixed !important;
                top: calc(12px + env(safe-area-inset-top)) !important;
                right: calc(12px + env(safe-area-inset-right)) !important;
                z-index: 9000 !important;

                height: 40px !important;
                padding: 0 18px !important;

                border-radius: 999px !important;
                border: 1px solid #d1d5db !important;
                background: #fff !important;

                color: #1a73e8 !important;
                font-size: 14px !important;
                font-weight: 600 !important;
                text-transform: lowercase !important;

                align-items: center !important;
                justify-content: center !important;
            }
        }

        /* =========================
   MOBILE GLOBAL NAV â€” MATCH DRAWING BAR STYLE (FIXED FLUSH TOP)
========================= */
        @media (max-width: 768px) {

            /* outer white bar */
            #global-nav {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;

                z-index: 4000 !important;
                background: #fff !important;
                border-bottom: 1px solid #eaeaea !important;

                /* âœ… iOS safe area so nothing shows above */
                padding-top: calc(8px + env(safe-area-inset-top)) !important;
                padding-right: 10px !important;
                padding-bottom: 8px !important;
                padding-left: 10px !important;

                /* âœ… let height be driven by padding + button height */
                height: auto !important;

                display: flex !important;
                gap: 8px !important;
                align-items: center !important;
                overflow: hidden !important;
            }

            #global-nav .nav-left,
            #global-nav .nav-right {
                flex: 1 1 0 !important;
                display: flex !important;
                gap: 8px !important;
            }

            /* buttons styled like mobile drawing buttons */
            #global-nav .nav-left button,
            #global-nav .nav-right button {
                flex: 1 !important;
                height: 40px !important;

                border-radius: 10px !important;
                border: 1px solid #d1d5db !important;

                font-size: 15px !important;
                font-weight: 500 !important;
                line-height: 1 !important;

                display: flex !important;
                align-items: center !important;
                justify-content: center !important;

                white-space: nowrap !important;
                padding: 0 10px !important;
            }

            /* preserve forward / back color intent */
            #global-nav .nav-left button {
                background: #f3f4f6 !important;
                color: #222 !important;
            }

            #global-nav .nav-right button {
                background: #1a73e8 !important;
                color: #fff !important;
            }

            #global-nav {
                margin-top: 0 !important;
                top: 0 !important;
                transform: none !important;
                /* if something else is transforming it */
            }


            /* push page content below the bar (includes safe-area + padding + button height) */
            #page-container {
                padding-top: calc(8px + env(safe-area-inset-top) + 40px + 8px + 16px) !important;
            }
        }



        /* =========================================================
   THEME A â€” clean / seamless
   (visual only â€” no layout changes)
========================================================= */

        /* page background */
        body {
            background: #ffffff;
        }

        /* cards become subtle panels */
        .field-card {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            margin-bottom: 24px;
            /* keep spacing between sections */
            border-radius: 0;
        }

        .field-card h2 {
            margin-bottom: 10px;
        }


        /* sidebar softened */
        #sidebar {
            background: #ffffff;
            border-right: 1px solid #e6e8ee;
        }

        #sidebar .nav-item:hover {
            background: #f3f4f6;
        }

        #sidebar .nav-item.active {
            background: #f5f6f8;
        }

        /* =========================================================
   INLINE +/- STEPPER (matches your other fields)
   - does NOT change the input's outer size
========================================================= */
        .stepper-input {
            position: relative;
            width: 100%;
        }

        .stepper-input input {
            width: 100%;
            padding-right: 70px !important;
            /* room for the two buttons */
        }

        .stepper-input .stepper-btns {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 6px;
        }

        .stepper-input .stepper-btn {
            width: 30px;
            height: 30px;
            /* tap-friendly without changing input height */
            border-radius: 8px;
            border: 1px solid #d1d5db;
            background: #fff;
            color: #222;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            -webkit-appearance: none;
            appearance: none;
        }

        .stepper-input .stepper-btn:active {
            transform: scale(0.98);
        }

        /* hide native number spinners (the â€œold vertical steppersâ€) */
        .stepper-input input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .stepper-input input[type="number"]::-webkit-outer-spin-button,
        .stepper-input input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>

</head>

<body>

    <div id="desktop-layout">

        <aside id="sidebar">
            <div class="nav-item active" data-page="page1">your info</div>
            <div class="nav-item" data-page="page2">vanity details</div>
            <div class="nav-item" data-page="page3">layout & style</div>
            <div class="nav-item" data-page="page4">frame sizing</div>
            <div class="nav-item" data-page="page5">materials & finish</div>
            <div class="nav-item" data-page="page6">summary</div>
        </aside>

        <main id="page-container">

            <!-- PAGE 1 -->
            <section id="page1" class="page active">
                <div class="field-card">
                    <h2>welcome</h2>
                    <p class="subtitle" style="margin-bottom:20px;">
                        start by telling me who this vanity is for and where it will be installed.
                    </p>

                    <div class="field-row">
                        <div class="field md"><label>first name</label><input id="firstName"></div>
                        <div class="field md"><label>last name</label><input id="lastName"></div>
                        <div class="field lg"><label>email</label><input id="email"></div>
                    </div>

                    <div class="field-row">
                        <div class="field md"><label>phone</label><input id="phone"></div>
                        <div class="field lg"><label>street address</label><input id="deliveryStreet"></div>
                        <div class="field md"><label>city</label><input id="deliveryCity"></div>
                        <div class="field sm"><label>state</label><input id="deliveryState"></div>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="back" disabled>back</button>
                    <button class="next" data-next="page2">next: vanity details</button>
                </div>
            </section>

            <!-- PAGE 2 -->
            <section id="page2" class="page">
                <div class="field-card">
                    <h2>vanity details</h2>

                    <!-- row 1: main size + sides + sinks -->
                    <div class="field-row">
                        <div class="field dimension-field">
                            <label for="width">width (in)</label>
                            <input id="width" type="number" min="18" step="0.25" placeholder='18" min.'>
                            <div id="widthError" class="field-error"></div>
                        </div>

                        <div class="field dimension-field">
                            <label for="height">
                                height <strong>without</strong> countertop (in)
                            </label>
                            <input id="height" type="number" min="6" step="0.25" placeholder='32â€“34.5" is standard'>
                        </div>

                        <div class="field dimension-field">
                            <label for="depth">depth (in)</label>
                            <input id="depth" type="number" min="6" step="0.25" placeholder='21â€“22" is standard'>
                        </div>

                        <div class="field sm">
                            <label class="label-with-help">
                                sink count
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="sink count"
                                    data-help-body="single sink or double sink vanity?">?</button>
                            </label>

                            <select id="sinkCount">
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                            </select>
                        </div>


                        <div class="field" id="sinkPositionField" style="display:none;">
                            <label for="sinkPosition">sink position</label>
                            <select id="sinkPosition" name="sinkPosition">
                                <option value="center">centered</option>
                                <option value="left">left</option>
                                <option value="right">right</option>
                            </select>
                        </div>

                    </div>

                    <!-- row 2: floating / shelf / makeup -->
                    <div class="field-row">
                        <div class="field">
                            <label for="doorDrawerPreset" class="label-with-help">
                                door and drawer style
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="door and drawer styles" data-help-html='
<div class="help-gallery">

  <div class="help-style">
    <div class="help-style-title">slab style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/styles.jpeg" alt="slab style" />
    <ul class="help-style-notes">
      <li>easy to clean, does not collect dust</li>
      <li>for stained cabinets: 3/4&quot; cabinet grade plywood for stability</li>
      <li>for painted cabinets: 3/4&quot; or 1&quot; medex</li>
      <li>waterproof finish for durability</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/shaker.jpeg" alt="shaker style" />
    <ul class="help-style-notes">
      <li>timeless and simple</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>a common profile found on all levels of cabinetry</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">double shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/double%20shaker.jpeg" alt="double shaker style" />
    <ul class="help-style-notes">
      <li>my standard profile offered at no up-charge</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>double shaker is only found on fully custom cabinetry</li>
    </ul>
  </div>

 <a
  class="help-modal-action help-modal-action-primary"
  href="https://www.turnerrossadesigns.com/photo-gallery-1"
  target="_blank"
  rel="noopener noreferrer">
  view more examples (new page)
</a>


</div>'>?</button>
                            </label>

                            <select id="doorDrawerPreset">
                                <option value="slab">slab</option>
                                <option value="shaker">shaker</option>
                                <option value="double-shaker">double shaker</option>
                                <option value="slab-shaker">slab/shaker combo</option>
                                <option value="slab-double-shaker">slab/double shaker combo</option>
                            </select>
                        </div>




                        <div class="field md">
                            <label class="label-with-help">
                                which sides are visible?
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="visible sides" data-help-body="tell me which sides will be seen.
sides you cant see after install are not finished.">?</button>
                            </label>

                            <select id="visibleSides">
                                <option value="none" selected>no sides visible</option>
                                <option value="left">left side</option>
                                <option value="right">right side</option>
                                <option value="both">both sides</option>
                            </select>
                        </div>



                        <div class="field md">
                            <label class="label-with-help">
                                is this a floating vanity?
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="floating vanity" data-help-body="this option makes the vanity appear to &quot;float&quot; with no legs.
NOTE: must be against at least one side wall."
                                    data-help-img="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/assets/help/floating%20pic.jpg">?</button>
                            </label>

                            <select id="floating">
                                <option value="false">no</option>
                                <option value="true">yes</option>
                            </select>
                        </div>

                        <div class="field" id="shelfBelowField">
                            <label for="shelfBelow" class="label-with-help">
                                add open shelf below?
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="open shelf below" data-help-body="this option adds an open shelf below the vanity.
it reduces cabinet space but creates visible storage."
                                    data-help-img="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/assets/help/shelf-below.jpeg">?</button>
                            </label>

                            <select id="shelfBelow">
                                <option value="no" selected>no</option>
                                <option value="yes">yes</option>
                            </select>
                        </div>


                        <!-- MAKEUP DESK -->
                        <div class="field">
                            <label class="label-with-help">
                                is there a makeup desk?
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="makeup desk" data-help-body="this option creates a &quot;desk&quot; by adding a shallow drawer with space below
recommended height is 30&quot; off the floor.">?</button>
                            </label>

                            <select id="makeupDeskEnabled">
                                <option value="no">no</option>
                                <option value="yes">yes</option>
                            </select>
                        </div>


                        <div class="field" id="makeupDeskPositionField" style="display:none;">
                            <label>desk position</label>
                            <select id="makeupDeskPosition">
                                <option value="center">center</option>
                                <option value="left">left</option>
                                <option value="right">right</option>
                            </select>
                        </div>

                        <div class="field" id="makeupDeskWidthField" style="display:none;">
                            <label>desk width (in)</label>
                            <input id="makeupDeskWidth" type="number" step="0.25" min="24" max="36" />
                        </div>

                        <div class="field" id="makeupDeskHeightField" style="display:none;">
                            <label>desk drawer height (in)</label>
                            <input id="makeupDeskHeight" type="number" step="0.25" min="3" max="5" />
                        </div>

                    </div>
                </div>

                <!-- nav buttons BELOW the card -->
                <div class="nav-buttons">
                    <button class="back" data-back="page1">back</button>
                    <button class="next" data-next="page3">next: layout & style</button>
                </div>
            </section>


            <!-- PAGE 3 -->
            <section id="page3" class="page">
                <div class="field-card">
                    <h2>layout & style</h2>

                    <!-- row 1: layout + styles + drawer widths -->
                    <div class="field-row">
                        <div class="field md">
                            <label>layout options</label>
                            <select id="layoutPreset">
                                <option value="default">default layout</option>
                            </select>
                        </div>

                        <div class="field md">
                            <label class="label-with-help">
                                door style
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="door and drawer styles" data-help-html='
<div class="help-gallery">

  <div class="help-style">
    <div class="help-style-title">slab style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/styles.jpeg" alt="slab style" />
    <ul class="help-style-notes">
      <li>easy to clean and does not collect dust</li>
      <li>for stained cabinets: 3/4&quot; cabinet grade plywood for stability</li>
      <li>for painted cabinets: 3/4&quot; or 1&quot; medex</li>
      <li>waterproof finish for durability</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/shaker.jpeg" alt="shaker style" />
    <ul class="help-style-notes">
      <li>timeless and simple</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>a common profile found on all levels of cabinetry</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">double shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/double%20shaker.jpeg" alt="double shaker style" />
    <ul class="help-style-notes">
      <li>my standard profile offered at no up-charge</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>double shaker is only found on fully custom cabinetry</li>
    </ul>
  </div>

  <a
    class="help-modal-action help-modal-action-primary"
    href="https://www.turnerrossadesigns.com/photo-gallery-1"
    target="_blank"
    rel="noopener noreferrer">
    view more examples
  </a>

</div>'>?</button>
                            </label>

                            <select id="doorStyle">
                                <option value="shaker">shaker</option>
                                <option value="slab">slab</option>
                                <option value="double-shaker">double shaker</option>
                            </select>
                        </div>

                        <div class="field md">
                            <label class="label-with-help">
                                drawer style
                                <button type="button" class="help-icon" aria-label="what is this?"
                                    data-help-title="door and drawer styles" data-help-html='
<div class="help-gallery">

  <div class="help-style">
    <div class="help-style-title">slab style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/styles.jpeg" alt="slab style" />
    <ul class="help-style-notes">
      <li>easy to clean and does not collect dust</li>
      <li>for stained cabinets: 3/4&quot; cabinet grade plywood for stability</li>
      <li>for painted cabinets: 3/4&quot; or 1&quot; medex</li>
      <li>waterproof finish for durability</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/shaker.jpeg" alt="shaker style" />
    <ul class="help-style-notes">
      <li>timeless and simple</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>a common profile found on all levels of cabinetry</li>
    </ul>
  </div>

  <div class="help-style">
    <div class="help-style-title">double shaker style</div>
    <img class="help-style-img" src="https://raw.githubusercontent.com/johnturneriv/VB-2.4/main/asset/help/double%20shaker.jpeg" alt="double shaker style" />
    <ul class="help-style-notes">
      <li>my standard profile offered at no up-charge</li>
      <li>1&quot; thick, 5 piece construction</li>
      <li>double shaker is only found on fully custom cabinetry</li>
    </ul>
  </div>

  <a
    class="help-modal-action help-modal-action-primary"
    href="https://www.turnerrossadesigns.com/photo-gallery-1"
    target="_blank"
    rel="noopener noreferrer">
    view more examples
  </a>

</div>'>?</button>
                            </label>

                            <select id="drawerStyle">
                                <option value="slab">slab</option>
                                <option value="shaker">shaker</option>
                                <option value="double-shaker">double shaker</option>
                                <option value="slab-shaker">slab top + shaker</option>
                                <option value="slab-double-shaker">slab top + double shaker</option>
                            </select>
                        </div>



                        <!-- drawer width controls (shown/hidden by JS) -->
                        <div id="drawerWidthSingleField" class="field md">
                            <label for="drawerWidthSingle">drawer width (in)</label>
                            <div class="stepper-input" data-step="0.25">
                                <input id="drawerWidthSingle" type="number" min="1" step="0.25" placeholder="auto" />
                                <div class="stepper-btns">
                                    <button type="button" class="stepper-btn" data-dir="1"
                                        aria-label="increase">+</button>
                                    <button type="button" class="stepper-btn" data-dir="-1"
                                        aria-label="decrease">âˆ’</button>
                                </div>
                            </div>
                        </div>

                        <div id="drawerWidthOuterField" class="field md">
                            <label for="drawerWidthOuter">outer drawer width (in)</label>
                            <div class="stepper-input" data-step="0.25">
                                <input id="drawerWidthOuter" type="number" min="1" step="0.25" placeholder="auto" />
                                <div class="stepper-btns">
                                    <button type="button" class="stepper-btn" data-dir="1"
                                        aria-label="increase">+</button>
                                    <button type="button" class="stepper-btn" data-dir="-1"
                                        aria-label="decrease">âˆ’</button>
                                </div>
                            </div>
                        </div>

                        <div id="drawerWidthCenterField" class="field md">
                            <label for="drawerWidthCenter">center drawer width (in)</label>
                            <div class="stepper-input" data-step="0.25">
                                <input id="drawerWidthCenter" type="number" min="1" step="0.25" placeholder="auto" />
                                <div class="stepper-btns">
                                    <button type="button" class="stepper-btn" data-dir="1"
                                        aria-label="increase">+</button>
                                    <button type="button" class="stepper-btn" data-dir="-1"
                                        aria-label="decrease">âˆ’</button>
                                </div>
                            </div>
                        </div>

                        <div id="drawerWidthTwoSectionField" class="field md">
                            <label for="drawerWidthTwoSection">drawer width (in)</label>
                            <div class="stepper-input" data-step="0.25">
                                <input id="drawerWidthTwoSection" type="number" min="1" step="0.25"
                                    placeholder="auto" />
                                <div class="stepper-btns">
                                    <button type="button" class="stepper-btn" data-dir="1"
                                        aria-label="increase">+</button>
                                    <button type="button" class="stepper-btn" data-dir="-1"
                                        aria-label="decrease">âˆ’</button>
                                </div>
                            </div>
                        </div>

                    </div>

                    <!-- row 2: bottom detail + toe/open-below height -->
                    <div class="field-row">
                        <div class="field">
                            <label for="topDrawerHeightPreset">top drawer height</label>
                            <select id="topDrawerHeightPreset">
                                <option value="equal">equal to others</option>
                                <option value="5">5"</option>
                                <option value="5.5">5.5"</option>
                                <option value="6">6"</option>
                                <option value="6.5">6.5"</option>
                                <option value="7">7"</option>
                                <option value="7.5">7.5"</option>
                                <option value="8">8"</option>
                            </select>
                        </div>

                        <div class="field sm" id="bottomDetailField">
                            <label>bottom detail</label>
                            <select id="bottomDetail">
                                <option value="toe-kick">toe kick</option>
                                <option value="open-below">open below</option>
                            </select>
                        </div>

                        <div class="field sm" id="bottomHeightField">
                            <label id="toeKickLabel">toe kick height (in)</label>
                            <input type="number" id="toeKickHeight">
                        </div>

                        <!-- rails between drawers -->
                        <div class="field sm" id="drawerRailsModeField">
                            <label for="drawerRailsMode">rails between drawers</label>
                            <select id="drawerRailsMode">
                                <option value="none" selected>none</option>
                                <option value="top">top only</option>
                                <option value="all">between all drawers</option>
                            </select>
                        </div>




                    </div>
                </div>

                <!-- nav buttons BELOW the card -->
                <div class="nav-buttons">
                    <button class="back" data-back="page2">back</button>
                    <button class="next" data-next="page4">next: frame sizing</button>
                </div>
            </section>


            <!-- PAGE 4 -->
            <section id="page4" class="page">
                <div class="field-card">
                    <h2>frame sizing</h2>

                    <div class="field-row">

                        <!-- SPACE ABOVE SHELF -->
                        <div id="shelfSpaceField" class="field sm">
                            <label for="shelfSpaceIn">space above shelf (in)</label>
                            <input id="shelfSpaceIn" type="number" step="0.25" min="6" max="12" value="8">
                        </div>

                        <!-- SHELF THICKNESS (only appears when shelfBelow=yes) -->
                        <div class="field sm" id="shelfThicknessField" style="display: none;">
                            <label for="shelfThickness">shelf thickness (in)</label>
                            <select id="shelfThickness">
                                <option value="1.5">1.5"</option>
                                <option value="2" selected>2" (standard)</option>
                                <option value="2.5">2.5"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>


                        <!-- ======================= -->
                        <!--     COMBINED FIELDS     -->
                        <!-- ======================= -->

                        <!-- STILE OPTIONS -->
                        <div class="field sm" id="frameStileWidthField">
                            <label>stile options</label>
                            <select id="frameStileWidth">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5" selected>1 1/2" (standard)</option>
                                <option value="2">2"</option>
                            </select>

                            <!-- Keep your blue note -->
                            <div id="drawerRailsNote" class="field-note">
                                rails between drawers need stiles!
                            </div>
                        </div>

                        <!-- TOP RAIL OPTIONS -->
                        <div class="field sm">
                            <label>top rail options</label>
                            <select id="frameTopRailHeight">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5" selected>1 1/2" (standard)</option>
                                <option value="2">2"</option>
                            </select>
                        </div>

                        <!-- BOTTOM RAIL OPTIONS -->
                        <div class="field sm">
                            <label>bottom rail options</label>
                            <select id="frameBottomRailHeight">
                                <option value="remove">remove</option>
                                <option value="0.75">3/4"</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2" selected>2" (standard)</option>
                                <option value="2.5">2 1/2"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>


                        <!-- DIVIDING RAIL HEIGHT -->
                        <div class="field sm" id="drawerRailHeightField">
                            <label for="drawerRailHeightIn">dividing rail height</label>
                            <select id="drawerRailHeightIn">
                                <option value="0.75">3/4"</option>
                                <option value="1" selected>1" (standard)</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2">2"</option>
                            </select>
                        </div>

                        <!-- LEG WIDTH -->
                        <div class="field sm">
                            <label>leg width (in)</label>
                            <select id="frameLegWidth">
                                <option value="0.75">3/4"</option>
                                <option value="1">1"</option>
                                <option value="1.5">1 1/2"</option>
                                <option value="2" selected>2" (standard)</option>
                                <option value="2.5">2 1/2"</option>
                                <option value="3">3"</option>
                            </select>
                        </div>

                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page3">back</button>
                    <button class="next" data-next="page5">next: materials & finish</button>
                </div>
            </section>

            <!-- ======================= -->
            <!--        PAGE 5           -->
            <!-- ======================= -->
            <section id="page5" class="page">
                <div class="field-card">
                    <h2>materials & finish</h2>

                    <!-- THIS IS THE ONLY ROW -->
                    <div id="finishRow" class="field-row">

                        <!-- ALWAYS VISIBLE -->
                        <div class="field md">
                            <label>finish type</label>
                            <select id="finishType">
                                <option value="">select finish type</option>
                                <option value="wood">wood grain</option>
                                <option value="paint">painted</option>
                            </select>
                        </div>

                        <!-- WOOD FIELDS -->
                        <div class="field md wood-field" style="display:none;">
                            <label>wood species</label>
                            <select id="woodSpecies">
                                <option value="">select species</option>
                                <option value="white-oak">white oak (most popular)</option>
                                <option value="walnut">walnut</option>
                                <option value="mahogany">mahogany</option>
                                <option value="cherry">cherry</option>
                                <option value="maple">maple</option>
                                <option value="red-oak">red oak</option>
                            </select>
                        </div>

                        <div class="field md wood-field" style="display:none;">
                            <label>stain options</label>
                            <select id="stainOption">
                                <option value="">select stain</option>
                                <option value="clear">hardwood with clear finish</option>
                                <option value="natural-seal">bona "natural seal"</option>
                                <option value="country-white">country white</option>
                                <option value="classic-gray">classic gray</option>
                                <option value="custom-stain">custom stain (formula required)</option>
                            </select>
                        </div>

                        <!-- PAINT FIELDS -->
                        <div class="field md paint-field" style="display:none;">
                            <label>finish options</label>
                            <select id="paintFinish">
                                <option value="">select paint finish</option>
                                <option value="custom">painted custom color</option>
                                <option value="primed">primed wood, ready for paint</option>
                                <option value="raw">raw wood, ready for paint</option>
                            </select>
                        </div>

                        <div class="field lg paint-field" id="customColorField" style="display:none;">
                            <label>custom color name/brand/code</label>
                            <input id="customColorInput" type="text" placeholder="e.g. BM White Dove OC-17">
                            <div class="field-note">omit if you're not sure yet</div>
                        </div>

                        <div class="field md paint-field" id="primerColorField" style="display:none;">
                            <label>primer color</label>
                            <select id="primerColor">
                                <option value="">choose primer</option>
                                <option value="white">white primer (lighter colors)</option>
                                <option value="gray">gray primer (darker colors)</option>
                            </select>
                        </div>

                    </div><!-- END ONE ROW -->

                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page4">back</button>
                    <button class="next" data-next="page6">next: summary</button>
                </div>
            </section>



            <!-- PAGE 6 -->
            <section id="page6" class="page">
                <div class="field-card">
                    <h2>summary</h2>
                    <p>summary details will go here</p>
                </div>

                <div class="nav-buttons">
                    <button class="back" data-back="page5">back</button>
                    <button class="next" disabled>done</button>
                </div>
            </section>

            <!-- drawing panel -->
            <!-- MOBILE DRAWING SHELL (mobile only) -->
            <div id="mobile-drawing-shell">
                <div id="mobile-drawing-bar" class="mobile-drawing-bar">
                    <button id="mobile-price-button" class="mobile-drawing-btn">view price</button>
                    <button id="mobile-minimize-button" class="mobile-drawing-btn">minimize</button>
                    <button id="mobile-expand-button" class="mobile-drawing-btn">full screen</button>
                </div>

                <div id="drawing-panel">
                    <svg id="vanityDrawing" preserveAspectRatio="xMinYMin meet"></svg>
                    <button id="mobile-expand-close" class="mobile-expand-close">close</button>
                </div>
            </div>


            <!-- GLOBAL NAV (desktop: includes price again) -->
            <div id="global-nav" class="nav-buttons nav-split">
                <div class="nav-left">
                    <button id="global-back" class="back">back</button>
                </div>

                <div class="nav-right">
                    <button id="price-button" class="price-button">
                        current price:
                        <span id="price-value" class="price-value">$0</span>
                    </button>

                    <button id="global-next" class="next">next</button>
                </div>
            </div>




        </main>

    </div>

    <!-- MOBILE APP -->
    <div id="mobile-app" class="hidden">
        <div id="mobile-header">

            <span class="mobile-title">vanity builder</span>
        </div>



        <div id="mobile-nav">
            <button id="mobile-back" class="mobile-nav-btn">back</button>
            <button id="mobile-next" class="mobile-nav-btn primary">next</button>
        </div>


        <div id="mobile-drawing">
            <svg id="mobileVanityDrawing"></svg>
        </div>
    </div>
    <script>
        var currentPageIndex = 0;

        let drawingEngineInitialized = false;
        let railsModeBeforeStilesOff = "none";

        let initialDrawDone = false;


        // =====================================================
        // SECTION SELECTION STATE (authoritative)
        // =====================================================

        // null = no section selected
        // number = index into model.sections
        let selectedSectionIndex = null;

        // --------------------------------------------------
        // PERSISTENT SECTION OVERRIDES (survive redraws)
        // --------------------------------------------------
        let sectionOverrides = {};

        let DRAWING_ZOOM = 1; // 1 = default


        const FRAME_DEFAULTS = {
            legWidthIn: 2.0,
            stileWidthIn: 1.5,
            topRailHeightIn: 1.5,
            bottomRailHeightIn: 2.0
        };
        const DEFAULT_DRAWER_RAIL_HEIGHT_IN = 1.0;


        const STROKE = .6;  // master line thickness

        const STRUCTURE_COLOR = "#000";     // Cabinet frame, legs, rails, etc.
        const DIM_COLOR = "#777";           // VB1-style gray for dim lines + ticks
        const DIM_STROKE = 0.6;         // thinner lines for dims / floor
        const DASH_PATTERN = "3 3";     // slightly tighter dash than VB1
        const SINK_COLOR = "#1a73e8";   // blue for sinks + sink dims
        const SINK_STROKE = 0.5;        // a little thinner than structure lines
        const SINK_DASH = "3 3";        // dashed outline for sinks
        const FLOAT_TOP_HEIGHT_IN = 34;


        // === Shelf-below constants ===
        const SHELF_THICKNESS_IN = 2;          // fixed 2" thick face
        const DEFAULT_SHELF_SPACE_IN = 8;      // default space above shelf to bottom rail
        const MIN_SHELF_SPACE_IN = 6;
        const MAX_SHELF_SPACE_IN = 12;


        // Track whether the user has manually changed drawer widths.
        // Programmatic seeding won't flip these.
        const drawerOverrideFlags = {
            single: false,
            outer: false,
            center: false,
            twoSection: false
        };

        // Track which drawer group the user last edited ("single" | "outer" | "center")
        let lastDrawerEdited = null;


        // ========================================================
        // SINK DEFAULTS + SECTION TWEAKS BASED ON LENGTH / LAYOUT
        // ========================================================

        /**
         * Decide a good default sink size (bowl width in inches)
         * based on vanity length and sink count.
         *
         *  - Single sink:
         *      18"â€“21"  â†’ 15" sink
         *      >21"â€“47" â†’ 18" sink
         *      â‰¥48"     â†’ 20" sink
         *
         *  - Double sink:
         *      50"â€“54"  â†’ 15" sinks
         *      >54"â€“68" â†’ 18" sinks
         *      â‰¥69"     â†’ 20" sinks
         */
        function chooseDefaultSinkSize(lengthIn, sinkCount) {
            if (sinkCount === 1) {
                if (lengthIn <= 21) return 15;   // smallest single: 18" vanity
                if (lengthIn <= 47) return 18;   // 22.5"â€“42" examples
                return 20;                       // 48"+ singles
            }

            if (sinkCount === 2) {
                if (lengthIn <= 54) return 15;   // 50" double
                if (lengthIn <= 68) return 18;   // 60"â€“66" doubles
                return 20;                       // 72"+ doubles
            }

            // Fallback (just in case)
            return 20;
        }



        /* ======================================================================= */
        /* === SECTION: DESKTOP SIDEBAR NAVIGATION LOGIC                        === */
        /* ======================================================================= */

        const sidebarItems = document.querySelectorAll("#sidebar .nav-item");
        const pages = document.querySelectorAll(".page");

        function setDrawingPanelVisibility(pageId) {
            const drawingPanel = document.getElementById("drawing-panel");
            const mobileBar = document.getElementById("mobile-drawing-bar");
            if (!drawingPanel) return;

            // Rule for ALL devices:
            // page1 + page2 => hide drawing
            const hide = (pageId === "page1" || pageId === "page2");

            drawingPanel.style.display = hide ? "none" : "block";

            // Mobile bar should follow drawing visibility (mobile-only via CSS)
            if (mobileBar) {
                mobileBar.style.display = hide ? "none" : "";
            }
        }




        sidebarItems.forEach(item => {
            item.addEventListener("click", () => {
                const pageId = item.getAttribute("data-page");
                goToPage(pageId);
            });
        });



        /* ======================================================================= */
        /* === SECTION: NEXT/BACK BUTTONS (GLOBAL BELOW DRAWING)                 === */
        /* ======================================================================= */

        /** central helper: switch to a given page id */
        function goToPage(pageId) {
            if (!pageId) return;

            // normalize pages into a real array (ONCE)
            const pagesArr = Array.from(pages);

            // sidebar highlight
            sidebarItems.forEach(i => {
                i.classList.toggle(
                    "active",
                    i.getAttribute("data-page") === pageId
                );
            });

            // activate correct page (DESKTOP SOURCE OF TRUTH)
            pagesArr.forEach(p => p.classList.remove("active"));
            const pageEl = document.getElementById(pageId);
            if (pageEl) pageEl.classList.add("active");

            // update index (AUTHORITATIVE)
            const idx = pagesArr.findIndex(p => p.id === pageId);
            currentPageIndex = idx >= 0 ? idx : 0;

            // âœ… IMMEDIATE scroll reset (mobile browsers sometimes ignore a single delayed call)
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;

            const pageContainerNow = document.getElementById("page-container");
            if (pageContainerNow) pageContainerNow.scrollTop = 0;

            const mobileStepNow = document.getElementById("mobile-step-container");
            if (mobileStepNow) mobileStepNow.scrollTop = 0;

            syncUIState(pageId);
            updateDrawing();
            syncGlobalNavState();

            // âœ… ALSO reset next frame (covers iOS/Safari + layout shifts)
            requestAnimationFrame(() => {
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;

                const pageContainer = document.getElementById("page-container");
                if (pageContainer) pageContainer.scrollTop = 0;

                // if you ever use the mini mobile app container, reset it too
                const mobileStep = document.getElementById("mobile-step-container");
                if (mobileStep) mobileStep.scrollTop = 0;
            });
        }


        function setupMobileNavHandlers() {
            // ----------------------------
            // Optional: mobile back/next
            // ----------------------------
            const backBtn = document.getElementById("mobile-back");
            const nextBtn = document.getElementById("mobile-next");

            if (backBtn) {
                backBtn.addEventListener("click", () => {
                    const activePage = document.querySelector(".page.active");
                    if (!activePage) return;

                    const localBack = activePage.querySelector(".nav-buttons .back");
                    if (!localBack || localBack.disabled) return;

                    const backPage = localBack.getAttribute("data-back");
                    if (!backPage) return;

                    goToPage(backPage);
                });
            }

            if (nextBtn) {
                nextBtn.addEventListener("click", () => {
                    const activePage = document.querySelector(".page.active");
                    if (!activePage) return;

                    const localNext = activePage.querySelector(".nav-buttons .next");
                    if (!localNext || localNext.disabled) return;

                    const nextPage = localNext.getAttribute("data-next");
                    if (!nextPage) return;

                    goToPage(nextPage);
                });
            }

            // ----------------------------
            // Mobile drawing bar buttons
            // ----------------------------
            const mobilePriceBtn = document.getElementById("mobile-price-button");
            if (mobilePriceBtn) {
                mobilePriceBtn.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const model = computeModel();
                    openPriceModal(model);
                });
            }

            const expandBtn = document.getElementById("mobile-expand-button");
            const closeBtn = document.getElementById("mobile-expand-close");


            if (expandBtn) {
                // keep label stable (bar hides in expanded mode anyway)
                expandBtn.textContent = "expand";

                expandBtn.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setExpanded(true);
                });
            }

            if (closeBtn) {
                closeBtn.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setExpanded(false);
                });
            }
        }

        // =======================================================
        // INITIAL PRICE VISIBILITY (run once on page load)
        // =======================================================
        const activePage = document.querySelector(".page.active")?.id;
        if (activePage) {
            updatePriceVisibility(activePage);
        }

        function syncGlobalNavState() {
            const globalBack = document.getElementById("global-back");
            const globalNext = document.getElementById("global-next");
            if (!globalBack || !globalNext) return;

            const activePage = document.querySelector(".page.active");
            if (!activePage) {
                globalBack.disabled = true;
                globalNext.disabled = true;
                globalBack.textContent = "back";
                globalNext.textContent = "next";
                return;
            }

            // Helper: use the target page's <h2> as the label (fallback to "previous"/"next")
            function getPageTitle(pageId) {
                if (!pageId) return "";
                const el = document.getElementById(pageId);
                const h2 = el ? el.querySelector("h2") : null;
                return (h2?.textContent || "").trim();
            }

            const localNav = activePage.querySelector(".nav-buttons");
            const localBack = localNav ? localNav.querySelector(".back") : null;
            const localNext = localNav ? localNav.querySelector(".next") : null;

            // -----------------
            // BACK button label
            // -----------------
            if (localBack) {
                globalBack.disabled = !!localBack.disabled;

                const backPageId = localBack.getAttribute("data-back") || "";
                const backTitle = getPageTitle(backPageId);

                if (!globalBack.disabled && backTitle) {
                    globalBack.textContent = `back: ${backTitle.toLowerCase()}`;
                } else {
                    globalBack.textContent = "back";
                }
            } else {
                globalBack.disabled = true;
                globalBack.textContent = "back";
            }

            // -----------------
            // NEXT button label (keep your current behavior)
            // -----------------
            if (localNext) {
                globalNext.disabled = !!localNext.disabled;
                globalNext.textContent = localNext.textContent || "next";
            } else {
                globalNext.disabled = true;
                globalNext.textContent = "next";
            }
        }

        function syncUIState(pageId) {
            // global nav
            if (typeof updateGlobalNavVisibility === "function") {
                updateGlobalNavVisibility(pageId);
            }

            // drawing panel (desktop)
            if (typeof setDrawingPanelVisibility === "function") {
                setDrawingPanelVisibility(pageId);
            }

            // mobile drawing visibility
            if (typeof updateMobileDrawingVisibility === "function") {
                updateMobileDrawingVisibility();
            }
            // hide price button on page1 + page2 (desktop)
            const priceBtn = document.getElementById("price-button");
            if (priceBtn) {
                const hide = (pageId === "page1" || pageId === "page2");
                priceBtn.style.display = hide ? "none" : "block";
            }
            // --- Page 4: hide stile options for single-section vanities ---
            if (pageId === "page4") {
                const model = computeModel();
                updateStileAndRailControlsVisibility(model);
            }

        }


        function updateGlobalNavVisibility(pageId) {
            const backBtn = document.getElementById("global-back");
            if (!backBtn) return;

            // hide back button only on page1
            backBtn.style.visibility = (pageId === "page1") ? "hidden" : "visible";
        }


        // hook up the bottom nav buttons
        (function attachGlobalNavHandlers() {
            const globalBack = document.getElementById("global-back");
            const globalNext = document.getElementById("global-next");
            if (!globalBack || !globalNext) return;

            globalBack.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localBack = activePage.querySelector(".nav-buttons .back");
                if (!localBack || localBack.disabled) return;

                const backPage = localBack.getAttribute("data-back");
                if (!backPage) return;

                goToPage(backPage);
            });

            globalNext.addEventListener("click", () => {
                const activePage = document.querySelector(".page.active");
                if (!activePage) return;

                const localNext = activePage.querySelector(".nav-buttons .next");
                if (!localNext || localNext.disabled) return;

                const nextPage = localNext.getAttribute("data-next");
                if (!nextPage) return;

                goToPage(nextPage);
            });
        })();
        setupMobileDrawingBarHandlers();




        /* ======================================================================= */
        /* === SECTION: MOBILE MODE DETECTION                                   === */
        /* ======================================================================= */

        // TEMP: keep the real app visible on mobile.
        // Your current #mobile-app does not render pages/forms, so hiding #desktop-layout breaks mobile.
        function checkMobileMode() {
            // Disabled: mobile/desktop visibility is controlled by CSS now.
            // Leaving this avoids inline styles fighting your media queries.
        }

        /* ======================================================================= */
        /* === SECTION: DRAWING ENGINE â€“ V1 (OUTLINE ONLY)                       === */
        /* ======================================================================= */

        function ensureSvgSetup() {
            const svg = getActiveDrawingSvg();   // âœ… mobile uses #mobileVanityDrawing
            if (!svg) return;

            svg.setAttribute("viewBox", "0 0 900 400");
            svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

            svg.style.display = "block";
        }


        // read optional frame overrides from inputs (if you add them later)
        function readFrameOverrides() {
            const overrides = {};

            const leg = Number(document.getElementById("frameLegWidth")?.value);
            if (leg > 0) overrides.legWidthIn = leg;

            const stile = Number(document.getElementById("frameStileWidth")?.value);
            if (stile > 0) overrides.stileWidthIn = stile;

            const topRail = Number(document.getElementById("frameTopRailHeight")?.value);
            if (topRail > 0) overrides.topRailHeightIn = topRail;

            const bottomRail = Number(document.getElementById("frameBottomRailHeight")?.value);
            if (bottomRail > 0) overrides.bottomRailHeightIn = bottomRail;

            return overrides;
        }

        // =======================================================
        // PRICING ADJUSTMENTS (easy to change later)
        // =======================================================
        const PRICING = {
            BASE_PER_FOOT: 900,

            SHELF_BELOW: 500,
            INTERIOR_SHELF: 50,        // per shelf
            DRAWERS_UNDER_SINK: 450,   // per sink
            MAKEUP_DESK: 300,
            OPEN_BELOW: 100,

            RETURN_SIDE: 250,          // per exposed side

            EXTRA_DRAWER: 175          // âœ… per additional drawer (user-added)
        };

        function computePriceBreakdown(model) {
            const breakdown = {
                base: 0,
                extras: [],
                total: 0
            };

            // -----------------------
            // BASE PRICE
            // -----------------------
            const basePrice = (model.widthIn / 12) * PRICING.BASE_PER_FOOT;
            breakdown.base = Math.round(basePrice);

            // -----------------------
            // SHELF BELOW
            // -----------------------
            if (model.shelfBelow) {
                breakdown.extras.push({
                    label: "Shelf below",
                    amount: PRICING.SHELF_BELOW
                });
            }

            // -----------------------
            // INTERIOR SHELVES
            // -----------------------
            const interiorShelfCount = Object.values(model.sectionOverrides || {})
                .filter(o => o?.interiorShelf === true).length;

            if (interiorShelfCount > 0) {
                breakdown.extras.push({
                    label: `Interior shelf Ã—${interiorShelfCount}`,
                    amount: interiorShelfCount * PRICING.INTERIOR_SHELF
                });
            }

            // -----------------------
            // âœ… EXTRA DRAWERS (USER-ADDED)
            // Counts drawers above the DEFAULT DRAWN count.
            // Default drawn count = what getFinalDrawerLayoutForSection()
            // would draw with NO override for that section.
            // -----------------------
            let extraDrawerCount = 0;

            const sections = model.sections || [];
            const overrides = model.sectionOverrides || {};

            // opening height must match drawing dims
            const openingHpx =
                (typeof model.openBottomY === "number" && typeof model.openTopY === "number")
                    ? (model.openBottomY - model.openTopY)
                    : 0;

            if (openingHpx > 0 && typeof getFinalDrawerLayoutForSection === "function") {
                sections.forEach((sec, idx) => {
                    if (sec.role !== "drawer") return;

                    const o = overrides[idx];
                    const hasOverride = o && typeof o.drawerCount === "number";

                    // If user didn't override this section, it can't add "extra drawers"
                    if (!hasOverride) return;

                    // --- A) what is the DEFAULT actually drawn count? ---
                    const defaultModel = { ...model, sectionOverrides: { ...overrides } };
                    if (defaultModel.sectionOverrides[idx]) {
                        // temporarily remove ONLY this section's drawerCount override
                        const copy = { ...defaultModel.sectionOverrides[idx] };
                        delete copy.drawerCount;
                        defaultModel.sectionOverrides[idx] = copy;
                    }

                    const defaultLayout = getFinalDrawerLayoutForSection(defaultModel, idx, openingHpx);
                    const defaultCount = Number(defaultLayout?.drawerCount) || 0;

                    // --- B) what is the OVERRIDDEN actually drawn count? ---
                    const overrideLayout = getFinalDrawerLayoutForSection(model, idx, openingHpx);
                    const overrideCount = Number(overrideLayout?.drawerCount) || 0;

                    if (overrideCount > defaultCount) {
                        extraDrawerCount += (overrideCount - defaultCount);
                    }
                });
            }

            if (extraDrawerCount > 0) {
                breakdown.extras.push({
                    label: `Extra drawer Ã—${extraDrawerCount}`,
                    amount: extraDrawerCount * PRICING.EXTRA_DRAWER
                });
            }

            // -----------------------
            // DRAWERS UNDER SINK
            // only when ALL drawers
            // -----------------------
            const allDrawers =
                model.sections?.length &&
                model.sections.every(sec => sec.role === "drawer");

            if (allDrawers && model.sinkCount > 0) {
                breakdown.extras.push({
                    label: `U shaped drawers under sink Ã—${model.sinkCount}`,
                    amount: model.sinkCount * PRICING.DRAWERS_UNDER_SINK
                });
            }

            // -----------------------
            // MAKEUP DESK
            // -----------------------
            if (model.hasMakeupDesk) {
                breakdown.extras.push({
                    label: "Makeup desk",
                    amount: PRICING.MAKEUP_DESK
                });
            }

            // -----------------------
            // OPEN BELOW
            // -----------------------
            if (model.bottomDetail === "open-below" || model.floating) {
                breakdown.extras.push({
                    label: "Open below",
                    amount: PRICING.OPEN_BELOW
                });
            }

            // -----------------------
            // RETURNS / VISIBLE SIDES
            // -----------------------
            if (model.visibleSides === "left") {
                breakdown.extras.push({ label: "Left return", amount: PRICING.RETURN_SIDE });
            } else if (model.visibleSides === "right") {
                breakdown.extras.push({ label: "Right return", amount: PRICING.RETURN_SIDE });
            } else if (model.visibleSides === "both") {
                breakdown.extras.push({
                    label: "Left + right returns",
                    amount: PRICING.RETURN_SIDE * 2
                });
            }

            // -----------------------
            // TOTAL
            // -----------------------
            const extrasTotal = breakdown.extras.reduce((sum, e) => sum + e.amount, 0);
            breakdown.total = breakdown.base + extrasTotal;

            return breakdown;
        }

        function computeCurrentPrice(model) {
            return computePriceBreakdown(model).total;
        }

        function updatePriceUI(model) {
            const breakdown = computePriceBreakdown(model);

            const amountEl = document.getElementById("price-amount");
            const panel = document.getElementById("price-breakdown");

            if (!amountEl || !panel) return;

            amountEl.textContent = `$${breakdown.total.toLocaleString()}`;

            // Build breakdown HTML
            let html = `<h4>price summary</h4>`;

            html += `
        <div class="price-line">
            <span>base price</span>
            <span>$${breakdown.base.toLocaleString()}</span>
        </div>
    `;

            if (breakdown.extras.length) {
                html += `<h4 style="margin-top:10px">extras</h4>`;
                breakdown.extras.forEach(e => {
                    html += `
                <div class="price-line extra">
                    <span>${e.label}</span>
                    <span>+$${e.amount.toLocaleString()}</span>
                </div>
            `;
                });
            }

            html += `
        <div class="price-line price-total">
            <span>total</span>
            <span>$${breakdown.total.toLocaleString()}</span>
        </div>
    `;

            panel.innerHTML = html;
        }


        function updatePriceVisibility(currentPageId) {
            const priceBox = document.getElementById("priceBox");
            if (!priceBox) return;

            // hide on page1 and page2
            const hide =
                currentPageId === "page1" ||
                currentPageId === "page2";

            priceBox.style.display = hide ? "none" : "flex";
        }


        function getDrawingScalePxPerInch() {
            const BASE_PX_PER_INCH = 2.0;   // â† your current visual size
            return BASE_PX_PER_INCH * DRAWING_ZOOM;
        }



        function computeModel() {
            const widthField = document.getElementById("width");
            const heightField = document.getElementById("height");
            const depthField = document.getElementById("depth");

            let widthInRaw = Number(widthField?.value || 0);
            let heightInRaw = Number(heightField?.value || 0);
            let depthInRaw = Number(depthField?.value || 0);

            // Spinner protection
            if (widthField?.value === "0") { widthInRaw = 30; widthField.value = "30"; }
            if (heightField?.value === "0") { heightInRaw = 34.5; heightField.value = "34.5"; }
            if (depthField?.value === "0") { depthInRaw = 22; depthField.value = "22"; }

            // Defaults
            if (!widthInRaw) widthInRaw = 30;
            if (!heightInRaw) heightInRaw = 34.5;
            if (!depthInRaw) depthInRaw = 22;

            // Snap to 1/4"
            widthInRaw = Math.round(widthInRaw * 4) / 4;
            heightInRaw = Math.round(heightInRaw * 4) / 4;
            depthInRaw = Math.round(depthInRaw * 4) / 4;

            // Clamp
            widthInRaw = Math.min(Math.max(widthInRaw, 18), 200);
            heightInRaw = Math.min(Math.max(heightInRaw, 6), 96);
            depthInRaw = Math.min(Math.max(depthInRaw, 12), 30);

            // Styles
            const doorStyle = document.getElementById("doorStyle")?.value || "shaker";
            const drawerStyle = document.getElementById("drawerStyle")?.value || "slab";
            const topDrawerHeightPreset = document.getElementById("topDrawerHeightPreset")?.value || "equal";
            const floating = document.getElementById("floating")?.value === "true";

            const visibleSideStyle = document.getElementById("visibleSideStyle")?.value || "shaker";


            // Toe kick / open-below
            const toeInput = document.getElementById("toeKickHeight");
            let rawToe = Math.round((Number(toeInput?.value || 4)) * 4) / 4;
            rawToe = Math.min(Math.max(rawToe, 2.5), 24);

            const bottomDetail = document.getElementById("bottomDetail")?.value || "toe-kick";
            const toeKickHeightIn = bottomDetail === "toe-kick"
                ? Math.min(Math.max(rawToe, 2.5), 7)
                : Math.min(Math.max(rawToe, 2.5), 24);

            // Sinks
            const sinkCount = Number(document.getElementById("sinkCount")?.value) || 0;
            const layoutPreset = document.getElementById("layoutPreset")?.value || "";
            const sinkPosition = document.getElementById("sinkPosition")?.value || "center";




            // Shelf
            let shelfBelow =
                document.getElementById("shelfBelow")?.value === "yes";

            let shelfSpaceIn = DEFAULT_SHELF_SPACE_IN;

            const makeupDeskEnabled =
                document.getElementById("makeupDeskEnabled")?.value === "yes";

            const makeupDeskPosition =
                document.getElementById("makeupDeskPosition")?.value || "center";

            let makeupDeskWidthIn =
                Number(document.getElementById("makeupDeskWidth")?.value) || 26;

            let makeupDeskHeightIn =
                Number(document.getElementById("makeupDeskHeight")?.value) || 4;

            // clamp defensively
            makeupDeskWidthIn = Math.max(24, Math.min(36, makeupDeskWidthIn));
            makeupDeskHeightIn = Math.max(3, Math.min(5, makeupDeskHeightIn));


            // Default drawer stack behavior
            const defaultDrawerStackCount = shelfBelow ? 2 : 3;

            const drawerStackConfig = {
                defaultCount: defaultDrawerStackCount,
                userOverride: null
            };

            if (shelfBelow) {
                const raw = parseFloat(document.getElementById("shelfSpaceIn")?.value);
                if (isFinite(raw)) shelfSpaceIn = raw;
                shelfSpaceIn = Math.min(Math.max(shelfSpaceIn, MIN_SHELF_SPACE_IN), MAX_SHELF_SPACE_IN);
            }

            let shelfThicknessIn = Number(document.getElementById("shelfThickness")?.value) || 2;
            shelfThicknessIn = Math.min(Math.max(shelfThicknessIn, 1.5), 3);

            // Drawer rails
            const drawerRailsMode = document.getElementById("drawerRailsMode")?.value || "none";

            let drawerRailHeightIn = parseFloat(document.getElementById("drawerRailHeightIn")?.value);
            if (!isFinite(drawerRailHeightIn) || drawerRailHeightIn <= 0)
                drawerRailHeightIn = DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            // Visible sides
            const visibleSides = document.getElementById("visibleSides")?.value || "both";

            // ============================
            // COMBINED FRAME OPTIONS
            // ============================

            // --- Stiles ---
            const stileSel = document.getElementById("frameStileWidth");
            const rawStile = stileSel?.value;
            const removeStiles = rawStile === "remove";
            const stileWidthIn = removeStiles ? 0 : Number(rawStile);

            // --- Top rail ---
            const topSel = document.getElementById("frameTopRailHeight");
            const rawTop = topSel?.value;
            const removeTopRail = rawTop === "remove";
            const topRailHeightIn = removeTopRail ? 0 : Number(rawTop);

            // --- Bottom rail ---
            const botSel = document.getElementById("frameBottomRailHeight");
            const rawBot = botSel?.value;
            const removeBottomRail = rawBot === "remove";
            const bottomRailHeightIn = removeBottomRail ? 0 : Number(rawBot);

            // Frame leg width (unchanged)
            const legWidthIn = Number(document.getElementById("frameLegWidth")?.value) || FRAME_DEFAULTS.legWidthIn;

            // Drawer width controls
            const singleDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthSingle")?.value || 0)) * 4) / 4;
            const outerDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthOuter")?.value || 0)) * 4) / 4;
            const centerDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthCenter")?.value || 0)) * 4) / 4;
            const twoSectionDrawerWidthIn =
                Math.round((Number(document.getElementById("drawerWidthTwoSection")?.value || 0)) * 4) / 4;

            // Final size guards
            const safeWidthIn = Math.max(widthInRaw, 18);
            const safeHeightIn = floating
                ? Math.max(heightInRaw, 14)
                : Math.max(heightInRaw, 20);

            // Floating gap
            let floatingGapIn = floating ? FLOAT_TOP_HEIGHT_IN - safeHeightIn : 0;
            if (floatingGapIn < 0) floatingGapIn = 0;

            // =====================================================
            // FIXED DRAWING SCALE (NO AUTO-FIT)
            // =====================================================

            // ðŸ”’ single source of truth
            const inchToPx = getDrawingScalePxPerInch(); // e.g. 8, later * zoom

            // Drawing height is fixed visually
            const viewH = 400;
            const bottomMargin = 45;

            // cabinet pixel size
            const cabW = safeWidthIn * inchToPx;
            const cabH = safeHeightIn * inchToPx;

            // vertical placement: keep cabinet sitting on floor line
            const floorY = viewH - bottomMargin;
            const gapPx = floating ? floatingGapIn * inchToPx : 0;

            const cabBottomY = floorY - gapPx;

            // ðŸ”’ IMPORTANT: X origin is NOT centered anymore
            // Run layout controls horizontal positioning
            const originX = 10 * inchToPx;

            const originY = cabBottomY - cabH;


            const sinkBowlWidthIn =
                sinkCount > 0 ? chooseDefaultSinkSize(safeWidthIn, sinkCount) : 0;

            // Build FRAME
            const frame = {
                legWidthIn,
                stileWidthIn,
                topRailHeightIn,
                bottomRailHeightIn,
                removeStiles,
                removeTopRail,
                removeBottomRail,
                legs: [
                    { xIn: 0 },
                    { xIn: safeWidthIn - legWidthIn }
                ]
            };

            // Build MODEL
            const model = {
                widthIn: safeWidthIn,
                heightIn: safeHeightIn,
                depthIn: depthInRaw,
                floating,
                floatingGapIn,
                toeKickHeightIn,
                bottomDetail,
                sectionOverrides,


                sinkCount,
                sinkPosition,
                sinkBowlWidthIn,
                layoutPreset,

                makeupDeskEnabled,
                makeupDeskPosition,
                makeupDeskWidthIn,
                makeupDeskHeightIn,


                doorStyle,
                drawerStyle,
                topDrawerHeightPreset,
                drawerStackConfig,

                drawerRailsMode,
                drawerRailHeightIn,

                drawerControls: {
                    singleDrawerWidthIn,
                    outerDrawerWidthIn,
                    centerDrawerWidthIn,
                    twoSectionDrawerWidthIn
                },

                visibleSides,
                visibleSideStyle,

                shelfBelow,
                shelfSpaceIn,
                shelfThicknessIn,

                scale: { inchToPx, originX, originY },
                frame
            };

            // Compute sections now that model exists
            model.sections = computeSections(model);

            // =====================================================
            // HARD RULE: rails require stiles on multi-section
            // =====================================================
            const isSingleSection = model.sections.length === 1;
            const stilesRemoved = model.frame?.removeStiles === true;

            if (!isSingleSection && stilesRemoved) {
                model.drawerRailsMode = "none";
                model.drawerRailHeightIn = 0;
            }


            // attach persistent section overrides
            model.sectionOverrides = sectionOverrides;

            // =====================================================
            // INVALIDATE INTERIOR SHELVES WHEN NO DOOR SECTIONS
            // =====================================================

            const hasDoorSection = model.sections.some(sec => sec.role === "door");

            if (!hasDoorSection && model.sectionOverrides) {
                Object.keys(model.sectionOverrides).forEach(idx => {
                    if (model.sectionOverrides[idx]?.interiorShelf) {
                        delete model.sectionOverrides[idx].interiorShelf;
                    }
                });
            }


            // Shelf px conversion
            model.shelfThicknessPx = shelfThicknessIn * inchToPx;

            // ===========================================================
            // PATCH 7 â€” cache case-opening vertical geometry in model
            // ===========================================================
            const geom = computeCaseOpeningVertical(model);

            // Basic open span
            model.openTopY = geom.openTopY;
            model.openBottomY = geom.openBottomY;

            // Helper geometry
            model.cabTopY = geom.openTopY;         // alias for consistency
            model.cabBottomY = geom.openBottomY;   // alias for consistency

            // Extra geometry only if computeCaseOpeningVertical returns them
            if (geom.caseBottomY !== undefined) model.caseBottomY = geom.caseBottomY;
            if (geom.shelfTopY !== undefined) model.shelfTopY = geom.shelfTopY;
            if (geom.shelfBottomY !== undefined) model.shelfBottomY = geom.shelfBottomY;
            if (geom.toeKickPx !== undefined) model.toeKickPx = geom.toeKickPx;

            // Return the final model
            return model;

        }



        // ---------------------------------------------------------------
        // LAYOUT CONSTANTS + LIBRARY
        // ---------------------------------------------------------------
        // LAYOUT CONSTRAINTS
        const MIN_DRAWER_WIDTH = 8.5;
        const MIN_DOOR_LEAF_WIDTH = 10;
        const MAX_SECTION_WIDTH = 40;
        const MIN_WIDTH_IN = 18; // hard minimum vanity width the UI should accept

        const MIN_SINK_SECTION_WIDTH = 15.5;      // ABSOLUTE LOWEST allowed (user adjustment)
        const DEFAULT_MIN_SINK_SECTION_WIDTH = 20; // Minimum sink section width for default layouts

        // Smallest valid double-sink vanity width (inches), based on:
        //  - two 20" sink sections (DEFAULT_MIN_SINK_SECTION_WIDTH)
        //  - one 8.5" drawer bay (MIN_DRAWER_WIDTH)
        //  - default 2" legs each side (FRAME_DEFAULTS.legWidthIn)
        //  - default 1.5" stiles between 3 sections (FRAME_DEFAULTS.stileWidthIn, 2 gaps)
        //
        // interiorWidth = 2*20 + 8.5 = 48.5
        // plus 2 stiles = 3.0 â†’ 51.5 between legs
        // plus 2 legs  = 4.0 â†’ 55.5 overall
        const MIN_DOUBLE_SINK_WIDTH_IN =
            2 * DEFAULT_MIN_SINK_SECTION_WIDTH +
            MIN_DRAWER_WIDTH +
            2 * FRAME_DEFAULTS.stileWidthIn +
            2 * FRAME_DEFAULTS.legWidthIn;

        // Adjust section widths based on the drawer width controls,
        // WITHOUT touching anything unless the user actually edited a field.
        function applyDrawerWidthOverrides(model, sections) {
            if (!sections || !sections.length) return sections;

            const sectionCount = sections.length;

            // snap helpers
            function snapTo(val, denom) {
                if (!val || !isFinite(val)) return 0;
                return Math.round(val * denom) / denom;
            }
            const snapQuarter = (v) => snapTo(v, 4); // user inputs
            const snapEighth = (v) => snapTo(v, 8); // internal reconciliation

            // read a drawer width from an <input> by id, return snapped inches or null
            function readDrawerInput(id) {
                const el = document.getElementById(id);
                if (!el) return null;
                const raw = parseFloat(el.value);
                if (!isFinite(raw) || raw <= 0) return null;
                return snapQuarter(raw);
            }

            // minimums
            const MIN_W = 8.5; // general bay minimum
            const MIN_SINK_W = (typeof DEFAULT_MIN_SINK_SECTION_WIDTH === "number")
                ? DEFAULT_MIN_SINK_SECTION_WIDTH
                : 20;

            // Sink bays are protected; everything else is adjustable
            const sinkIdx = computeSinkSectionIndices(model, sections) || [];
            if (!sinkIdx.length) return sections;

            const protectedSet = new Set(sinkIdx);
            const protectedIdx = sections.map((_, i) => i).filter(i => protectedSet.has(i));
            const adjustableIdx = sections.map((_, i) => i).filter(i => !protectedSet.has(i));

            if (!adjustableIdx.length || !protectedIdx.length) return sections;

            // Total interior span is the sum of section widths
            const totalWidth = sections.reduce((sum, s) => sum + (s.widthIn || 0), 0);
            if (!(totalWidth > 0)) return sections;

            // -----------------------------
            // Decide which control is active
            // -----------------------------
            const targets = {}; // idx -> desired width
            let appliedAny = false;

            // 2-section: dedicated field
            if (sectionCount === 2 && drawerOverrideFlags?.twoSection) {
                const desired = readDrawerInput("drawerWidthTwoSection");
                if (desired != null) {
                    const adj = adjustableIdx[0];
                    targets[adj] = Math.max(MIN_W, desired);
                    appliedAny = true;
                }
            }

            // 3-section: single field
            if (!appliedAny && sectionCount === 3 && drawerOverrideFlags?.single) {
                const desired = readDrawerInput("drawerWidthSingle");
                if (desired != null) {
                    adjustableIdx.forEach(i => targets[i] = Math.max(MIN_W, desired));
                    appliedAny = true;
                }
            }

            // 5-section: outer/center if meaningful, else single
            if (!appliedAny && sectionCount === 5) {
                const minAdj = Math.min(...adjustableIdx);
                const maxAdj = Math.max(...adjustableIdx);

                const outerAdj = adjustableIdx.filter(i => i === minAdj || i === maxAdj);
                const centerAdj = adjustableIdx.filter(i => i !== minAdj && i !== maxAdj);

                const canUseOuterCenter = outerAdj.length && centerAdj.length;

                if (canUseOuterCenter && (drawerOverrideFlags?.outer || drawerOverrideFlags?.center)) {
                    if (drawerOverrideFlags.outer) {
                        const o = readDrawerInput("drawerWidthOuter");
                        if (o != null) {
                            outerAdj.forEach(i => targets[i] = Math.max(MIN_W, o));
                            appliedAny = true;
                        }
                    }
                    if (drawerOverrideFlags.center) {
                        const c = readDrawerInput("drawerWidthCenter");
                        if (c != null) {
                            centerAdj.forEach(i => targets[i] = Math.max(MIN_W, c));
                            appliedAny = true;
                        }
                    }
                } else if (drawerOverrideFlags?.single) {
                    const desired = readDrawerInput("drawerWidthSingle");
                    if (desired != null) {
                        adjustableIdx.forEach(i => targets[i] = Math.max(MIN_W, desired));
                        appliedAny = true;
                    }
                }
            }

            // fallback: single field if flagged and nothing else applied
            if (!appliedAny && drawerOverrideFlags?.single) {
                const desired = readDrawerInput("drawerWidthSingle");
                if (desired != null) {
                    adjustableIdx.forEach(i => targets[i] = Math.max(MIN_W, desired));
                    appliedAny = true;
                }
            }

            if (!appliedAny) return sections;

            // Fill unspecified adjustable targets with current widths (so partial overrides work)
            adjustableIdx.forEach(i => {
                if (targets[i] == null) targets[i] = Math.max(MIN_W, sections[i].widthIn || 0);
            });

            // -----------------------------
            // Clamp so protected sink bays never drop below MIN_SINK_W
            // -----------------------------
            const protectedMinTotal = protectedIdx.length * MIN_SINK_W;
            const maxAdjustableTotal = totalWidth - protectedMinTotal;

            const adjustableMinTotal = adjustableIdx.length * MIN_W;
            if (maxAdjustableTotal < adjustableMinTotal - 1e-6) {
                return sections;
            }

            let adjustableTotal = adjustableIdx.reduce((sum, i) => sum + (targets[i] || 0), 0);

            // If too large, scale down (but not below MIN_W)
            if (adjustableTotal > maxAdjustableTotal + 1e-6) {
                const excess = adjustableTotal - maxAdjustableTotal;

                const reducible = adjustableIdx.reduce((sum, i) => {
                    return sum + Math.max(0, (targets[i] || 0) - MIN_W);
                }, 0);

                if (reducible <= 1e-6) return sections;

                adjustableIdx.forEach(i => {
                    const cur = targets[i] || 0;
                    const room = Math.max(0, cur - MIN_W);
                    const cut = excess * (room / reducible);
                    targets[i] = snapQuarter(Math.max(MIN_W, cur - cut));
                });

                adjustableTotal = adjustableIdx.reduce((sum, i) => sum + (targets[i] || 0), 0);
            }

            // -----------------------------
            // Distribute remaining width to protected sink bays
            // -----------------------------
            const protectedTotal = totalWidth - adjustableTotal;

            // If exactly two protected bays (double sinks), start them equal
            const forceEqualProtected = (protectedIdx.length === 2 && (model.sinkCount || 0) === 2);

            const protWidths = {};
            if (forceEqualProtected) {
                const each = snapEighth(protectedTotal / 2);
                protWidths[protectedIdx[0]] = each;
                protWidths[protectedIdx[1]] = each;
            } else {
                // Start with minimums
                protectedIdx.forEach(i => protWidths[i] = MIN_SINK_W);

                let remaining = protectedTotal - protectedMinTotal;
                if (remaining < -1e-6) return sections;

                // Distribute remaining proportionally by current (width - min)
                const weights = protectedIdx.map(i => {
                    const cur = sections[i].widthIn || 0;
                    return Math.max(0, cur - MIN_SINK_W);
                });
                const weightSum = weights.reduce((a, b) => a + b, 0);

                if (weightSum > 1e-6) {
                    protectedIdx.forEach((i, k) => {
                        protWidths[i] = snapEighth(MIN_SINK_W + remaining * (weights[k] / weightSum));
                    });
                } else {
                    const add = remaining / protectedIdx.length;
                    protectedIdx.forEach(i => {
                        protWidths[i] = snapEighth(MIN_SINK_W + add);
                    });
                }
            }

            // Apply widths back to sections (NO xIn here)
            adjustableIdx.forEach(i => {
                sections[i].widthIn = targets[i];
            });
            protectedIdx.forEach(i => {
                sections[i].widthIn = protWidths[i];
            });

            // ============================================================
            // CRITICAL: reconcile total width in 1/8" units so we never drift
            // and so 1/4" changes can split as 1/8"+1/8" across two sinks.
            // ============================================================
            const denom = 8;
            const targetUnits = Math.round(totalWidth * denom);

            const minAdjUnits = Math.round(MIN_W * denom);
            const minSinkUnits = Math.round(MIN_SINK_W * denom);

            const units = sections.map(s => Math.round((s.widthIn || 0) * denom));
            let sumUnits = units.reduce((a, b) => a + b, 0);
            let delta = targetUnits - sumUnits; // >0 means we need to ADD units somewhere

            function minUnitsFor(i) {
                return protectedSet.has(i) ? minSinkUnits : minAdjUnits;
            }
            function canDec(i) {
                return units[i] > minUnitsFor(i);
            }

            function dec(i) { units[i] -= 1; delta += 1; }
            function inc(i) { units[i] += 1; delta -= 1; }

            const protOrder = [...protectedIdx];
            const adjOrder = [...adjustableIdx];

            // If removing units, remove from protected first (they are the compensation pool), then adjustable
            while (delta < 0) {
                let changed = false;

                // If two protected bays and we want symmetry, remove alternating so they stay equal-ish
                if (forceEqualProtected) {
                    for (const i of protOrder) {
                        if (!canDec(i)) continue;
                        dec(i);
                        changed = true;
                        if (delta === 0) break;
                    }
                } else {
                    for (const i of protOrder) {
                        if (!canDec(i)) continue;
                        dec(i);
                        changed = true;
                        if (delta === 0) break;
                    }
                }

                if (delta === 0) break;

                if (!changed) {
                    for (const i of adjOrder) {
                        if (!canDec(i)) continue;
                        dec(i);
                        changed = true;
                        if (delta === 0) break;
                    }
                }

                if (!changed) break;
            }

            // If adding units, add to protected bays (split evenly when there are two)
            while (delta > 0) {
                if (forceEqualProtected) {
                    inc(protOrder[0]);
                    if (delta > 0) inc(protOrder[1]);
                } else {
                    inc(protOrder[0]);
                }
            }

            // Final symmetry lock if two protected bays
            if (forceEqualProtected) {
                const a = protOrder[0], b = protOrder[1];
                const avg = Math.floor((units[a] + units[b]) / 2);
                units[a] = avg;
                units[b] = (units[a] + units[b]) - avg; // keep sum the same
                // if we made them uneven by 1 unit, fix by giving 1 unit to the other
                const diff = units[a] - units[b];
                if (diff === 1) { units[a] -= 1; units[b] += 1; }
                if (diff === -1) { units[a] += 1; units[b] -= 1; }
            }

            // Write back reconciled widths
            for (let i = 0; i < sections.length; i++) {
                sections[i].widthIn = units[i] / denom;
            }

            return sections;
        }


        // 2-SECTION LAYOUT OVERRIDE (drawer bay + other bay)
        //
        // IMPORTANT:
        // - widths in "sections" are FACE widths only
        // - gaps (stiles) must remain gaps, not get baked into face widths
        function applyTwoSectionDrawerOverride(model, sectionsOverride) {
            const sections = sectionsOverride || model.sections || [];
            if (!sections || sections.length < 2) return;

            const twoInput = document.getElementById("drawerWidthTwoSection");
            if (!twoInput) return;

            // Only apply if the user has edited this field
            if (!drawerOverrideFlags || !drawerOverrideFlags.twoSection) return;

            // Don't fight the user while typing
            if (document.activeElement === twoInput) return;

            let requested = Number(twoInput.value);
            if (!isFinite(requested) || requested <= 0) return;

            // Only works when there is exactly ONE drawer section
            const drawerIdx = sections.findIndex(sec => sec.role === "drawer");
            if (drawerIdx === -1) return;

            const drawerCount = sections.filter(s => s.role === "drawer").length;
            if (drawerCount !== 1) return;

            // Gap width (stiles) stays as a gap
            const removeStiles = model.removeStiles === true || model.frame?.removeStiles === true;
            const gapWidthIn = removeStiles ? 0 : (model.frame?.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn ?? 0);
            const gapsCount = Math.max(sections.length - 1, 0);
            const totalGapIn = gapsCount * gapWidthIn;

            // Total FACE width available (exclude gaps)
            const totalFaceIn = sections.reduce((sum, s) => sum + (Number(s.widthIn) || 0), 0);
            if (!isFinite(totalFaceIn) || totalFaceIn <= 0) return;

            // Min face width guard
            const MIN_FACE =
                (typeof MIN_DRAWER_WIDTH === "number" && isFinite(MIN_DRAWER_WIDTH) && MIN_DRAWER_WIDTH > 0)
                    ? MIN_DRAWER_WIDTH
                    : ((typeof MIN_SECTION_WIDTH === "number" && isFinite(MIN_SECTION_WIDTH) && MIN_SECTION_WIDTH > 0)
                        ? MIN_SECTION_WIDTH
                        : 8.5);

            // Clamp requested face width so "other" still has at least MIN_FACE
            requested = Math.round(requested * 4) / 4;
            if (requested < MIN_FACE) requested = MIN_FACE;
            if (requested > totalFaceIn - MIN_FACE) requested = totalFaceIn - MIN_FACE;

            const otherFaceTotal = totalFaceIn - requested;

            // other sections (everything except drawer bay)
            const others = sections.map((s, i) => ({ s, i })).filter(o => o.i !== drawerIdx);
            if (!others.length) return;

            const oldOtherTotal = others.reduce((sum, o) => sum + (Number(o.s.widthIn) || 0), 0);
            if (!isFinite(oldOtherTotal) || oldOtherTotal <= 0) return;

            // Apply new face widths
            sections[drawerIdx].widthIn = requested;

            // Scale other face widths proportionally into otherFaceTotal
            let running = 0;
            for (let k = 0; k < others.length; k++) {
                const o = others[k].s;

                let w;
                if (k === others.length - 1) {
                    // last gets the remainder (prevents rounding drift)
                    w = otherFaceTotal - running;
                } else {
                    const frac = (Number(o.widthIn) || 0) / oldOtherTotal;
                    w = otherFaceTotal * frac;
                }

                w = Math.max(MIN_FACE, w);
                w = Math.round(w * 4) / 4;

                o.widthIn = w;
                running += w;
            }

            // Re-tile left->right using EXISTING left edge and the gap width
            const leftEdgeIn = sections[0].xIn;
            let cursor = leftEdgeIn;

            for (let i = 0; i < sections.length; i++) {
                sections[i].xIn = cursor;
                cursor += sections[i].widthIn;
                if (i < sections.length - 1) cursor += gapWidthIn;
            }

            // Sync field to the clamped value (but never while focused)
            twoInput.value = String(Math.round(requested * 4) / 4);
        }


        function computeSections(model) {
            const { widthIn, frame, sinkCount, layoutPreset } = model;

            const legWidthIn = frame?.legWidthIn ?? FRAME_DEFAULTS.legWidthIn;
            const stileWidthInRaw = frame?.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn;
            const removeStiles = model.removeStiles;   // flag: stiles removed

            // === drawer width controls coming from the model ===
            const drawerControls = model.drawerControls || {};
            const singleDw = drawerControls.singleDrawerWidthIn || 0;
            const outerDw = drawerControls.outerDrawerWidthIn || 0;
            const centerDw = drawerControls.centerDrawerWidthIn || 0;
            const twoDw = drawerControls.twoSectionDrawerWidthIn || 0;

            // interior between legs
            const interiorStartIn = legWidthIn;
            const interiorEndIn = widthIn - legWidthIn;
            const interiorWidthIn = interiorEndIn - interiorStartIn;
            if (interiorWidthIn <= 0) return [];

            // --- pick layout (just for roles + sectionCount) -------------------
            const allLayouts = getLayoutsFor(
                widthIn,
                sinkCount,
                model.sinkPosition || "center"
            );

            const defaultSectionCount = getDefaultSectionCount(widthIn, sinkCount);

            let chosenLayout = null;

            if (layoutPreset) {
                chosenLayout = allLayouts.find(l => l.id === layoutPreset) || null;
            }

            if (!chosenLayout) {
                chosenLayout =
                    allLayouts.find(l => l.isDefault) ||
                    allLayouts[0] ||
                    null;
            }

            let sectionCount;
            let roles = [];

            if (chosenLayout) {
                sectionCount = chosenLayout.sectionCount;
                roles = chosenLayout.roles.slice();

                // keep the <select> in sync with any fallback we chose
                const layoutSel = document.getElementById("layoutPreset");
                if (layoutSel && layoutSel.value !== chosenLayout.id) {
                    layoutSel.value = chosenLayout.id;
                }
            } else {
                // extreme edge case â€“ no layouts at all
                sectionCount = defaultSectionCount;
                roles = new Array(sectionCount).fill("door");
            }

            // gaps between sections (face-frame stiles) -------------------------
            const gaps = Math.max(sectionCount - 1, 0);
            const gapWidthIn = removeStiles ? 0 : stileWidthInRaw;

            const availableFaceWidthIn = interiorWidthIn - gaps * gapWidthIn;
            if (availableFaceWidthIn <= 0) return [];

            // base equal width for all sections
            const baseWidthIn = availableFaceWidthIn / sectionCount;

            // ================================================================
            // EARLY EXIT MODE:
            // If this vanity *could* have all sections equal at >= 20"
            // and the user has NOT overridden drawer widths, then
            // just make all sections equal and return.
            // ================================================================
            const hasSink = (sinkCount > 0);
            const equalSectionWidthIn = baseWidthIn;

            const canUseEqualSections =
                hasSink &&
                sectionCount > 1 &&
                equalSectionWidthIn >= DEFAULT_MIN_SINK_SECTION_WIDTH &&  // 20"
                !drawerOverrideFlags.single &&
                !drawerOverrideFlags.outer &&
                !drawerOverrideFlags.center &&
                !drawerOverrideFlags.twoSection; // âœ… IMPORTANT


            if (canUseEqualSections) {
                const sections = [];
                let xIn = interiorStartIn;

                for (let i = 0; i < sectionCount; i++) {
                    sections.push({
                        index: i,
                        xIn,
                        widthIn: equalSectionWidthIn,
                        role: roles[i] || "door"
                    });

                    xIn += equalSectionWidthIn;
                    if (i < sectionCount - 1) {
                        xIn += gapWidthIn;  // same stile width / 0 if removeStiles
                    }
                }
                applyDrawerWidthOverrides(model, sections);

                // âœ… Rebuild x-positions now that widths may have changed
                let runX = interiorStartIn;
                for (let i = 0; i < sections.length; i++) {
                    const sec = sections[i];
                    sec.xIn = runX;
                    runX += sec.widthIn;

                    if (i < sections.length - 1) {
                        runX += gapWidthIn;  // same stile width / 0 if removeStiles
                    }
                }

                return sections;

            }


            // -------------------------------------------------------------------
            // Start with equal widths
            // -------------------------------------------------------------------
            let widths = new Array(sectionCount).fill(baseWidthIn);

            // which sections are drawers?
            const drawerIndices = [];
            roles.forEach((role, i) => {
                if (role === "drawer") drawerIndices.push(i);
            });

            const hasSinks = (sinkCount && sinkCount > 0);
            const anyDrawerOverride =
                drawerOverrideFlags.single ||
                drawerOverrideFlags.outer ||
                drawerOverrideFlags.center ||
                drawerOverrideFlags.twoSection;

            // ============================================================
            // SINK-FIRST DEFAULT LAYOUT (no drawer overrides)
            // ============================================================
            if (hasSinks && sectionCount >= 2 && !anyDrawerOverride) {
                // 1) Build a provisional equal-width layout so we can ask
                //    "which sections get sinks?" using your existing logic.
                const provisionalSections = [];
                let runX0 = interiorStartIn;
                for (let i = 0; i < sectionCount; i++) {
                    const wIn = baseWidthIn;
                    provisionalSections.push({
                        index: i,
                        xIn: runX0,
                        widthIn: wIn,
                        role: roles[i] || "door"
                    });
                    runX0 += wIn;
                    if (i < sectionCount - 1) {
                        runX0 += gapWidthIn;
                    }
                }

                const sinkIndices = computeSinkSectionIndices({
                    ...model,
                    sections: provisionalSections
                });

                if (sinkIndices && sinkIndices.length) {
                    const nSinks = sinkIndices.length;
                    const nNonSinks = sectionCount - nSinks;

                    if (nNonSinks > 0) {
                        // How big can sinks be, while keeping drawers >= MIN_DRAWER_WIDTH?
                        const maxSinkWidth =
                            (availableFaceWidthIn - nNonSinks * MIN_DRAWER_WIDTH) / nSinks;

                        if (maxSinkWidth >= MIN_SINK_SECTION_WIDTH) {
                            // Target 20" by default, but never exceed what's feasible.
                            let sinkWidth = DEFAULT_MIN_SINK_SECTION_WIDTH; // 20"
                            if (sinkWidth > maxSinkWidth) sinkWidth = maxSinkWidth;

                            const remaining = availableFaceWidthIn - sinkWidth * nSinks;
                            const nonSinkWidth = remaining / nNonSinks;

                            const sinkSet = new Set(sinkIndices);
                            widths = widths.map((_, idx) =>
                                sinkSet.has(idx) ? sinkWidth : nonSinkWidth
                            );
                        }
                        // else: geometry is too tight to enforce 20"/15.5" nicely
                        //       (tiny / weird combos). In that case we just keep
                        //       the equal widths we started with. This is effectively
                        //       your "<24" exception in practice.
                    } else {
                        // all sections are sinks â€“ just make them equal
                        const per = availableFaceWidthIn / nSinks;
                        const sinkSet = new Set(sinkIndices);
                        widths = widths.map((_, idx) =>
                            sinkSet.has(idx) ? per : 0
                        );
                    }
                }
            }

            // ============================================================
            // DRAWER WIDTH LOGIC
            //
            // Apply ONLY when:
            //   - we have drawers, AND
            //   - either there are no sinks, OR the user has overridden
            //     the drawer widths (single / outer / center).
            // ============================================================
            if (drawerIndices.length && (!(hasSinks && sectionCount >= 2 && !anyDrawerOverride))) {

                // helper to snap to 1/4" and guard nonsense
                function normalizeDrawer(val) {
                    let v = Number(val);
                    if (!v || !isFinite(v) || v <= 0) return 0;
                    v = Math.round(v * 4) / 4;
                    if (v < MIN_DRAWER_WIDTH) v = MIN_DRAWER_WIDTH;
                    return v;
                }

                // -------------------------------------------------------
                // 3-SECTION: single drawer width control
                //   - if no sink overrides: we let user change drawers
                //     and keep door/sink bays >= MIN_SINK_SECTION_WIDTH.
                // -------------------------------------------------------
                if (sectionCount === 3) {
                    let dw = normalizeDrawer(singleDw);

                    // if user hasn't set anything yet (dw = 0), choose default = baseWidthIn
                    if (!dw) {
                        dw = baseWidthIn;

                        const input = document.getElementById("drawerWidthSingle");
                        if (input && !input.value) {
                            input.value = Math.round(dw * 4) / 4;
                        }
                    }

                    if (dw) {
                        const drawerCount = drawerIndices.length;
                        const doorCount = sectionCount - drawerCount;

                        // If we have sinks and at least one non-drawer section,
                        // clamp drawer width so the door/sink bays can't shrink
                        // below MIN_SINK_SECTION_WIDTH.
                        if (sinkCount > 0 && doorCount > 0) {
                            // door width = (availableFaceWidthIn - drawerCount * dw) / doorCount
                            // We want: doorWidth >= MIN_SINK_SECTION_WIDTH
                            // â†’ dw <= (availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH) / drawerCount
                            const maxDrawerTotal = availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH;

                            if (maxDrawerTotal > 0) {
                                const maxDwFromSink = maxDrawerTotal / drawerCount;
                                if (dw > maxDwFromSink) {
                                    dw = maxDwFromSink;
                                }
                            }
                        }

                        // global drawer minimum still applies
                        if (dw < MIN_DRAWER_WIDTH) {
                            dw = MIN_DRAWER_WIDTH;
                        }

                        // snap and sync the UI field with the clamped value
                        dw = Math.round(dw * 4) / 4;
                        const input = document.getElementById("drawerWidthSingle");
                        if (input) {
                            input.value = dw;
                        }

                        // --- now recompute widths using this clamped drawer width ---
                        const drawerTotal = dw * drawerCount;
                        const remaining = availableFaceWidthIn - drawerTotal;

                        if (doorCount > 0 && remaining > 0) {
                            const doorW = remaining / doorCount;
                            if (doorW > 0) {
                                drawerIndices.forEach(i => { widths[i] = dw; });
                                for (let i = 0; i < sectionCount; i++) {
                                    if (!drawerIndices.includes(i)) {
                                        widths[i] = doorW;
                                    }
                                }
                            }
                        }
                    }
                }

                // -------------------------------------------------------
                // 5-SECTION: outer + center drawer controls
                //   - still respects sink minimums but now ONLY when
                //     user is actually editing drawers.
                // -------------------------------------------------------
                if (sectionCount === 5) {
                    let outer = normalizeDrawer(outerDw);
                    let center = normalizeDrawer(centerDw);

                    // default if user hasn't touched them yet
                    if (!outer && !center) {
                        outer = baseWidthIn;
                        center = baseWidthIn;

                        const outerInput = document.getElementById("drawerWidthOuter");
                        if (outerInput && !outerInput.value) {
                            outerInput.value = Math.round(outer * 4) / 4;
                        }
                        const centerInput = document.getElementById("drawerWidthCenter");
                        if (centerInput && !centerInput.value) {
                            centerInput.value = Math.round(center * 4) / 4;
                        }
                    }

                    // if one is missing, fall back to equal
                    if (!outer) outer = baseWidthIn;
                    if (!center) center = baseWidthIn;

                    const outerDrawerIdx = drawerIndices.filter(
                        i => i === 0 || i === sectionCount - 1
                    );
                    const centerDrawerIdx = drawerIndices.filter(
                        i => !outerDrawerIdx.includes(i)
                    );

                    const nOuter = outerDrawerIdx.length;
                    const nCenter = centerDrawerIdx.length;

                    let drawerTotal = nOuter * outer + nCenter * center;
                    const drawerCount = nOuter + nCenter;
                    const doorCount = sectionCount - drawerCount;

                    // If we have sinks and at least one non-drawer section,
                    // clamp the *edited* drawer group so door/sink bays never
                    // drop below MIN_SINK_SECTION_WIDTH.
                    if (sinkCount > 0 && doorCount > 0) {
                        // doorWidth = (availableFaceWidthIn - drawerTotal) / doorCount
                        // We want: doorWidth >= MIN_SINK_SECTION_WIDTH
                        // â†’ drawerTotal <= availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH
                        const maxDrawerTotal =
                            availableFaceWidthIn - doorCount * MIN_SINK_SECTION_WIDTH;

                        if (maxDrawerTotal > 0 && drawerTotal > maxDrawerTotal) {
                            // see which field the user actually touched last
                            if (lastDrawerEdited === "outer" && nOuter > 0) {
                                // nOuter * outer + nCenter * center <= maxDrawerTotal
                                // â†’ outer <= (maxDrawerTotal - nCenter * center) / nOuter
                                const allowedForOuter = maxDrawerTotal - nCenter * center;
                                let maxOuter = allowedForOuter / nOuter;
                                if (maxOuter < MIN_DRAWER_WIDTH) maxOuter = MIN_DRAWER_WIDTH;
                                outer = maxOuter;
                            } else if (lastDrawerEdited === "center" && nCenter > 0) {
                                // nOuter * outer + nCenter * center <= maxDrawerTotal
                                // â†’ center <= (maxDrawerTotal - nOuter * outer) / nCenter
                                const allowedForCenter = maxDrawerTotal - nOuter * outer;
                                let maxCenter = allowedForCenter / nCenter;
                                if (maxCenter < MIN_DRAWER_WIDTH) maxCenter = MIN_DRAWER_WIDTH;
                                center = maxCenter;
                            } else {
                                // fallback: scale both (rare edge-case when we don't know)
                                const scaleFactor = maxDrawerTotal / drawerTotal;
                                outer *= scaleFactor;
                                center *= scaleFactor;
                            }

                            drawerTotal = nOuter * outer + nCenter * center;
                        }
                    }

                    // global drawer minimum still applies
                    if (outer < MIN_DRAWER_WIDTH) outer = MIN_DRAWER_WIDTH;
                    if (center < MIN_DRAWER_WIDTH) center = MIN_DRAWER_WIDTH;

                    // snap & sync UI fields with clamped values
                    outer = Math.round(outer * 4) / 4;
                    center = Math.round(center * 4) / 4;

                    const outerInput = document.getElementById("drawerWidthOuter");
                    if (outerInput) outerInput.value = outer;

                    const centerInput = document.getElementById("drawerWidthCenter");
                    if (centerInput) centerInput.value = center;

                    // recompute with final drawer widths
                    const finalDrawerTotal = nOuter * outer + nCenter * center;
                    const remaining = availableFaceWidthIn - finalDrawerTotal;

                    if (doorCount > 0 && remaining > 0) {
                        const doorW = remaining / doorCount;
                        if (doorW > 0) {
                            outerDrawerIdx.forEach(i => { widths[i] = outer; });
                            centerDrawerIdx.forEach(i => { widths[i] = center; });
                            for (let i = 0; i < sectionCount; i++) {
                                if (!drawerIndices.includes(i)) {
                                    widths[i] = doorW;
                                }
                            }
                        }
                    }
                }
            }

            // -------------------------------------------------------------------
            // Build final sections array with the chosen widths
            // -------------------------------------------------------------------
            const sections = [];
            let xIn = interiorStartIn;

            for (let i = 0; i < sectionCount; i++) {
                const wIn = widths[i];

                sections.push({
                    index: i,
                    xIn,
                    widthIn: wIn,
                    role: roles[i] || "door"
                });

                xIn += wIn;
                if (i < sectionCount - 1) {
                    xIn += gapWidthIn;
                }
            }

            // Apply drawer-width overrides (sink bays protected; non-sink bays adjustable)
            applyDrawerWidthOverrides(model, sections);

            // Rebuild x-positions now that widths are final
            let runX = interiorStartIn;
            for (let i = 0; i < sections.length; i++) {
                const sec = sections[i];
                sec.xIn = runX;
                runX += sec.widthIn;

                if (i < sections.length - 1) {
                    runX += gapWidthIn;  // same stile width / 0 if removeStiles
                }
            }

            return sections;

        }



        function getDefaultSectionCount(widthIn, sinkCount) {
            // clamp sinkCount to 0â€“2
            const s = Math.max(0, Math.min(2, sinkCount || 0));

            // 17â€“42"  â†’ 1 section
            if (widthIn < 42) return 1;

            // 42â€“90" â†’ 3 sections by default
            if (widthIn < 90) return 3;

            // 90â€“115" â†’ special rules:
            //  - single sink â†’ default 3 sections
            //  - 0 or 2 sinks â†’ default 5 sections
            if (widthIn <= 115) {
                if (s === 1) return 3;
                return 5;
            }

            // 115â€“130" â†’ 5 sections
            if (widthIn < 130) return 5;

            // 130"+ â†’ 7 sections
            return 7;
        }

        // âš ï¸ VISIBILITY ONLY
        // This function must NEVER write drawer input values.
        // Drawer width inputs are synced ONLY in syncDrawerInputsFromSections().
        // âš ï¸ VISIBILITY ONLY
        // This function must NEVER write drawer input values.
        // Drawer width inputs are synced ONLY in syncDrawerInputsFromSections().

        function updateDrawerWidthFieldsVisibility(model) {
            const singleWrap = document.getElementById("drawerWidthSingleField");
            const outerWrap = document.getElementById("drawerWidthOuterField");
            const centerWrap = document.getElementById("drawerWidthCenterField");
            const twoSectionWrap = document.getElementById("drawerWidthTwoSectionField");

            if (!singleWrap || !outerWrap || !centerWrap || !twoSectionWrap) return;

            const sections = model.sections || [];
            const sectionCount = sections.length;

            // default: hide everything
            singleWrap.style.display = "none";
            outerWrap.style.display = "none";
            centerWrap.style.display = "none";
            twoSectionWrap.style.display = "none";

            if (!sectionCount) return;

            // ------------------------------------------------------------
            // 1) If we have sinks: protect sink bays; adjust everything else
            // 2) If we have NO sinks: adjust ONLY bays that are drawers
            // ------------------------------------------------------------
            const sinkIdx = computeSinkSectionIndices(model, sections) || [];
            let adjustableIdx = [];

            if (sinkIdx.length) {
                const protectedSet = new Set(sinkIdx);
                adjustableIdx = sections
                    .map((_, i) => i)
                    .filter(i => !protectedSet.has(i));
            } else {
                // NO SINK fallback: adjustable bays are wherever drawer faces are drawn
                adjustableIdx = sections
                    .map((sec, i) => (sec?.role === "drawer" ? i : null))
                    .filter(i => i !== null);
            }

            // If nothing is adjustable, still allow the simple control as a fallback
            if (!adjustableIdx.length) {
                singleWrap.style.display = "";
                return;
            }

            if (sectionCount === 2) {
                twoSectionWrap.style.display = "";
                return;
            }

            if (sectionCount === 3) {
                singleWrap.style.display = "";
                return;
            }

            if (sectionCount === 5) {
                const minAdj = Math.min(...adjustableIdx);
                const maxAdj = Math.max(...adjustableIdx);

                const outerAdj = adjustableIdx.filter(i => i === minAdj || i === maxAdj);
                const centerAdj = adjustableIdx.filter(i => i !== minAdj && i !== maxAdj);

                if (outerAdj.length && centerAdj.length) {
                    outerWrap.style.display = "";
                    centerWrap.style.display = "";
                    return;
                }

                singleWrap.style.display = "";
                return;
            }

            singleWrap.style.display = "";
        }




        function syncDrawerInputsFromSections(model) {
            const sections = model.sections || [];
            const sectionCount = sections.length;
            if (!sectionCount) return;

            const singleInput = document.getElementById("drawerWidthSingle");
            const outerInput = document.getElementById("drawerWidthOuter");
            const centerInput = document.getElementById("drawerWidthCenter");
            const twoSectionInput = document.getElementById("drawerWidthTwoSection");

            if (!singleInput && !outerInput && !centerInput && !twoSectionInput) return;

            function snapQuarter(val) {
                const n = Number(val);
                if (!isFinite(n) || n <= 0) return 0;
                return Math.round(n * 4) / 4;
            }

            function readVal(inputEl) {
                if (!inputEl) return 0;
                const n = Number(inputEl.value);
                return isFinite(n) ? n : 0;
            }

            // Write helper:
            // - never overwrite while typing
            // - if override is ON, only write when value differs (clamp-to-effective)
            function safeSet(inputEl, effectiveIn, overrideIsOn) {
                if (!inputEl) return;
                if (document.activeElement === inputEl) return; // ðŸ”’ never overwrite while typing

                const v = snapQuarter(effectiveIn);
                if (v <= 0) return;

                const cur = readVal(inputEl);
                const diff = Math.abs(cur - v);

                // If override is OFF: always seed/refresh
                // If override is ON: only clamp when it drifted (mins/max hit)
                if (!overrideIsOn || diff >= 0.125) { // 1/8" threshold prevents jitter
                    inputEl.value = String(v);
                }
            }

            // --------------------------------------------
            // Effective widths come from "adjustable bays"
            // (non-sink bays). Sink bays are protected.
            // --------------------------------------------
            const sinkIdx = computeSinkSectionIndices(model, sections) || [];
            const protectedSet = new Set(sinkIdx);

            const adjustableIdx = sections
                .map((_, i) => i)
                .filter(i => !protectedSet.has(i));

            // If no sinks / no adjustable bays, keep existing behavior (do nothing)
            if (!sinkIdx.length || !adjustableIdx.length) return;

            function avgWidth(indices) {
                if (!indices.length) return 0;
                const sum = indices.reduce((a, i) => a + (sections[i]?.widthIn || 0), 0);
                return sum / indices.length;
            }

            // === 2-SECTION â†’ use adjustable bay ===
            if (sectionCount === 2 && twoSectionInput) {
                const eff = avgWidth(adjustableIdx.slice(0, 1));
                const overrideOn = !!(drawerOverrideFlags?.twoSection && initialDrawDone);
                safeSet(twoSectionInput, eff, overrideOn);
                return;
            }

            // === 3-SECTION â†’ single uses adjustable bays average ===
            if (sectionCount === 3) {
                if (!singleInput) return;
                const eff = avgWidth(adjustableIdx);
                const overrideOn = !!(drawerOverrideFlags?.single && initialDrawDone);
                safeSet(singleInput, eff, overrideOn);
                return;
            }

            // === 5-SECTION â†’ outer/center split over adjustable bays ===
            if (sectionCount === 5) {
                // Determine adjustable outer vs center by their positions among adjustable bays
                const minAdj = Math.min(...adjustableIdx);
                const maxAdj = Math.max(...adjustableIdx);

                const outerAdj = adjustableIdx.filter(i => i === minAdj || i === maxAdj);
                const centerAdj = adjustableIdx.filter(i => i !== minAdj && i !== maxAdj);

                if (outerInput) {
                    const effOuter = avgWidth(outerAdj.length ? outerAdj : adjustableIdx);
                    const overrideOn = !!(drawerOverrideFlags?.outer && initialDrawDone);
                    safeSet(outerInput, effOuter, overrideOn);
                }

                if (centerInput) {
                    const effCenter = avgWidth(centerAdj.length ? centerAdj : adjustableIdx);
                    const overrideOn = !!(drawerOverrideFlags?.center && initialDrawDone);
                    safeSet(centerInput, effCenter, overrideOn);
                }

                return;
            }

            // fallback: if a weird count slips through, keep single aligned to adjustable avg
            if (singleInput) {
                const eff = avgWidth(adjustableIdx);
                const overrideOn = !!(drawerOverrideFlags?.single && initialDrawDone);
                safeSet(singleInput, eff, overrideOn);
            }
        }



        // Which section counts are allowed at this width?
        function getAllowedSectionCounts(widthIn) {
            if (widthIn < 42) return [1];        // tiny vanities
            if (widthIn < 89) return [3];        // normal range â†’ 3 only
            if (widthIn <= 115) return [3, 5];   // wide, but still able to be 3 *or* 5
            if (widthIn < 130) return [5];       // bigger â†’ 5 only
            return [7];                          // monsters â†’ 7 sections
        }

        function getLayoutsFor(widthIn, sinkCount, sinkPosition) {
            const layouts = [];
            const s = Math.max(0, Math.min(2, sinkCount || 0)); // clamp 0â€“2
            const pos = sinkPosition || "center";
            const allowedCounts = getAllowedSectionCounts(widthIn);
            const defaultCount = getDefaultSectionCount(widthIn, s);

            function addLayout(sectionCount, id, label, roles, isDefaultForThisCount) {
                layouts.push({
                    id,
                    label,
                    roles,
                    sectionCount,
                    isDefault: isDefaultForThisCount && sectionCount === defaultCount
                });
            }

            // =========================================================
            // SPECIAL CASE: OFF-CENTER SINGLE SINK
            //
            // Only for:
            //   - exactly 1 sink
            //   - sinkPosition is left or right
            //   - width between 30" and 115"
            //
            // For these, we *replace* the normal layout catalog with:
            //   width < 58" â†’ 2-section only
            //   58â€“76"      â†’ 2- and 3-section options
            //   >76"        â†’ 3-section only
            //
            // **Key rule weâ€™re enforcing now:**
            //   Whenever 2-section off-center layouts exist,
            //   the default is ALWAYS the mixed layout:
            //     - left sink  â†’ door(s) / drawers
            //     - right sink â†’ drawers / door(s)
            // =========================================================
            const offCenterSingle =
                s === 1 &&
                pos !== "center" &&
                widthIn >= 30 &&
                widthIn <= 115;

            if (offCenterSingle) {
                // Off-center single sink:
                //  - 2 sections allowed from 30â€“76"
                //  - 3 sections allowed from 58â€“115"
                //  - 58â€“76" has BOTH 2- and 3-section options
                const allow2 = (widthIn >= 30 && widthIn <= 76);
                const allow3 = (widthIn >= 58 && widthIn <= 115);

                // We still care about default section count for 3-section choices:
                const defaultCountOff = allow3 ? 3 : 2;

                // ---------- 2-SECTION OFF-CENTER OPTIONS -------------------------
                if (allow2) {
                    // pure doors & pure drawers are NEVER default
                    addLayout(
                        2,
                        "off-four-doors",        // â†’ ['door', 'door']
                        "door(s)",
                        ["door", "door"],
                        false
                    );
                    addLayout(
                        2,
                        "off-all-drawers",       // â†’ ['drawer', 'drawer']
                        "all drawers",
                        ["drawer", "drawer"],
                        false
                    );

                    // âœ… HARD RULE: mixed pattern is ALWAYS the default
                    if (pos === "left") {
                        // sink on the left â†’ left bay is the door section
                        layouts.push({
                            id: "off-doors-drawers",
                            label: "door(s) / drawers",
                            roles: ["door", "drawer"],
                            sectionCount: 2,
                            isDefault: true
                        });
                    } else if (pos === "right") {
                        // sink on the right â†’ right bay is the door section
                        layouts.push({
                            id: "off-drawers-doors",
                            label: "drawers / door(s)",
                            roles: ["drawer", "door"],
                            sectionCount: 2,
                            isDefault: true
                        });
                    }
                }

                // ---------- 3-SECTION OFF-CENTER OPTIONS -------------------------
                if (allow3) {
                    // Common 3-sec "all drawers" option
                    addLayout(
                        3,
                        "off-all-drawers",             // â†’ ['drawer','drawer','drawer']
                        "all drawers",
                        ["drawer", "drawer", "drawer"],
                        false
                    );

                    if (pos === "left") {
                        // sink on the left â†’ left section is door bay
                        addLayout(
                            3,
                            "off-doors-drawers-drawers", // â†’ ['door','drawer','drawer']
                            "door(s) / drawers / drawers",
                            ["door", "drawer", "drawer"],
                            defaultCountOff === 3        // default when 3-section is the preferred count
                        );
                    } else if (pos === "right") {
                        // sink on the right â†’ right section is door bay
                        addLayout(
                            3,
                            "off-drawers-drawers-doors", // â†’ ['drawer','drawer','door']
                            "drawers / drawers / door(s)",
                            ["drawer", "drawer", "door"],
                            defaultCountOff === 3        // default when 3-section is the preferred count
                        );
                    }
                }

                // If we successfully built any, de-duplicate and sort, then return.
                if (layouts.length) {
                    // de-duplicate labels & keep the "isDefault" one where applicable
                    const byLabel = new Map();
                    layouts.forEach(layout => {
                        const existing = byLabel.get(layout.label);
                        if (!existing) {
                            byLabel.set(layout.label, layout);
                        } else if (!existing.isDefault && layout.isDefault) {
                            byLabel.set(layout.label, layout);
                        }
                    });

                    const uniqueLayouts = Array.from(byLabel.values());
                    uniqueLayouts.sort((a, b) => {
                        if (a.isDefault && !b.isDefault) return -1;
                        if (!a.isDefault && b.isDefault) return 1;
                        if (a.sectionCount !== b.sectionCount) return a.sectionCount - b.sectionCount;
                        return 0;
                    });

                    return uniqueLayouts;
                }
                // If somehow nothing got built, we fall through to the normal catalog.
            }

            // =========================================================
            // NORMAL CASE: CENTERED or MULTI-SINK
            // (your existing catalog)
            // =========================================================
            allowedCounts.forEach(sectionCount => {
                // 1 SECTION --------------------------------------------------------
                if (sectionCount === 1) {
                    // 0 or 1 sink â†’ same visual choices
                    if (s === 0 || s === 1) {
                        addLayout(1, "1_doors", "door(s)", ["door"], true);
                        addLayout(1, "1_all-drawers", "all drawers", ["drawer"], false);
                    } else if (s === 2) {
                        // not really a thing, but fall back to doors
                        addLayout(1, "1_doors", "door(s)", ["door"], true);
                    }
                }

                // 3 SECTIONS -------------------------------------------------------
                if (sectionCount === 3) {
                    if (s === 0) {
                        addLayout(3, "3_dr-d-dr",
                            "drawers / door(s) / drawers",
                            ["drawer", "door", "drawer"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_d-dr-d",
                            "door(s) / drawers / door(s)",
                            ["door", "drawer", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(3, "3_dr-d-dr",
                            "drawers / door(s) / drawers",
                            ["drawer", "door", "drawer"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(3, "3_d-dr-d",
                            "door(s) / drawers / door(s)",
                            ["door", "drawer", "door"],
                            true
                        );
                        addLayout(3, "3_doors",
                            "door(s)",
                            ["door", "door", "door"],
                            false
                        );
                        addLayout(3, "3_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }

                // 5 SECTIONS -------------------------------------------------------
                if (sectionCount === 5) {
                    if (s === 0) {
                        addLayout(5, "5_dr-d-dr-d-dr",
                            "drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                        addLayout(5, "5_d-dr-d-dr-d",
                            "door(s) / drawers / door(s) / drawers / door(s)",
                            ["door", "drawer", "door", "drawer", "door"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(5, "5_dr-dr-d-dr-dr",
                            "drawers / drawers / door(s) / drawers / drawers",
                            ["drawer", "drawer", "door", "drawer", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(5, "5_dr-d-dr-d-dr",
                            "drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(5, "5_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(5, "5_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }

                // 7 SECTIONS -------------------------------------------------------
                if (sectionCount === 7) {
                    if (s === 0) {
                        addLayout(7, "7_mixed",
                            "drawers / door(s) / drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 1) {
                        addLayout(7, "7_center-door",
                            "drawers / door(s) / drawers / door(s) / drawers / door(s) / drawers",
                            ["drawer", "door", "drawer", "door", "drawer", "door", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    } else if (s === 2) {
                        addLayout(7, "7_double-door",
                            "drawers / drawers / door(s) / drawers / door(s) / drawers / drawers",
                            ["drawer", "drawer", "door", "drawer", "door", "drawer", "drawer"],
                            true
                        );
                        addLayout(7, "7_doors",
                            "door(s)",
                            ["door", "door", "door", "door", "door", "door", "door"],
                            false
                        );
                        addLayout(7, "7_all-drawers",
                            "all drawers",
                            ["drawer", "drawer", "drawer", "drawer", "drawer", "drawer", "drawer"],
                            false
                        );
                    }
                }
            });

            // If nothing was built (very edge-case), fall back to a simple all-doors layout
            if (!layouts.length) {
                const fallbackCount = getDefaultSectionCount(widthIn, s);
                const roles = new Array(fallbackCount).fill("door");
                layouts.push({
                    id: "fallback_doors",
                    label: "door(s)",
                    roles,
                    sectionCount: fallbackCount,
                    isDefault: true
                });
            }

            // ðŸ”¹ Remove duplicate labels (e.g. multiple "door(s)" or "all drawers")
            // If there are duplicates, keep the one marked as default; otherwise keep the first.
            const byLabel = new Map();
            layouts.forEach(layout => {
                const existing = byLabel.get(layout.label);
                if (!existing) {
                    byLabel.set(layout.label, layout);
                } else if (!existing.isDefault && layout.isDefault) {
                    byLabel.set(layout.label, layout);
                }
            });

            const uniqueLayouts = Array.from(byLabel.values());

            // Put the "default" layout first, then sort by section count for readability
            uniqueLayouts.sort((a, b) => {
                if (a.isDefault && !b.isDefault) return -1;
                if (!a.isDefault && b.isDefault) return 1;
                if (a.sectionCount !== b.sectionCount) return a.sectionCount - b.sectionCount;
                return 0;
            });

            return uniqueLayouts;
        }



        function updateLayoutOptions() {
            const layoutSel = document.getElementById("layoutPreset");
            if (!layoutSel) return;

            const widthIn = Number(document.getElementById("width")?.value) || 0;
            const sinkCount = Number(document.getElementById("sinkCount")?.value) || 0;
            const sinkPosition = document.getElementById("sinkPosition")?.value || "center";

            // no width yet â†’ show a single placeholder option
            if (!widthIn) {
                layoutSel.innerHTML = "";
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "layout";
                layoutSel.appendChild(opt);
                return;
            }

            const layouts = getLayoutsFor(widthIn, sinkCount, sinkPosition);
            const current = layoutSel.value;

            layoutSel.innerHTML = "";

            layouts.forEach(o => {
                const opt = document.createElement("option");
                opt.value = o.id;
                opt.textContent = o.label;
                layoutSel.appendChild(opt);
            });

            // keep current selection if it is still valid
            const stillValid = layouts.some(o => o.id === current);
            if (stillValid) {
                layoutSel.value = current;
            } else if (layouts.length) {
                layoutSel.value = layouts[0].id;
            }
        }

        function updateSinkCountOptions() {
            const sinkSel = document.getElementById("sinkCount");
            const widthInput = document.getElementById("width");
            if (!sinkSel || !widthInput) return;

            const rawWidth = Number(widthInput.value) || 0;

            // find the "2" option inside sinkCount
            const optDouble = Array.from(sinkSel.options).find(o => o.value === "2");
            if (!optDouble) return;

            const canHaveDouble = rawWidth >= MIN_DOUBLE_SINK_WIDTH_IN;

            if (canHaveDouble) {
                optDouble.disabled = false;
            } else {
                // gray it out
                optDouble.disabled = true;

                // if user was on "2", bump them down to something valid
                if (sinkSel.value === "2") {
                    // if vanity is at least "normal single-sink territory", default to 1
                    if (rawWidth >= 24) {
                        sinkSel.value = "1";
                    } else {
                        sinkSel.value = "0";
                    }
                }
            }
        }


        // now we start a new function (works correctly)
        function clearSvg(svg) {
            while (svg.firstChild) svg.removeChild(svg.firstChild);
        }

        function drawVanityOutline(svg, model) {
            const { widthIn, heightIn, scale, floating, toeKickHeightIn } = model;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const leftX = ox;
            const rightX = ox + cabW;

            const topY = oy;

            // bottom should be ABOVE the toe kick, not at full height
            const toeKickPx = floating ? 0 : (toeKickHeightIn * px);
            const caseBottomY = oy + cabH - toeKickPx;

            function line(x1, y1, x2, y2) {
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                l.setAttribute("x1", x1);
                l.setAttribute("y1", y1);
                l.setAttribute("x2", x2);
                l.setAttribute("y2", y2);
                l.setAttribute("stroke", "#000");
                l.setAttribute("stroke-width", "0.3");
                svg.appendChild(l);
            }

            // Top outline
            line(leftX, topY, rightX, topY);

            // Left side
            line(leftX, topY, leftX, caseBottomY);

            // Right side
            line(rightX, topY, rightX, caseBottomY);
        }


        function drawLegs(svg, model) {
            const { heightIn, scale, frame } = model;
            if (!frame || !frame.legs || frame.legs.length === 0) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const legWpx = frame.legWidthIn * px;
            const legBottomY = model.cabinetBottomY ?? (oy + heightIn * px);
            const legHpx = Math.max(legBottomY - oy, 0);


            frame.legs.forEach(leg => {
                const x = ox + leg.xIn * px;
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", oy);
                rect.setAttribute("width", legWpx);
                rect.setAttribute("height", legHpx);
                rect.setAttribute("fill", "none");
                rect.setAttribute("stroke", "#000");
                rect.setAttribute("stroke-width", STROKE);
                svg.appendChild(rect);
            });
        }

        function drawTopRail(svg, model) {
            const { widthIn, scale, frame, removeTopRail } = model;
            if (!frame || removeTopRail) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabWpx = widthIn * px;
            const legWpx = frame.legWidthIn * px;

            const railHpx = frame.topRailHeightIn * px;

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", ox + legWpx);
            rect.setAttribute("y", oy);
            rect.setAttribute("width", cabWpx - legWpx * 2);
            rect.setAttribute("height", railHpx);
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", STRUCTURE_COLOR);
            rect.setAttribute("stroke-width", STROKE);
            svg.appendChild(rect);
        }

        function drawBottomRail(svg, model) {
            const { widthIn, scale, frame, removeBottomRail } = model;
            if (!frame || removeBottomRail) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const cabWpx = widthIn * px;
            const legWpx = frame.legWidthIn * px;

            // Get case opening bounds â€” authoritative
            const { openBottomY } = computeCaseOpeningVertical(model);

            const railHpx = frame.bottomRailHeightIn * px;

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", ox + legWpx);
            rect.setAttribute("y", openBottomY);
            rect.setAttribute("width", cabWpx - legWpx * 2);
            rect.setAttribute("height", railHpx);
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", STRUCTURE_COLOR);
            rect.setAttribute("stroke-width", STROKE);
            svg.appendChild(rect);
        }

        // âš ï¸ INTERNAL GEOMETRY HELPER
        // Do NOT call this directly from drawing functions.
        // Always access via computeGeometry(model).

        function computeCaseOpeningVertical(model) {
            const {
                heightIn,
                toeKickHeightIn,
                frame,
                floating,
                scale,
                removeTopRail,
                removeBottomRail,
                shelfBelow,
                shelfSpaceIn,
                shelfThicknessIn
            } = model;

            const px = scale.inchToPx;
            const oy = scale.originY;
            const cabHpx = heightIn * px;

            // Absolute cabinet bottom
            const cabBottomY = oy + cabHpx;

            // -------------------------------------------------------------
            // TOE KICK
            // -------------------------------------------------------------
            const toeKickPx = floating ? 0 : ((toeKickHeightIn || 4) * px);

            // Start with usable interior bottom
            let caseBottomY = cabBottomY - toeKickPx;

            // -------------------------------------------------------------
            // SHELF (single source of truth)
            // -------------------------------------------------------------
            const shelfGapPx = (shelfSpaceIn || DEFAULT_SHELF_SPACE_IN) * px;
            const shelfThPx = shelfBelow
                ? (shelfThicknessIn || 0.75) * px
                : null;

            let shelfBottomY = null;
            let shelfTopY = null;

            if (shelfBelow) {
                shelfBottomY = caseBottomY;
                shelfTopY = shelfBottomY - shelfThPx;

                // Remove shelf + gap from usable opening
                caseBottomY -= (shelfThPx + shelfGapPx);
            }

            // -------------------------------------------------------------
            // RAILS
            // -------------------------------------------------------------
            const topRailHpx = (!removeTopRail && frame?.topRailHeightIn)
                ? frame.topRailHeightIn * px
                : 0;

            const bottomRailHpx = (!removeBottomRail && frame?.bottomRailHeightIn)
                ? frame.bottomRailHeightIn * px
                : 0;

            // -------------------------------------------------------------
            // OPENING SPAN
            // -------------------------------------------------------------
            const openTopY = oy + topRailHpx;
            const openBottomY = removeBottomRail
                ? caseBottomY
                : caseBottomY - bottomRailHpx;

            return {
                // authoritative opening
                openTopY,
                openBottomY,

                // cabinet structure
                cabBottomY,
                caseBottomY,
                toeKickPx,

                // rails
                topRailHpx,
                bottomRailHpx,

                // shelf
                shelfTopY,
                shelfBottomY,
                shelfThicknessPx: shelfThPx
            };
        }


        // âœ… SINGLE SOURCE OF TRUTH FOR ALL CABINET GEOMETRY
        // Drawing code must ONLY read geometry from here.

        function computeGeometry(model) {
            const vertical = computeCaseOpeningVertical(model);

            return {
                vertical: {
                    ...vertical,
                    shelfTopY: vertical.shelfTopY ?? null,
                    shelfBottomY: vertical.shelfBottomY ?? null,
                    shelfThicknessPx: vertical.shelfThicknessPx ?? null
                }
            };
        }



        function drawSectionStiles(svg, model) {
            const {
                sections,
                frame,
                scale,
                removeStiles
            } = model;

            // nothing to draw, or user turned them off
            if (!sections || sections.length < 2 || !frame || removeStiles) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const stileWidthIn = frame.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn;
            const stileWpx = stileWidthIn * px;

            const geom = computeGeometry(model);
            const { openTopY, openBottomY } = geom.vertical;

            const stileHeight = Math.max(openBottomY - openTopY, 0);
            if (stileHeight <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            // one stile per internal section gap:
            // section i runs from sec.xIn .. sec.xIn + sec.widthIn
            // the gap (for the stile) starts at that right edge and is exactly stileWidthIn wide.
            for (let i = 0; i < sections.length - 1; i++) {
                const sec = sections[i];

                // start of the gap between this section and the next
                const gapStartIn = sec.xIn + sec.widthIn;
                const rectX = ox + gapStartIn * px;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", rectX);
                r.setAttribute("y", openTopY);
                r.setAttribute("width", stileWpx);
                r.setAttribute("height", stileHeight);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", STRUCTURE_COLOR);
                r.setAttribute("stroke-width", STROKE);
                svg.appendChild(r);
            }
        }

        function ensureSectionOverride(model, idx) {
            if (!model.sectionOverrides) {
                model.sectionOverrides = {};
            }

            if (!model.sectionOverrides[idx]) {
                model.sectionOverrides[idx] = {
                    drawerCount: null,
                    doorLeaves: null,
                    drawerDimsHidden: false,   // ðŸ‘ˆ default: show dims when override exists
                    interiorShelf: false       // ðŸ‘ˆ default: OFF
                };
            }

        }


        // =======================================================
        // GLOBAL helper used by ALL patch functions
        // =======================================================
        function patchRectCentered(svg, cx, cy, w, h) {

            // Controls the gap between the patch and the rail/stile edge.
            // Increase for shorter patches, decrease for longer.
            const INSET = 0.30;

            const isVertical = h >= w;

            let finalW = w;
            let finalH = h;

            if (isVertical) {
                finalH = Math.max(1, h - INSET * 2);
            } else {
                finalW = Math.max(1, w - INSET * 2);
            }

            const x = cx - finalW / 2;
            const y = cy - finalH / 2;

            const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            r.setAttribute("x", x);
            r.setAttribute("y", y);
            r.setAttribute("width", finalW);
            r.setAttribute("height", finalH);
            r.setAttribute("fill", "#fff");
            r.setAttribute("stroke", "none");

            svg.appendChild(r);
        }

        function drawFrameJointPatches(svg, model) {
            if (!svg || !model || !model.scale || !model.frame) return;

            const {
                widthIn,
                frame,
                scale,
                sections = [],
                removeStiles,
                removeTopRail,
                removeBottomRail
            } = model;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabWpx = widthIn * px;
            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const stileWpx = (frame.stileWidthIn ?? FRAME_DEFAULTS.stileWidthIn) * px;

            const stroke = (typeof STROKE === "number" ? STROKE : 0.7);
            const CROSS_THICK = stroke * 2; // the small dimension of patches

            const hasTopRail =
                !removeTopRail &&
                frame.topRailHeightIn &&
                frame.topRailHeightIn > 0;

            const hasBottomRail =
                !removeBottomRail &&
                frame.bottomRailHeightIn &&
                frame.bottomRailHeightIn > 0;

            const geom = computeGeometry(model);
            const { openTopY, openBottomY } = geom.vertical;


            // ======================================================
            // STILE JOINT PATCHES
            // ======================================================
            if (!removeStiles && sections.length > 1 && stileWpx > 0) {
                const pillH = CROSS_THICK;
                const pillW = stileWpx;

                for (let i = 0; i < sections.length - 1; i++) {
                    const sec = sections[i];
                    const gapStartIn = sec.xIn + sec.widthIn;
                    const stileX = ox + gapStartIn * px;
                    const cx = stileX + stileWpx / 2;

                    if (hasTopRail) {
                        patchRectCentered(svg, cx, openTopY, pillW, pillH);
                    }
                    if (hasBottomRail) {
                        patchRectCentered(svg, cx, openBottomY, pillW, pillH);
                    }
                }
            }

            // ======================================================
            // TOP RAIL PATCHES (vertical)
            // ======================================================
            if (hasTopRail) {
                const railH = frame.topRailHeightIn * px;
                const cxL = ox + legWpx;
                const cxR = ox + cabWpx - legWpx;
                const cy = oy + railH / 2;

                patchRectCentered(svg, cxL, cy, CROSS_THICK, railH);
                patchRectCentered(svg, cxR, cy, CROSS_THICK, railH);
            }

            // ======================================================
            // BOTTOM RAIL PATCHES (vertical)
            // ======================================================
            if (hasBottomRail) {
                const railH = frame.bottomRailHeightIn * px;
                const cy = openBottomY + railH / 2;
                const cxL = ox + legWpx;
                const cxR = ox + cabWpx - legWpx;

                patchRectCentered(svg, cxL, cy, CROSS_THICK, railH);
                patchRectCentered(svg, cxR, cy, CROSS_THICK, railH);
            }

            // ======================================================
            // DRAWER RAIL PATCHES (vertical)
            // ======================================================
            const hasDrawer = sections.some(s => s.role === "drawer");
            if (!hasDrawer) return;

            const openingH = openBottomY - openTopY;
            if (openingH <= 0) return;

            sections.forEach((sec, sectionIndex) => {
                if (sec.role !== "drawer") return;

                const faceLeft = ox + sec.xIn * px;
                const faceRight = faceLeft + sec.widthIn * px;

                // ðŸ”’ MUST match the exact layout used to DRAW the drawers
                const layout = getFinalDrawerLayoutForSection(
                    model,
                    sectionIndex,
                    openingH
                );

                if (!layout || layout.mode === "none" || layout.railHeightPx <= 0) return;

                const railH = layout.railHeightPx;
                let curY = openTopY;

                for (let i = 0; i < layout.drawerCount; i++) {
                    curY += layout.heightsPx[i];

                    const place =
                        (layout.mode === "all" && i < layout.drawerCount - 1) ||
                        (layout.mode === "top" && i === 0 && layout.drawerCount > 1);

                    if (place) {
                        const cy = curY + railH / 2;
                        patchRectCentered(svg, faceLeft, cy, CROSS_THICK, railH);
                        patchRectCentered(svg, faceRight, cy, CROSS_THICK, railH);

                        curY += railH; // step past the rail
                    }
                }
            });
        }

        function drawShelf(svg, model) {
            const geom = computeGeometry(model).vertical;
            if (!model.shelfBelow) return;
            if (geom.shelfTopY == null || geom.shelfThicknessPx == null) return;

            const { scale, frame, widthIn } = model;
            const px = scale.inchToPx;
            const ox = scale.originX;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const cabWpx = widthIn * px;

            const shelfRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            shelfRect.setAttribute("x", ox + legWpx);
            shelfRect.setAttribute("y", geom.shelfTopY);
            shelfRect.setAttribute("width", cabWpx - legWpx * 2);
            shelfRect.setAttribute("height", geom.shelfThicknessPx);
            shelfRect.setAttribute("fill", "none");
            shelfRect.setAttribute("stroke", STRUCTURE_COLOR);
            shelfRect.setAttribute("stroke-width", STROKE);

            svg.appendChild(shelfRect);
        }



        function drawShelfPatches(svg, model) {
            const geom = computeGeometry(model).vertical;


            if (!model.shelfBelow) return;
            if (geom.shelfTopY == null || geom.shelfThicknessPx == null) return;

            const shelfH = geom.shelfThicknessPx;


            const { scale, frame, widthIn } = model;
            const px = scale.inchToPx;
            const ox = scale.originX;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;
            const cabWpx = widthIn * px;

            const stroke = (typeof STROKE === "number" ? STROKE : 0.7);
            const CROSS_THICK = stroke * 2.0;


            const cxL = ox + legWpx;
            const cxR = ox + cabWpx - legWpx;
            const cy = geom.shelfTopY + shelfH / 2;


            patchRectCentered(svg, cxL, cy, CROSS_THICK, shelfH);
            patchRectCentered(svg, cxR, cy, CROSS_THICK, shelfH);
        }


        // Compute per-row drawer heights (in pixels) for a 3-drawer stack
        // based on the top-drawer preset ("equal" or numeric inches).
        function computeDrawerRowHeightsPx(openingHeightPx, px, topDrawerOption) {
            const drawerCount = 3;

            // fallback: equal stack
            if (!topDrawerOption || topDrawerOption === "equal") {
                const h = openingHeightPx / drawerCount;
                return [h, h, h];
            }

            const asNumber = parseFloat(topDrawerOption);
            if (!isFinite(asNumber) || asNumber <= 0) {
                const h = openingHeightPx / drawerCount;
                return [h, h, h];
            }

            let topPx = asNumber * px;

            // keep lower drawers from collapsing
            const MIN_ROW_IN = 2.0;                // 2" minimum per lower drawer
            const minRowPx = MIN_ROW_IN * px;

            if (topPx > openingHeightPx - 2 * minRowPx) {
                topPx = openingHeightPx - 2 * minRowPx;
            }

            const remaining = openingHeightPx - topPx;
            const midPx = remaining / 2;
            const botPx = remaining / 2;

            return [topPx, midPx, botPx];
        }

        // Compute drawer row heights AND account for horizontal rails between drawers
        function computeDrawerLayout(
            openingHeightPx,
            px,
            topDrawerOption,
            railsMode,
            railHeightIn,
            model            // ðŸ‘ˆ ADD MODEL
        ) {
            // -----------------------------------------
            // 1) Decide BASE drawer count (intent)
            // -----------------------------------------
            const shelfBelow = !!model?.shelfBelow;

            let drawerCount = shelfBelow ? 2 : 3;

            // -----------------------------------------
            // 2) Compute raw drawer heights
            // -----------------------------------------
            let heights;

            if (drawerCount === 3) {
                heights = computeDrawerRowHeightsPx(openingHeightPx, px, topDrawerOption);
            } else {
                const equalHpx = openingHeightPx / 2;
                heights = [equalHpx, equalHpx];
            }

            // -----------------------------------------
            // 3) Enforce minimum drawer face height
            // -----------------------------------------
            const MIN_FACE_IN = 5;
            const minRowIn = Math.min(...heights.map(hpx => hpx / px));

            if (!isFinite(minRowIn) || minRowIn < MIN_FACE_IN) {
                drawerCount = 2;
                const equalHpx = openingHeightPx / 2;
                heights = [equalHpx, equalHpx];
            }

            // -----------------------------------------
            // 4) Rails setup
            // -----------------------------------------
            let mode = railsMode || "none";
            let railIn = railHeightIn;
            if (!isFinite(railIn) || railIn <= 0) railIn = DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            const railPx = railIn * px;

            let railsCount = 0;
            if (mode === "top") {
                railsCount = drawerCount > 1 ? 1 : 0;
            } else if (mode === "all") {
                railsCount = Math.max(drawerCount - 1, 0);
            }

            const totalRailPx = railPx * railsCount;

            // -----------------------------------------
            // 5) Bail out if rails donâ€™t fit
            // -----------------------------------------
            if (
                mode === "none" ||
                totalRailPx <= 0 ||
                totalRailPx >= openingHeightPx * 0.9
            ) {
                return {
                    drawerCount,
                    heightsPx: heights,
                    railCount: 0,
                    railHeightPx: 0,
                    mode: "none"
                };
            }

            // -----------------------------------------
            // 6) Shrink drawer faces to make room for rails
            // -----------------------------------------
            const scaleFactor = (openingHeightPx - totalRailPx) / openingHeightPx;
            const scaledHeights = heights.map(h => h * scaleFactor);

            return {
                drawerCount,
                heightsPx: scaledHeights,
                railCount: railsCount,
                railHeightPx: railPx,
                mode
            };
        }

        function getDrawerCountForSection(model, sectionIndex, defaultCount) {
            const o = model.sectionOverrides?.[sectionIndex];
            if (!o || typeof o.drawerCount !== "number") {
                return defaultCount;
            }
            return Math.max(1, Math.round(o.drawerCount));
        }

        function getDoorLeafRulesForSection(sec) {
            const openingIn = sec.widthIn;

            // hard rules
            let minLeaves = 1;
            let maxLeaves = 1;

            if (openingIn >= 20 && openingIn <= 26) {
                minLeaves = 1;
                maxLeaves = 2;
            } else if (openingIn > 26) {
                minLeaves = 2;
                maxLeaves = 2;
            }

            return { minLeaves, maxLeaves };
        }


        function drawSectionFronts(svg, model) {
            const { sections, scale } = model;
            if (!sections || sections.length === 0) return;

            const doorStyle = model.doorStyle || "shaker";
            const drawerStyle = model.drawerStyle || "slab";
            const drawerRailsMode = model.drawerRailsMode || "none";
            const drawerRailHeightIn = model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const topDrawerOption = model.topDrawerHeightPreset || "equal";

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const openingHeight = Math.max(openBottomY - openTopY, 0);
            if (openingHeight <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            // =========================
            // FACE RECT HELPER
            // =========================
            function drawFaceRect(x, y, w, h) {
                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", x);
                r.setAttribute("y", y);
                r.setAttribute("width", w);
                r.setAttribute("height", h);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", STRUCTURE_COLOR);
                r.setAttribute("stroke-width", STROKE);
                svg.appendChild(r);
                return r;
            }

            // =========================
            // SHAKER PANELS
            // =========================
            function addShakerPanels(x, y, w, h, railIn, kind) {
                const railPx = railIn * px;
                const inner1X = x + railPx;
                const inner1Y = y + railPx;
                const inner1W = w - 2 * railPx;
                const inner1H = h - 2 * railPx;
                if (inner1W <= 0 || inner1H <= 0) return;

                drawFaceRect(inner1X, inner1Y, inner1W, inner1H);

                if (kind === "double") {
                    const gapPx = 0.375 * px;
                    drawFaceRect(
                        inner1X + gapPx,
                        inner1Y + gapPx,
                        inner1W - 2 * gapPx,
                        inner1H - 2 * gapPx
                    );
                }
            }

            function resolveDrawerStyleForRow(baseStyle, rowIndex) {
                if (baseStyle === "slab-shaker") return rowIndex === 0 ? "slab" : "shaker";
                if (baseStyle === "slab-double-shaker") return rowIndex === 0 ? "slab" : "double-shaker";
                return baseStyle;
            }

            function computeEffectiveDrawerRails(style, faceHeightPx, px) {
                if (style === "slab") return { kind: "slab", railIn: 0 };

                const faceHeightIn = faceHeightPx / px;
                const minRailIn = 1.5;
                const minPanelIn = 2.0;

                if (faceHeightIn < 2 * minRailIn + minPanelIn) {
                    return { kind: "slab", railIn: 0 };
                }

                const maxRail = (faceHeightIn - minPanelIn) / 2;
                const railIn = Math.max(minRailIn, Math.min(2.0, maxRail));
                return { kind: style === "double-shaker" ? "double" : "single", railIn };
            }

            function drawDrawerFaceDimsForSection(
                svg,
                model,
                sectionIndex,
                x,
                topY,
                widthPx,
                openingHeightPx,
                layout
            ) {

                // ---------------------------------------------
                // GLOBAL REDUNDANCY CHECK â€” override dims only
                // ---------------------------------------------
                const sections = model.sections || [];
                const drawerSections = sections
                    .map((sec, idx) => ({ sec, idx }))
                    .filter(o => o.sec.role === "drawer");

                // if only one drawer section, override dims are meaningless
                if (drawerSections.length <= 1) return;

                // compute effective drawer counts for all drawer sections
                const fullOpeningHeightPx =
                    computeCaseOpeningVertical(model).openBottomY -
                    computeCaseOpeningVertical(model).openTopY;

                const counts = drawerSections.map(({ idx }) => {
                    const baseLayout = computeDrawerLayout(
                        fullOpeningHeightPx,
                        model.scale.inchToPx,
                        model.topDrawerHeightPreset || "equal",
                        model.drawerRailsMode || "none",
                        model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                        model
                    );

                    return getDrawerCountForSection(
                        model,
                        idx,
                        baseLayout.drawerCount
                    );
                });

                // if all drawer counts are equal, override dims add no info
                const allEqual = counts.every(c => c === counts[0]);
                if (allEqual) return;

                const overrides = model?.sectionOverrides || (typeof sectionOverrides !== "undefined" ? sectionOverrides : {});
                const o = overrides?.[sectionIndex];

                const format = model._formatInchesFraction || formatInchesFraction;

                // must have an override
                if (!o || typeof o.drawerCount !== "number") return;

                // --------------------------------------------------
                // DETERMINE TRUE DEFAULT DRAWER COUNT
                // --------------------------------------------------
                const baseLayout = computeDrawerLayout(
                    openingHeightPx,
                    model.scale.inchToPx,
                    model.topDrawerHeightPreset || "equal",
                    model.drawerRailsMode || "none",
                    model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                    model
                );

                const defaultCount = baseLayout.drawerCount;

                // ðŸ”‘ if override matches default â†’ DO NOT show override dims
                if (o.drawerCount === defaultCount) return;

                // user explicitly hid them
                if (o.drawerDimsHidden) return;

                const ns = "http://www.w3.org/2000/svg";
                const px = model.scale.inchToPx;

                // visual style â€” subtle
                const DIM_COLOR = "#94a3b8"; // slate-400
                const FONT_SIZE = 8;

                // centered within THIS SECTION
                const dimX = x + widthPx / 2;

                let curY = topY;

                layout.heightsPx.forEach((hPx, i) => {
                    const y1 = curY;
                    const y2 = curY + hPx;

                    const midY = y1 + hPx / 2;

                    const label = document.createElementNS(ns, "text");
                    label.setAttribute("x", dimX);
                    label.setAttribute("y", midY);
                    label.setAttribute("font-size", FONT_SIZE);
                    label.setAttribute("text-anchor", "middle");
                    label.setAttribute("dominant-baseline", "middle");
                    label.setAttribute("fill", DIM_COLOR);
                    label.setAttribute("fill-opacity", "0.6");
                    label.textContent = `${format(hPx / px)}"`;
                    svg.appendChild(label);

                    curY += hPx;

                    // skip rails visually
                    if (layout.railHeightPx > 0) {
                        if (
                            (layout.mode === "all" && i < layout.drawerCount - 1) ||
                            (layout.mode === "top" && i === 0)
                        ) {
                            curY += layout.railHeightPx;
                        }
                    }
                });
            }


            function drawDrawerStack(x, y, w, h, baseDrawerStyle, sectionIndex) {

                // ðŸ”‘ SINGLE SOURCE OF TRUTH
                const layout = getFinalDrawerLayoutForSection(
                    model,
                    sectionIndex,
                    h
                );

                let curY = y;

                drawDrawerFaceDimsForSection(
                    svg,
                    model,
                    sectionIndex,
                    x,
                    y,
                    w,
                    h,
                    layout
                );

                layout.heightsPx.forEach((drawerH, i) => {
                    const rowStyle = resolveDrawerStyleForRow(baseDrawerStyle, i);
                    drawFaceRect(x, curY, w, drawerH);

                    if (rowStyle !== "slab") {
                        const eff = computeEffectiveDrawerRails(rowStyle, drawerH, model.scale.inchToPx);
                        if (eff.railIn > 0) {
                            addShakerPanels(x, curY, w, drawerH, eff.railIn, eff.kind);
                        }
                    }

                    curY += drawerH;

                    // ðŸ”’ rails between drawers ONLY
                    if (
                        layout.railHeightPx > 0 &&
                        (
                            (layout.mode === "all" && i < layout.drawerCount - 1) ||
                            (layout.mode === "top" && i === 0 && layout.drawerCount > 1)
                        )
                    ) {
                        drawFaceRect(x, curY, w, layout.railHeightPx);
                        curY += layout.railHeightPx;
                    }
                });
            }



            // =====================================================
            // MAIN LOOP
            // =====================================================
            sections.forEach((sec, idx) => {
                const isSelected = idx === selectedSectionIndex;

                const faceX = ox + sec.xIn * px;
                const faceW = sec.widthIn * px;
                const faceTop = openTopY;
                const faceH = openingHeight;

                // ------------------------
                // DRAW CONTENT
                // ------------------------
                if (sec.role === "drawer") {
                    drawDrawerStack(faceX, faceTop, faceW, faceH, drawerStyle, idx);
                } else {
                    drawFaceRect(faceX, faceTop, faceW, faceH);
                    const o = sectionOverrides?.[idx];

                    const openingIn = sec.widthIn;

                    // ----------------------------------
                    // INTERIOR SHELF (VISUAL ONLY)
                    // ----------------------------------
                    if (o?.interiorShelf === true) {

                        const SHELF_GAP_IN = 0.75; // 3/4"
                        const gapPx = SHELF_GAP_IN * px;

                        const midY = faceTop + faceH / 2;

                        const y1 = midY - gapPx / 2;
                        const y2 = midY + gapPx / 2;

                        [y1, y2].forEach(y => {
                            const l = document.createElementNS(ns, "line");
                            l.setAttribute("x1", faceX);
                            l.setAttribute("x2", faceX + faceW);

                            l.setAttribute("y1", y);
                            l.setAttribute("y2", y);

                            // match dimension styling
                            l.setAttribute("stroke", DIM_COLOR);
                            l.setAttribute("stroke-width", 0.3);

                            l.setAttribute("stroke-dasharray", "6 3");


                            svg.appendChild(l);
                        });
                    }



                    // ----------------------------------
                    // DOOR LEAF RESOLUTION + CLAMPING
                    // ----------------------------------

                    // geometry allowance
                    const canHaveOne = openingIn <= 26;
                    const canHaveTwo = openingIn >= 20;

                    // default from geometry
                    let doorLeaves = canHaveTwo ? 2 : 1;

                    // user override (intent)
                    if (o && typeof o.doorLeaves === "number") {
                        doorLeaves = o.doorLeaves;
                    }

                    // clamp to geometry (DO NOT mutate override)
                    if (doorLeaves === 2 && !canHaveTwo) {
                        doorLeaves = 1;
                    }
                    if (doorLeaves === 1 && !canHaveOne) {
                        doorLeaves = 2;
                    }

                    const useDouble = doorLeaves === 2;



                    if (useDouble) {
                        const cx = faceX + faceW / 2;
                        const split = document.createElementNS(ns, "line");
                        split.setAttribute("x1", cx);
                        split.setAttribute("y1", faceTop);
                        split.setAttribute("x2", cx);
                        split.setAttribute("y2", faceTop + faceH);
                        split.setAttribute("stroke", STRUCTURE_COLOR);
                        split.setAttribute("stroke-width", STROKE);
                        svg.appendChild(split);
                    }

                    if (doorStyle !== "slab") {
                        const kind = doorStyle === "double-shaker" ? "double" : "single";
                        const railIn = 2.0;

                        if (useDouble) {
                            const w2 = faceW / 2;
                            addShakerPanels(faceX, faceTop, w2, faceH, railIn, kind);
                            addShakerPanels(faceX + w2, faceTop, w2, faceH, railIn, kind);
                        } else {
                            addShakerPanels(faceX, faceTop, faceW, faceH, railIn, kind);
                        }
                    }
                }

                // ------------------------
                // SELECTION OVERLAY (doors + drawers)
                // ------------------------
                if (isSelected) {
                    const sel = document.createElementNS(ns, "rect");
                    sel.setAttribute("x", faceX);
                    sel.setAttribute("y", faceTop);
                    sel.setAttribute("width", faceW);
                    sel.setAttribute("height", faceH);
                    sel.setAttribute("fill", "none");
                    sel.setAttribute("stroke", "#3b82f6");
                    sel.setAttribute("stroke-width", 1.5);
                    sel.setAttribute("pointer-events", "none");
                    sel.classList.add("section-selected");
                    svg.appendChild(sel);
                }

            });
        }


        function drawSectionHitTargets(svg, model) {
            const { sections, scale } = model;
            if (!sections || !sections.length) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const height = Math.max(openBottomY - openTopY, 0);
            if (height <= 0) return;

            const ns = "http://www.w3.org/2000/svg";

            sections.forEach((sec, index) => {
                const x = ox + sec.xIn * px;
                const w = sec.widthIn * px;

                if (w <= 0) return;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", x);
                r.setAttribute("y", openTopY);
                r.setAttribute("width", w);
                r.setAttribute("height", height);

                // invisible but interactive
                r.setAttribute("fill", "transparent");
                r.setAttribute("pointer-events", "all");

                let hoverOverlay = null;

                r.addEventListener("mouseenter", () => {
                    if (selectedSectionIndex !== null) return;

                    const overlay = document.createElementNS(ns, "rect");
                    overlay.setAttribute("x", x);
                    overlay.setAttribute("y", openTopY);
                    overlay.setAttribute("width", w);
                    overlay.setAttribute("height", height);
                    overlay.setAttribute("fill", "#3b82f6");
                    overlay.setAttribute("fill-opacity", "0.10");
                    overlay.setAttribute("pointer-events", "none");

                    svg.appendChild(overlay);
                    hoverOverlay = overlay;
                });

                r.addEventListener("mouseleave", () => {
                    if (hoverOverlay) {
                        hoverOverlay.remove();
                        hoverOverlay = null;
                    }
                });


                r.addEventListener("click", (e) => {
                    e.stopPropagation();

                    // no selection â†’ select
                    if (selectedSectionIndex === null) {
                        selectedSectionIndex = index;
                        updateDrawing();
                        return;
                    }

                    // clicking same section â†’ do nothing
                    if (selectedSectionIndex === index) return;

                    // clicking different section â†’ clear selection
                    selectedSectionIndex = null;
                    updateDrawing();
                });



                svg.appendChild(r);
            });
        }

        function drawSectionControlsOverlay(svg, model) {

            const { sections, scale } = model;
            if (selectedSectionIndex == null) return;
            if (!sections || !sections[selectedSectionIndex]) return;

            const px = scale.inchToPx;
            const ox = scale.originX;

            const { openTopY, openBottomY } = computeCaseOpeningVertical(model);
            const openingHeight = openBottomY - openTopY;
            if (openingHeight <= 0) return;

            const sec = sections[selectedSectionIndex];

            const faceX = ox + sec.xIn * px;
            const faceW = sec.widthIn * px;
            const faceTop = openTopY;

            const ns = "http://www.w3.org/2000/svg";

            // =====================================================
            // âœ… Overlay layer (always on top, even over sinks)
            // =====================================================
            const prev = svg.querySelector("#sectionControlsOverlay");
            if (prev) prev.remove();

            const overlayLayer = document.createElementNS(ns, "g");
            overlayLayer.setAttribute("id", "sectionControlsOverlay");
            svg.appendChild(overlayLayer);

            // After the whole draw finishes (including sinks), move overlay to top.
            requestAnimationFrame(() => {
                if (overlayLayer && overlayLayer.parentNode) {
                    overlayLayer.parentNode.appendChild(overlayLayer);
                }
            });

            // --------------------------------------------------
            // SECTION CONTROL BUTTONS (no side effects yet)
            // --------------------------------------------------
            const buttons = [];

            if (sec.role === "drawer") {
                const current =
                    sectionOverrides[selectedSectionIndex]?.drawerCount ?? 3;

                buttons.push({ id: "add-drawer", label: "add drawer" });

                if (current > 1) {
                    buttons.push({ id: "remove-drawer", label: "remove drawer" });
                }

                // âœ… Only show hide/show dims AFTER user changes drawer count (override dims actually appear)
                const DEFAULT_DRAWER_COUNT = 3;
                const hasDrawerOverride = (current !== DEFAULT_DRAWER_COUNT);

                if (hasDrawerOverride) {
                    const dimsHidden = sectionOverrides[selectedSectionIndex]?.drawerDimsHidden;
                    buttons.push({
                        id: "toggle-drawer-dims",
                        label: dimsHidden ? "show dims" : "hide dims"
                    });
                }
            }


            if (sec.role === "door") {
                const { minLeaves, maxLeaves } = getDoorLeafRulesForSection(sec);

                // determine current leaf count from drawing state
                // default = geometry-based
                let currentLeaves = (sec.widthIn >= 20 ? 2 : 1);

                // if an override exists, trust it
                const o = sectionOverrides[selectedSectionIndex];
                if (o && typeof o.doorLeaves === "number") {
                    currentLeaves = o.doorLeaves;
                }

                // show ONLY valid transitions
                if (currentLeaves === 1 && maxLeaves === 2) {
                    buttons.push({ id: "make-two-doors", label: "make two doors" });
                }
                if (currentLeaves === 2 && minLeaves === 1) {
                    buttons.push({ id: "make-one-door", label: "make one door" });
                }

            }

            // -----------------------------
            // INTERIOR SHELF TOGGLE
            // -----------------------------
            // âŒ hide interior shelf option when global shelfBelow is enabled
            if (!model.shelfBelow) {
                const hasShelf =
                    sectionOverrides[selectedSectionIndex]?.interiorShelf === true;

                buttons.push({
                    id: "toggle-interior-shelf",
                    label: hasShelf ? "remove interior shelf" : "add interior shelf"
                });
            }

            if (!buttons.length) return;

            // --------------------------------------------------
            // BUTTON LAYOUT
            // --------------------------------------------------
            const btnW = 110;
            const btnH = 26;
            const GAP_Y = 8;

            let curY = faceTop + 14; // start near top of selected face

            // light tint behind stack
            const totalH = buttons.length * btnH + (buttons.length - 1) * GAP_Y + 12;

            const t = document.createElementNS(ns, "rect");
            t.setAttribute("x", faceX + faceW - btnW - 12);
            t.setAttribute("y", curY - 6);
            t.setAttribute("width", btnW + 10);
            t.setAttribute("height", totalH);
            t.setAttribute("rx", 8);
            t.setAttribute("fill", "rgba(0,0,0,0.06)");
            t.setAttribute("stroke", "rgba(0,0,0,0.12)");
            overlayLayer.appendChild(t);

            buttons.forEach((btn) => {

                const x = faceX + faceW - btnW - 7;
                const y = curY;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", x);
                r.setAttribute("y", y);
                r.setAttribute("width", btnW);
                r.setAttribute("height", btnH);
                r.setAttribute("rx", 8);
                r.setAttribute("fill", "#1a73e8"); // blue
                r.setAttribute("stroke", "#0b57d0");
                r.style.cursor = "pointer";
                overlayLayer.appendChild(r);

                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", x + btnW / 2);
                text.setAttribute("y", y + btnH / 2 + 4);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-size", "12");
                text.setAttribute("fill", "#fff");
                text.textContent = btn.label;
                text.setAttribute("pointer-events", "none");
                overlayLayer.appendChild(text); // âœ… TEXT ABOVE BUTTON RECT

                r.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const o = (sectionOverrides[selectedSectionIndex] ||= {});

                    if (btn.id === "add-drawer") {
                        const cur = o.drawerCount ?? 3;
                        o.drawerCount = cur + 1;
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "remove-drawer") {
                        const cur = o.drawerCount ?? 3;
                        o.drawerCount = Math.max(1, cur - 1);
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "toggle-drawer-dims") {
                        o.drawerDimsHidden = !o.drawerDimsHidden;
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "toggle-interior-shelf") {
                        o.interiorShelf = !(o.interiorShelf === true);
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "make-two-doors") {
                        o.doorLeaves = 2;
                        updateDrawing();
                        return;
                    }

                    if (btn.id === "make-one-door") {
                        o.doorLeaves = 1;
                        updateDrawing();
                        return;
                    }
                });

                curY += btnH + GAP_Y;
            });

        }


        // ===========================================================
        // PATCH 5 â€” Throttled Update Drawing (Corrected Version)
        // ===========================================================



        function computeRunModel() {
            // For now, exactly one object: the existing vanity
            return {
                objects: [
                    {
                        id: "obj-1",
                        type: "vanity",
                        model: computeModel()
                    }
                ]
            };
        }

        function getActiveDrawingSvg() {
            const isMobile = window.matchMedia("(max-width: 768px)").matches;

            // OPTION A: On mobile we're showing the DESKTOP app layout,
            // so we must draw into the desktop SVG.
            if (isMobile) {
                return document.getElementById("vanityDrawing");
            }

            return document.getElementById("vanityDrawing");
        }

        function computeDrawingScale(svg, model) {
            const { widthIn, heightIn } = model;

            const svgRect = svg.getBoundingClientRect();
            const svgW = svgRect.width;
            const svgH = svgRect.height;

            // === USER-TUNABLE KNOBS (IN INCHES) ===
            const MARGIN_TOP_IN = 10;     // space above sink dims
            const MARGIN_BOTTOM_IN = 8;   // space below cabinet + width dim
            const MARGIN_SIDE_IN = 6;

            // Base px per inch (visual preference)
            const BASE_PX_PER_INCH = 8.0;

            // Cabinet bounds (in inches)
            const contentWIn = widthIn + MARGIN_SIDE_IN * 2;
            const contentHIn = heightIn + MARGIN_TOP_IN + MARGIN_BOTTOM_IN;

            // âœ… KEY CHANGE:
            // Fit ONLY by HEIGHT so long vanities do NOT shrink.
            const fitPxPerInchByHeight = svgH / contentHIn;

            // Final scale (never exceed base unless SVG is huge)
            const px = Math.min(BASE_PX_PER_INCH, fitPxPerInchByHeight);

            // âœ… KEY CHANGE:
            // Anchor to left margin (so the left end is visible and the rest can scroll)
            const originX = MARGIN_SIDE_IN * px;
            const originY = MARGIN_TOP_IN * px;

            return {
                inchToPx: px,
                originX,
                originY,

                // optional helpers (safe to ignore by draw code)
                contentWIn,
                contentHIn
            };
        }


        let _drawPending = false;

        function updateDrawing() {
            if (!initialDrawDone) return;

            if (_drawPending) return;
            _drawPending = true;

            requestAnimationFrame(() => {
                _drawPending = false;

                // âœ… Never draw on page 1â€“2 (matches your rule)
                const activePageId = document.querySelector(".page.active")?.id || "";
                const shouldDraw = (activePageId !== "page1" && activePageId !== "page2");

                // keep the mobile drawing wrapper in sync with the page
                updateMobileDrawingVisibility();

                if (!shouldDraw) {
                    const desktopSvg = document.getElementById("vanityDrawing");
                    if (desktopSvg) desktopSvg.innerHTML = "";

                    const mobileSvg = document.getElementById("mobileVanityDrawing");
                    if (mobileSvg) mobileSvg.innerHTML = "";

                    return;
                }

                // =====================================================
                // ðŸ”‘ Identify ACTIVE SVG early and ensure stable sizing
                // =====================================================
                const activeSvg = getActiveDrawingSvg();
                if (!activeSvg) return;

                // âœ… If the drawing is minimized, DO NOT clear/redraw now.
                // Navigating pages while minimized can make SVG size 0,
                // which causes doActualRunDrawing() to clear and then bail.
                // Instead: mark "needs redraw" and wait until user expands.
                if (document.body.classList.contains("drawing-minimized")) {
                    activeSvg.dataset.needsRedrawOnExpand = "1";
                    return;
                }

                // âœ… Let SVG grow wider than the panel when needed (enables horizontal scroll)
                activeSvg.style.height = "100%";
                activeSvg.style.width = "auto";

                // ðŸ”’ DO NOT remove width / height attributes.
                // doActualRunDrawing() sets real pixel dimensions for scrolling.

                // If layout isn't settled yet (or svg width doesn't match parent),
                // skip this draw and retry once on the next frame.
                const parent = activeSvg.parentElement;
                const svgW = activeSvg.getBoundingClientRect().width;
                const parentW = parent ? parent.getBoundingClientRect().width : svgW;

                // One-shot retry guard (prevents loops)
                if (!window.__vbLayoutRetry) window.__vbLayoutRetry = 0;

                const looksUnstable =
                    !isFinite(svgW) || svgW <= 0 ||
                    !isFinite(parentW) || parentW <= 0;

                if (looksUnstable && window.__vbLayoutRetry < 1) {
                    window.__vbLayoutRetry += 1;
                    requestAnimationFrame(() => updateDrawing());
                    return;
                }
                window.__vbLayoutRetry = 0;

                // =====================================================
                // Normal model â†’ UI sync â†’ drawing
                // =====================================================
                const model = computeModel();
                if (!model) return;

                // ðŸ”’ UI sync happens ONCE per model, not per draw
                updateDrawerWidthFieldsVisibility(model);
                syncDrawerInputsFromSections(model);
                updateStileAndRailControlsVisibility(model);

                const runModel = computeRunModel();
                if (!runModel) return;

                // =====================================================
                // Draw into the ACTIVE SVG, even if draw code
                // still hard-codes "vanityDrawing"
                // =====================================================
                const desktopSvg = document.getElementById("vanityDrawing");
                const mobileSvg = document.getElementById("mobileVanityDrawing");

                const wasMobile = (activeSvg === mobileSvg);

                // If mobile is active, temporarily alias its id to "vanityDrawing"
                // so existing draw code continues to work without edits.
                let restoreDesktopId = false;

                if (wasMobile) {
                    if (desktopSvg && desktopSvg !== activeSvg) {
                        desktopSvg.id = "vanityDrawing_desktop";
                        restoreDesktopId = true;
                    }
                    activeSvg.id = "vanityDrawing";
                }

                doActualRunDrawing(runModel);

                // restore ids
                if (wasMobile) {
                    activeSvg.id = "mobileVanityDrawing";
                    if (restoreDesktopId && desktopSvg) {
                        desktopSvg.id = "vanityDrawing";
                    }
                }

                updatePriceDisplay(runModel.objects[0].model);
                updatePriceDisplay(model);
            });
        }


        function drawVanityAtX(svg, model, offsetX) {
            const originalX = model.scale.originX;

            // shift drawing origin
            model.scale.originX = originalX + offsetX;

            // ðŸ”’ EXACT SAME DRAW CALLS AS NORMAL VANITY
            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);

            // restore origin
            model.scale.originX = originalX;
        }

        function doActualRunDrawing(runModel) {
            const svg = getActiveDrawingSvg();
            if (!svg) return;

            clearSvg(svg);

            // =========================================================
            // STABLE TRANSFORM TARGET (prevents midpoint drift + snapping)
            // =========================================================
            const ns = "http://www.w3.org/2000/svg";
            const viewportG = document.createElementNS(ns, "g");
            viewportG.setAttribute("id", "mobileViewport");
            svg.appendChild(viewportG);

            // ðŸ”’ APPLY VIEWPORT SCALE (ONCE)
            runModel.objects.forEach(obj => {
                if (obj.model) {
                    obj.model.scale = computeDrawingScale(svg, obj.model);
                }
            });

            const basePx = runModel.objects[0]?.model?.scale?.inchToPx;
            if (!basePx) return;

            // -------------------------------
            // 2) DETERMINE TALLEST OBJECT
            // -------------------------------
            let tallestHeightIn = 0;

            runModel.objects.forEach(obj => {
                if (obj.type === "vanity" && obj.model?.heightIn) {
                    tallestHeightIn = Math.max(tallestHeightIn, obj.model.heightIn);
                }
            });

            // -------------------------------
            // 3) HEIGHT-FIRST RULE (scale clamp)
            // -------------------------------
            const MAX_DRAWING_HEIGHT_PX = 700;

            let effectivePx = basePx;

            // temporary gutters for scale decision (will recompute later)
            const TEMP_TOP_GUTTER_PX = 12 * basePx;
            const TEMP_BOTTOM_GUTTER_PX = 10 * basePx;

            const rawHeightPx =
                tallestHeightIn * basePx +
                TEMP_TOP_GUTTER_PX +
                TEMP_BOTTOM_GUTTER_PX;

            if (rawHeightPx > MAX_DRAWING_HEIGHT_PX) {
                effectivePx = basePx * (MAX_DRAWING_HEIGHT_PX / rawHeightPx);
            }

            // âœ… KEY: if expanded mode has a locked px, always use it
            const isExpanded = document.body.classList.contains("drawing-expanded");
            const lockedPx = Number(svg.dataset.lockedEffectivePx);
            if (isExpanded && isFinite(lockedPx) && lockedPx > 0) {
                effectivePx = lockedPx;
            }

            // âœ… KEY: remember what we actually drew at (used to lock expanded later)
            svg.dataset.lastEffectivePx = String(effectivePx);

            // -------------------------------
            // 4) GUTTERS (NOW USING effectivePx)
            // -------------------------------
            const SINK_DIM_OFFSET_IN = 7;

            const LEFT_GUTTER_PX = 22 * effectivePx;
            const RIGHT_GUTTER_PX = 22 * effectivePx;

            const TOP_GUTTER_PX =
                (SINK_DIM_OFFSET_IN + 7) * effectivePx; // â¬… extra safety space above first dim chain

            const BOTTOM_GUTTER_PX = 10 * effectivePx;

            // -------------------------------
            // 5) DRAW OBJECTS (HORIZONTAL FLOW)
            // -------------------------------
            let cursorX = 0;
            const GAP_PX = 24;

            runModel.objects.forEach(obj => {
                if (obj.type !== "vanity") return;

                obj.model.scale.inchToPx = effectivePx;
                obj.model.scale.originX = LEFT_GUTTER_PX;
                obj.model.scale.originY = TOP_GUTTER_PX;

                // âœ… draw INTO the wrapper group (not the svg)
                drawVanityAtX(viewportG, obj.model, cursorX);

                cursorX += obj.model.widthIn * effectivePx + GAP_PX;
            });

            // -------------------------------
            // 6) FINAL VIEWPORT SIZE (BBOX-BASED â†’ NO MORE "INVISIBLE WALL")
            // -------------------------------
            // Use what was ACTUALLY drawn to size the viewBox so nothing clips.
            let bbox;
            try {
                bbox = viewportG.getBBox();
            } catch (e) {
                // If bbox fails for any reason, bail safely.
                return;
            }

            // Ensure the viewBox starts at 0,0 (your drawing expects that),
            // but expand width/height to fully contain the drawn content + gutters.
            const totalWidth = Math.ceil(Math.max(bbox.x + bbox.width + RIGHT_GUTTER_PX, 1));
            const totalHeight = Math.ceil(Math.max(bbox.y + bbox.height + BOTTOM_GUTTER_PX, 1));

            // Keep viewBox for consistency, but ALSO set explicit pixel size so
            // 1 viewBox unit == 1 CSS px, enabling scroll + stable scale.
            svg.setAttribute("viewBox", `0 0 ${totalWidth} ${totalHeight}`);
            svg.setAttribute("width", `${totalWidth}`);
            svg.setAttribute("height", `${totalHeight}`);

            // âœ… KEY: re-apply the current mobile pan/zoom AFTER redraw
            requestAnimationFrame(() => {
                if (typeof applyMobileTransform === "function") applyMobileTransform();
            });

            // -------------------------------
            // 7) CENTER THE SCROLLER (DESKTOP + MOBILE)
            // -------------------------------
            const panel = document.getElementById("drawing-panel");

            // âœ… KEY: do NOT re-center if user has panned/zoomed (prevents snap-to-center)
            const userHasMovedView =
                (typeof mobileScale === "number" && mobileScale !== 1) ||
                (typeof mobileTranslateX === "number" && mobileTranslateX !== 0) ||
                (typeof mobileTranslateY === "number" && mobileTranslateY !== 0);

            if (panel && !document.body.classList.contains("drawing-expanded") && !userHasMovedView) {
                requestAnimationFrame(() => {
                    const maxX = Math.max(0, svg.getBoundingClientRect().width - panel.clientWidth);
                    const maxY = Math.max(0, svg.getBoundingClientRect().height - panel.clientHeight);

                    panel.scrollLeft = Math.max(0, maxX / 2);
                    panel.scrollTop = Math.max(0, maxY / 2);
                });
            }
        }


        // DRAW PIPELINE
        // Order matters. Geometry is computed once per frame.
        // Drawing functions must NOT recompute layout or geometry.

        function doActualDrawing(model) {
            const svg = document.getElementById("vanityDrawing");
            if (!svg || !model) return;

            clearSvg(svg);


            // =====================================================
            // MAKEUP DESK BRANCH (DRAW ROUTING ONLY)
            // =====================================================
            if (model.makeupDeskEnabled === true) {
                drawVanityWithMakeupDesk(svg, model);
                return; // ðŸ”’ IMPORTANT: do not fall through
            }

            // =====================================================
            // NORMAL VANITY (UNCHANGED)
            // =====================================================
            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);
        }

        function drawVanityWithMakeupDesk(svg, model) {
            // TEMP: for now, draw EXACTLY the same as a normal vanity
            // This guarantees no regressions while we scaffold.

            drawVanityOutline(svg, model);
            drawLegs(svg, model);
            drawTopRail(svg, model);
            drawBottomRail(svg, model);
            drawSectionStiles(svg, model);

            drawSectionFronts(svg, model);
            drawSectionHitTargets(svg, model);
            drawSectionControlsOverlay(svg, model);

            drawFrameJointPatches(svg, model);

            drawSinkOutlines(svg, model);
            drawSinkDimensions(svg, model);

            drawShelf(svg, model);
            drawBottomDetail(svg, model);
            drawShelfPatches(svg, model);

            drawSimpleDimensions(svg, model);
        }




        // Decide which sections host sinks based on sinkCount and sinkPosition.
        // Optional second arg lets us run this on a fresh sections array
        // before model.sections has been assigned.
        function computeSinkSectionIndices(model, sectionsOverride) {
            const sections = sectionsOverride || model.sections || [];
            if (!sections.length) return [];

            const sinkCount = model.sinkCount || 0;
            if (!sinkCount) return [];

            const widthIn = model.widthIn || 0;
            const rawPos = model.sinkPosition || "center";

            const lastIndex = sections.length - 1;
            const clampIdx = (idx) => {
                if (idx < 0) return 0;
                if (idx > lastIndex) return lastIndex;
                return idx;
            };

            // === SINGLE SINK =====================================================
            if (sinkCount === 1) {
                // Off-center is only meaningful for:
                //  - exactly 1 sink
                //  - width between 30" and 115"
                const offCenterAllowed =
                    widthIn >= 30 &&
                    widthIn <= 115;

                let sinkPosition = rawPos;
                if (!offCenterAllowed) {
                    sinkPosition = "center";
                }

                let idx;
                if (sinkPosition === "left") {
                    // always first section
                    idx = 0;
                } else if (sinkPosition === "right") {
                    // always last section
                    idx = lastIndex;
                } else {
                    // "center" (or anything else) â†’ pick a center-ish section
                    // For odd counts (3, 5, 7, â€¦) this is the true middle.
                    // For even counts (2, 4, â€¦) this biases slightly left.
                    idx = Math.floor(lastIndex / 2);
                }

                idx = clampIdx(idx);
                return [idx];
            }

            // === DOUBLE SINKS ====================================================
            if (sinkCount === 2) {
                // Build door + drawer section lists with x-centers
                const doorSecs = [];
                const drawerSecs = [];

                sections.forEach((sec, i) => {
                    const centerX = sec.xIn + sec.widthIn / 2;
                    if (sec.role === "door" || sec.role === "sink") {
                        doorSecs.push({ i, x: centerX });
                    } else if (sec.role === "drawer") {
                        drawerSecs.push({ i, x: centerX });
                    }
                });

                // Helper: sort by x ascending
                const byX = (a, b) => a.x - b.x;

                // 1) If we have at least two DOOR sections â†’ use the outermost doors
                //    (e.g. in drawer / door / drawer / door / drawer, this gives sections 2 & 4)
                if (doorSecs.length >= 2) {
                    const sorted = [...doorSecs].sort(byX);
                    return [sorted[0].i, sorted[sorted.length - 1].i];
                }

                // 2) Exactly one door section + some drawers:
                //    pair that door with the FURTHEST drawer bay
                if (doorSecs.length === 1 && drawerSecs.length >= 1) {
                    const d = doorSecs[0];
                    const others = drawerSecs.filter(s => s.i !== d.i);
                    if (others.length) {
                        let best = others[0];
                        let bestDist = Math.abs(others[0].x - d.x);
                        for (let k = 1; k < others.length; k++) {
                            const dist = Math.abs(others[k].x - d.x);
                            if (dist > bestDist) {
                                bestDist = dist;
                                best = others[k];
                            }
                        }
                        return [d.i, best.i].sort((a, b) => a - b);
                    }
                    // if somehow no "others", fall back to outermost drawers
                }

                // 3) No door sections at all â†’ all drawers; use outermost drawers
                if (drawerSecs.length >= 2) {
                    const sorted = [...drawerSecs].sort(byX);
                    return [sorted[0].i, sorted[sorted.length - 1].i];
                }

                // 4) Horrible edge case: not enough info, fall back to 0 & last
                return [0, lastIndex];
            }

            // Other sink counts: nothing to place for now
            return [];
        }



        function drawSinkOutlines(svg, model) {
            const { sections = [], sinkCount = 0, scale } = model;
            if (!sections.length || !sinkCount || !scale) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;
            const ns = "http://www.w3.org/2000/svg";

            const cabTopY = oy;

            // Sinks sit 1/4" below the top
            const SINK_TOP_OFFSET_IN = 0.25;
            const SIDE_MARGIN_IN = 0.25;  // small buffer from section edges

            const sinkTopY = cabTopY + SINK_TOP_OFFSET_IN * px;

            // Decide bowl size from the *section* width: always 15 / 18 / 20
            function pickBowlWidthForSection(secWidthIn) {
                const usable = Math.max(secWidthIn - 2 * SIDE_MARGIN_IN, 0);

                if (usable >= 20) return 20;       // biggest
                if (usable >= 17) return 18;       // mid
                return 15;                         // smallest
            }

            function pickBowlHeight(bowlIn) {
                // you can tweak these, but keep them discrete as well
                if (bowlIn === 15) return 6.0;
                if (bowlIn === 18) return 6.5;
                return 7.0; // for 20"
            }

            const sinkIndices = computeSinkSectionIndices(model);

            sinkIndices.forEach(idx => {
                const sec = sections[idx];
                if (!sec) return;

                const bowlWidthIn = pickBowlWidthForSection(sec.widthIn);
                const bowlHeightIn = pickBowlHeight(bowlWidthIn);

                const sinkWidthPx = bowlWidthIn * px;
                const sinkHeightPx = bowlHeightIn * px;

                const centerIn = sec.xIn + sec.widthIn / 2;
                const centerX = ox + centerIn * px;
                const sinkLeftX = centerX - sinkWidthPx / 2;

                const r = document.createElementNS(ns, "rect");
                r.setAttribute("x", sinkLeftX);
                r.setAttribute("y", sinkTopY);
                r.setAttribute("width", sinkWidthPx);
                r.setAttribute("height", sinkHeightPx);
                r.setAttribute("fill", "none");
                r.setAttribute("stroke", SINK_COLOR);
                r.setAttribute("stroke-width", SINK_STROKE);
                r.setAttribute("stroke-dasharray", SINK_DASH);
                svg.appendChild(r);
            });
        }

        function drawSinkDimensions(svg, model) {
            const { sections = [], sinkCount = 0, scale, widthIn } = model;
            if (!sections.length || !sinkCount || !scale || !widthIn) return;

            const px = scale.inchToPx;
            // DIM UI SCALE DIAL (scales text + arrowheads with the drawing)
            const DIM_UI_BASE_PX_PER_INCH = 6;
            const dimUiScale = Math.max(0.75, px / DIM_UI_BASE_PX_PER_INCH);

            const ox = scale.originX;
            const oy = scale.originY;

            const ns = "http://www.w3.org/2000/svg";

            const cabW = widthIn * px;
            const leftX = ox;
            const rightX = ox + cabW;
            const cabTopY = oy;

            const ALIGN_FUDGE = 0.5;

            // knob: how far above the top of the cabinet (in drawing inches)
            const SINK_DIM_OFFSET_IN = 7;          // â† change this to move sink dim chain

            const sinkDimY = cabTopY - SINK_DIM_OFFSET_IN * px - ALIGN_FUDGE;


            // draw the little V-shaped arrowheads like in your CAD screenshot
            function drawArrowHead(x, y, dir) {
                // dir = +1 (arrow points right) or -1 (arrow points left)
                const len = 4 * dimUiScale;   // arrow reach (scales with drawing)
                const spread = 2 * dimUiScale;


                const line1 = document.createElementNS(ns, "line");
                line1.setAttribute("x1", x);
                line1.setAttribute("y1", y);
                line1.setAttribute("x2", x + dir * len);
                line1.setAttribute("y2", y - spread);
                line1.setAttribute("stroke", SINK_COLOR);
                line1.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(line1);

                const line2 = document.createElementNS(ns, "line");
                line2.setAttribute("x1", x);
                line2.setAttribute("y1", y);
                line2.setAttribute("x2", x + dir * len);
                line2.setAttribute("y2", y + spread);
                line2.setAttribute("stroke", SINK_COLOR);
                line2.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(line2);
            }

            function createDimSegment(x1, x2, labelText) {
                const midX = (x1 + x2) / 2;

                // dashed blue base line
                const line = document.createElementNS(ns, "line");
                line.setAttribute("x1", x1);
                line.setAttribute("y1", sinkDimY);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", sinkDimY);
                line.setAttribute("stroke", SINK_COLOR);
                line.setAttribute("stroke-width", SINK_STROKE);
                line.setAttribute("stroke-dasharray", SINK_DASH);
                svg.appendChild(line);

                // arrowheads: start points inward toward the segment
                const dir = x2 >= x1 ? 1 : -1;
                drawArrowHead(x1, sinkDimY, dir);      // arrow at start
                drawArrowHead(x2, sinkDimY, -dir);     // arrow at end

                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", midX);
                text.setAttribute("y", sinkDimY - 9 * dimUiScale);
                text.setAttribute("font-size", String(10 * dimUiScale));

                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("fill", SINK_COLOR);
                text.textContent = labelText;
                svg.appendChild(text);
            }

            // figure out centers with sinks
            const sinkIndices = computeSinkSectionIndices(model);
            if (!sinkIndices.length) return;

            const centersIn = sinkIndices.map(idx => {
                const sec = sections[idx];
                return sec.xIn + sec.widthIn / 2;
            }).sort((a, b) => a - b);

            if (centersIn.length === 1) {
                // single sink: leftâ†’center, centerâ†’right
                const c = centersIn[0];
                const xC = ox + c * px;

                const leftDistIn = c;
                const rightDistIn = widthIn - c;

                createDimSegment(
                    leftX - ALIGN_FUDGE,
                    xC - ALIGN_FUDGE,
                    `${formatInchesFraction(leftDistIn)}"`
                );


                createDimSegment(
                    xC - ALIGN_FUDGE,
                    rightX - ALIGN_FUDGE,
                    `${formatInchesFraction(rightDistIn)}"`
                );
            } else {
                // double sink: use outermost centers
                const c1 = centersIn[0];
                const c2 = centersIn[centersIn.length - 1];

                const xC1 = ox + c1 * px;
                const xC2 = ox + c2 * px;

                const leftDistIn = c1;
                const betweenIn = c2 - c1;
                const rightDistIn = widthIn - c2;

                // left end â†’ left sink center
                createDimSegment(
                    leftX - ALIGN_FUDGE,
                    xC1 - ALIGN_FUDGE,
                    `${formatInchesFraction(leftDistIn)}"`
                );

                // between sink centers
                createDimSegment(
                    xC1 - ALIGN_FUDGE,
                    xC2 - ALIGN_FUDGE,
                    `${formatInchesFraction(betweenIn)}"`
                );

                // right sink center â†’ right end
                createDimSegment(
                    xC2 - ALIGN_FUDGE,
                    rightX - ALIGN_FUDGE,
                    `${formatInchesFraction(rightDistIn)}"`
                );
            }

            // vertical blue centerlines: 3" tall, centered on the sink dim line
            const halfCenterLine = (3 * px) / 2;

            sinkIndices.forEach(idx => {
                const sec = sections[idx];
                if (!sec) return;

                const centerIn = sec.xIn + sec.widthIn / 2;
                const centerX = ox + centerIn * px;

                const vTop = sinkDimY - halfCenterLine;
                const vBot = sinkDimY + halfCenterLine;

                const centerLine = document.createElementNS(ns, "line");
                centerLine.setAttribute("x1", centerX);
                centerLine.setAttribute("y1", vTop);
                centerLine.setAttribute("x2", centerX);
                centerLine.setAttribute("y2", vBot);
                centerLine.setAttribute("stroke", SINK_COLOR);
                centerLine.setAttribute("stroke-width", SINK_STROKE);
                svg.appendChild(centerLine);
            });
        }

        function drawBottomDetail(svg, model) {
            const {
                widthIn,
                heightIn,
                toeKickHeightIn,
                scale,
                frame,
                bottomDetail,
                floating,
                floatingGapIn = 0,
                shelfBelow
            } = model;

            if (!frame || !scale) return;

            const px = scale.inchToPx;
            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const legWpx = (frame.legWidthIn ?? FRAME_DEFAULTS.legWidthIn) * px;

            const cabBottomYFull = oy + cabH;
            const floorX1 = ox + legWpx;
            const floorX2 = ox + cabW - legWpx;

            const ns = "http://www.w3.org/2000/svg";

            // âœ… READ geometry (never compute or mutate here)
            const geom = computeGeometry(model).vertical;
            const {
                shelfTopY,
                shelfBottomY,
                shelfThicknessPx
            } = geom;

            // -------------------------------------------------------
            // FLOATING MODE
            // -------------------------------------------------------
            if (floating) {
                let gapIn = floatingGapIn;
                if (!gapIn || !isFinite(gapIn) || gapIn < 0) {
                    gapIn = FLOAT_TOP_HEIGHT_IN - heightIn;
                    if (gapIn < 0) gapIn = 0;
                }

                const floorY = cabBottomYFull + gapIn * px;
                const extendPx = 20;

                const floorLine = document.createElementNS(ns, "line");
                floorLine.setAttribute("x1", ox - extendPx);
                floorLine.setAttribute("y1", floorY);
                floorLine.setAttribute("x2", ox + cabW + extendPx);
                floorLine.setAttribute("y2", floorY);
                floorLine.setAttribute("stroke", DIM_COLOR);
                floorLine.setAttribute("stroke-width", DIM_STROKE);
                floorLine.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.insertBefore(floorLine, svg.firstChild);

                const label = document.createElementNS(ns, "text");
                label.setAttribute("x", (floorX1 + floorX2) / 2);
                label.setAttribute("y", floorY - 2 * px);
                label.setAttribute("font-size", "10");
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("dominant-baseline", "middle");
                label.textContent = "floating";
                svg.appendChild(label);

                return;
            }

            // -------------------------------------------------------
            // NON-FLOATING
            // -------------------------------------------------------
            const floorY = cabBottomYFull;

            const openTopY =
                shelfBelow && shelfBottomY != null
                    ? shelfBottomY
                    : cabBottomYFull - ((toeKickHeightIn || 4) * px);

            const labelY = floorY + (openTopY - floorY) / 2;

            // -------------------------------------------------------
            // OPEN BELOW
            // -------------------------------------------------------
            if (bottomDetail === "open-below") {
                const extendPx = 20;

                const floorLine = document.createElementNS(ns, "line");
                floorLine.setAttribute("x1", ox - extendPx);
                floorLine.setAttribute("y1", floorY);
                floorLine.setAttribute("x2", ox + cabW + extendPx);
                floorLine.setAttribute("y2", floorY);
                floorLine.setAttribute("stroke", DIM_COLOR);
                floorLine.setAttribute("stroke-width", DIM_STROKE);
                floorLine.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.insertBefore(floorLine, svg.firstChild);

                const label = document.createElementNS(ns, "text");
                label.setAttribute("x", (floorX1 + floorX2) / 2);
                label.setAttribute("y", labelY);
                label.setAttribute("font-size", "12");
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("dominant-baseline", "middle");
                label.textContent = "open below";
                svg.appendChild(label);

                return;
            }

            // -------------------------------------------------------
            // TOE KICK (DEFAULT)
            // -------------------------------------------------------
            const floorLine = document.createElementNS(ns, "line");
            floorLine.setAttribute("x1", floorX1);
            floorLine.setAttribute("y1", floorY);
            floorLine.setAttribute("x2", floorX2);
            floorLine.setAttribute("y2", floorY);
            floorLine.setAttribute("stroke", STRUCTURE_COLOR);
            floorLine.setAttribute("stroke-width", STROKE);
            svg.appendChild(floorLine);

            const label = document.createElementNS(ns, "text");
            label.setAttribute("x", (floorX1 + floorX2) / 2);
            label.setAttribute("y", labelY);
            label.setAttribute("font-size", "12");
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("dominant-baseline", "middle");
            label.textContent = `${toeKickHeightIn}" toe kick`;
            svg.appendChild(label);
        }



        // DRAW-ONLY FUNCTION
        // Must not modify model or compute geometry.
        // Reads from computeGeometry(model) only.

        function drawSimpleDimensions(svg, model) {
            const {
                widthIn,
                heightIn,
                scale,
                sections = [],
                frame = {},
                removeStiles,
                toeKickHeightIn
            } = model;

            const px = scale.inchToPx;
            // DIM UI SCALE DIAL (scales text + ticks with the drawing)
            // If your "normal" drawing px is ~9, this keeps the look consistent.
            // Increase 9 -> 10/11 to make dim UI relatively smaller. Decrease to make it bigger.
            const DIM_UI_BASE_PX_PER_INCH = 6;
            const dimUiScale = Math.max(0.75, px / DIM_UI_BASE_PX_PER_INCH);


            const geom = computeGeometry(model);
            const { openTopY, openBottomY, cabBottomY } = geom.vertical;

            const ox = scale.originX;
            const oy = scale.originY;

            const cabW = widthIn * px;
            const cabH = heightIn * px;

            const leftX = ox;
            const rightX = ox + cabW;
            const cabTopY = oy;


            const ns = "http://www.w3.org/2000/svg";

            // tiny visual alignment nudge so dims line up perfectly
            const ALIGN_FUDGE = 0.5;

            // inch-based offsets
            const off2p5Px = 1.5 * px;   // 2.5" in pixels


            // --- helpers ---------------------------------------------------
            const createDimLine = (x1, y1, x2, y2) => {
                const l = document.createElementNS(ns, "line");
                l.setAttribute("x1", x1);
                l.setAttribute("y1", y1);
                l.setAttribute("x2", x2);
                l.setAttribute("y2", y2);
                l.setAttribute("stroke", DIM_COLOR);
                l.setAttribute("stroke-width", DIM_STROKE);
                l.setAttribute("stroke-dasharray", DASH_PATTERN);
                svg.appendChild(l);
            };

            const createText = (x, y, text, anchor = "middle") => {
                const t = document.createElementNS(ns, "text");
                t.setAttribute("x", x);
                t.setAttribute("y", y);
                t.setAttribute("font-size", String(10 * dimUiScale)); // scales with drawing
                t.setAttribute("text-anchor", anchor);          // <- use param
                t.setAttribute("dominant-baseline", "middle");
                t.setAttribute("fill", DIM_COLOR);
                t.textContent = text;
                svg.appendChild(t);
            };

            // dashed vertical tick centered on dim line
            const createVerticalTick = (x, dimY) => {
                const tickLen = 6 * dimUiScale;
                const half = tickLen / 2;
                const pattern = "2 2";

                const up = document.createElementNS(ns, "line");
                up.setAttribute("x1", x);
                up.setAttribute("y1", dimY - half);
                up.setAttribute("x2", x);
                up.setAttribute("y2", dimY);
                up.setAttribute("stroke", DIM_COLOR);
                up.setAttribute("stroke-width", DIM_STROKE);
                up.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(up);

                const dn = document.createElementNS(ns, "line");
                dn.setAttribute("x1", x);
                dn.setAttribute("y1", dimY);
                dn.setAttribute("x2", x);
                dn.setAttribute("y2", dimY + half);
                dn.setAttribute("stroke", DIM_COLOR);
                dn.setAttribute("stroke-width", DIM_STROKE);
                dn.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(dn);
            };

            // dashed horizontal tick centered on dim line
            const createHorizontalTick = (dimX, y) => {
                const tickLen = 6 * dimUiScale;
                const half = tickLen / 2;
                const pattern = "2 2";

                const left = document.createElementNS(ns, "line");
                left.setAttribute("x1", dimX - half);
                left.setAttribute("y1", y);
                left.setAttribute("x2", dimX);
                left.setAttribute("y2", y);
                left.setAttribute("stroke", DIM_COLOR);
                left.setAttribute("stroke-width", DIM_STROKE);
                left.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(left);

                const right = document.createElementNS(ns, "line");
                right.setAttribute("x1", dimX);
                right.setAttribute("y1", y);
                right.setAttribute("x2", dimX + half);
                right.setAttribute("y2", y);
                right.setAttribute("stroke", DIM_COLOR);
                right.setAttribute("stroke-width", DIM_STROKE);
                right.setAttribute("stroke-dasharray", pattern);
                svg.appendChild(right);
            };

            // === OVERALL WIDTH (below the floor line) =============================
            // knob: how far below the floor line (in drawing inches)
            const OVERALL_WIDTH_OFFSET_IN = 4;      // â† change this number to move it

            const overallWidthY = cabBottomY + OVERALL_WIDTH_OFFSET_IN * px + ALIGN_FUDGE;
            const dimLeftX = leftX - ALIGN_FUDGE;
            const dimRightX = rightX - ALIGN_FUDGE;

            createDimLine(dimLeftX, overallWidthY, dimRightX, overallWidthY);
            createVerticalTick(dimLeftX, overallWidthY);
            createVerticalTick(dimRightX, overallWidthY);

            // text sits just below the dim line
            createText(
                dimLeftX + cabW / 2,
                overallWidthY + 10,
                `${formatInchesFraction(widthIn)}"`
            );


            // === SECTION WIDTHS (2.5" above cabinet) =============================
            if (sections && sections.length > 0) {
                const sectionLineY = cabTopY - off2p5Px - ALIGN_FUDGE;

                sections.forEach(sec => {
                    const leftIn = sec.xIn;
                    const rightIn = sec.xIn + sec.widthIn;
                    const faceWidthIn = rightIn - leftIn;
                    if (faceWidthIn <= 0) return;

                    const leftPx = ox + leftIn * px - ALIGN_FUDGE;
                    const rightPx = ox + rightIn * px - ALIGN_FUDGE;

                    createDimLine(leftPx, sectionLineY, rightPx, sectionLineY);
                    createVerticalTick(leftPx, sectionLineY);
                    createVerticalTick(rightPx, sectionLineY);

                    const midX = leftPx + (rightPx - leftPx) / 2;
                    createText(
                        midX,
                        sectionLineY - 8,
                        `${formatInchesFraction(faceWidthIn)}"`
                    );
                });
            }


            // === OVERALL HEIGHT (left side, 2.5" away) ===========================
            const dimTopY = cabTopY - ALIGN_FUDGE;
            const dimBottomY = cabBottomY - ALIGN_FUDGE;
            const dimXLeftSide = leftX - off2p5Px - ALIGN_FUDGE;

            createDimLine(dimXLeftSide, dimTopY, dimXLeftSide, dimBottomY);
            createHorizontalTick(dimXLeftSide, dimTopY);
            createHorizontalTick(dimXLeftSide, dimBottomY);

            // 1" text gap from the dim line (in drawing inches)
            const labelGapIn = 1;
            const labelX = dimXLeftSide - labelGapIn * px;

            createText(
                labelX,
                dimTopY + cabH / 2,
                `${formatInchesFraction(heightIn)}"`,
                "end" // right-align text at labelX
            );




            // === DRAWER FACE HEIGHTS (right side, 2.5" away) ====================
            const hasDrawerSection = sections.some(sec => sec.role === "drawer");

            if (hasDrawerSection) {

                const openingHeightPx = openBottomY - openTopY;

                if (openingHeightPx > 0) {
                    const drawerDimX = rightX + off2p5Px + ALIGN_FUDGE;
                    const topDrawerOption = model.topDrawerHeightPreset || "equal";

                    const drawerRailsMode = model.drawerRailsMode || "none";
                    const drawerRailHeightIn = model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN;

                    // ---------------------------------------------
                    // STANDARD DRAWER DIMS â€” authoritative count
                    // ---------------------------------------------
                    const drawerSections = sections
                        .map((sec, idx) => ({ sec, idx }))
                        .filter(o => o.sec.role === "drawer");

                    // base drawer count MUST match section drawing logic
                    const baseCount = model.shelfBelow ? 2 : 3;

                    let effectiveCount = baseCount;

                    // if multiple drawer sections, they must agree
                    if (drawerSections.length) {
                        const counts = drawerSections.map(({ idx }) =>
                            getDrawerCountForSection(model, idx, baseCount)
                        );

                        // only adopt override when all sections match
                        if (counts.every(c => c === counts[0])) {
                            effectiveCount = counts[0];
                        }
                        // ---------------------------------------------
                        // CLAMP to match drawDrawerStack() behavior
                        // (prevents "4 labels but only 3 drawers drawn")
                        // ---------------------------------------------
                        const MIN_FACE_IN = 5;
                        const openingIn = openingHeightPx / px;
                        const maxDrawers = Math.max(1, Math.floor(openingIn / MIN_FACE_IN));
                        effectiveCount = Math.max(1, Math.min(effectiveCount, maxDrawers));

                    }

                    // rebuild heights using the SAME opening height
                    const layout = getFinalDrawerLayoutForSection(
                        model,
                        drawerSections[0]?.idx ?? 0,
                        openingHeightPx
                    );



                    const drawerCount = layout.drawerCount;
                    const heights = layout.heightsPx;
                    const railPx = layout.railHeightPx;

                    let curY = openTopY - ALIGN_FUDGE;

                    for (let i = 0; i < drawerCount; i++) {
                        const segHpx = heights[i] ?? (openingHeightPx / drawerCount);
                        const y1 = curY;
                        const y2 = curY + segHpx;

                        // dim for this drawer face only
                        createDimLine(drawerDimX, y1, drawerDimX, y2);
                        createHorizontalTick(drawerDimX, y1);
                        createHorizontalTick(drawerDimX, y2);

                        const midY = y1 + (y2 - y1) / 2;
                        const segHin = segHpx / px;

                        const textOffsetPx = 1 * px;

                        createText(
                            drawerDimX + textOffsetPx,
                            midY,
                            `${formatInchesFraction(segHin)}"`,
                            "start"
                        );

                        curY += segHpx;

                        // skip over rails so the dim chain visually leaves the 1" gaps
                        if (railPx > 0) {
                            if (drawerRailsMode === "all" && i < drawerCount - 1) {
                                curY += railPx;
                            } else if (drawerRailsMode === "top" && i === 0 && drawerCount > 1) {
                                curY += railPx;
                            }
                        }
                    }
                }
            }


            // === TOE KICK / OPEN-BELOW HEIGHT (right side, below drawers) ==========
            if (!model.floating && toeKickHeightIn && toeKickHeightIn > 0) {
                // same X as drawer height dims
                const dimX = rightX + off2p5Px + ALIGN_FUDGE;

                const toeKickPx = toeKickHeightIn * px;
                const floorY = cabBottomY - ALIGN_FUDGE;   // bottom of cabinet
                const topY = floorY - toeKickPx;         // top of toe-kick/open-below space

                // vertical dim line
                createDimLine(dimX, topY, dimX, floorY);
                createHorizontalTick(dimX, topY);
                createHorizontalTick(dimX, floorY);

                // text 1" away from the dim line
                const labelOffsetPx = 1 * px;
                const midY = topY + (floorY - topY) / 2;

                createText(
                    dimX + labelOffsetPx,
                    midY,
                    `${formatInchesFraction(toeKickHeightIn)}"`,
                    "start"
                );
            }

            // === SHELF OPENING HEIGHT (right side, above shelf) ====================
            if (model.shelfBelow && !model.floating) {

                const shelfTopY = geom.shelfTopY;
                const openTopY = geom.openTopY;

                if (shelfTopY != null && shelfTopY > openTopY) {

                    const dimX = rightX + off2p5Px + ALIGN_FUDGE;

                    createDimLine(dimX, openTopY, dimX, shelfTopY);
                    createHorizontalTick(dimX, openTopY);
                    createHorizontalTick(dimX, shelfTopY);

                    const shelfOpeningIn = (shelfTopY - openTopY) / px;
                    const midY = (openTopY + shelfTopY) / 2;
                    const textOffsetPx = 1 * px;

                    createText(
                        dimX + textOffsetPx,
                        midY,
                        `${formatInchesFraction(shelfOpeningIn)}"`,
                        "start"
                    );
                }
            }


            // === SHELF SPACE DIMENSION (right side, between shelf and bottom rail) ===
            if (model.shelfBelow && !model.floating) {

                const px = scale.inchToPx;
                const shelfTopY = geom.vertical.shelfTopY;
                const bottomRailBottomY = geom.vertical.openBottomY + (geom.vertical.bottomRailHpx || 0);


                // coordinates
                const dimX = rightX + off2p5Px + ALIGN_FUDGE;  // same as drawer + toe kick dims
                const floorY = cabBottomY - ALIGN_FUDGE;

                // draw line
                createDimLine(dimX, bottomRailBottomY, dimX, shelfTopY);
                createHorizontalTick(dimX, bottomRailBottomY);
                createHorizontalTick(dimX, shelfTopY);

                // label 1" to the right of the dim line
                const textOffsetPx = 1 * px;
                const midY = (bottomRailBottomY + shelfTopY) / 2;


                createText(
                    dimX + textOffsetPx,
                    midY,
                    `${formatInchesFraction(model.shelfSpaceIn)}"`,
                    "start"
                );
            }
        }


        function syncBottomHeightLabelAndLimits() {
            const bottomSel = document.getElementById("bottomDetail");
            const toeInput = document.getElementById("toeKickHeight");
            const label = document.getElementById("toeKickLabel");

            if (!bottomSel || !toeInput || !label) return;

            const mode = bottomSel.value;

            if (mode === "toe-kick") {
                label.textContent = "toe kick height (in)";
                toeInput.min = 2.5;
                toeInput.max = 7;

                // if current value is out of toe-kick range, reset to default 4"
                let v = Number(toeInput.value);
                if (!v || v < 2.5 || v > 7) {
                    toeInput.value = 4;
                }
            } else {
                label.textContent = "open below height (in)";
                toeInput.min = 2.5;
                toeInput.max = 24;

                // leave value as-is if present; otherwise start at 4"
                let v = Number(toeInput.value);
                if (!v) toeInput.value = 4;
            }
        }

        function updateBottomControlsVisibility() {
            const floatingSel = document.getElementById("floating");
            const bottomField = document.getElementById("bottomDetailField");
            const heightField = document.getElementById("bottomHeightField");

            if (!floatingSel || !bottomField || !heightField) return;

            const isFloating = floatingSel.value === "true";

            // hide both controls when floating
            if (isFloating) {
                bottomField.style.display = "none";
                heightField.style.display = "none";
            } else {
                bottomField.style.display = "";
                heightField.style.display = "";
            }
        }

        function enforceMinWidth() {
            const widthInput = document.getElementById("width");
            const widthError = document.getElementById("widthError");
            if (!widthInput || !widthError) return;

            let v = Number(widthInput.value);

            // If empty or NaN, clear the error and bail (user hasn't really entered anything yet)
            if (!v && v !== 0) {
                widthError.textContent = "";
                return;
            }

            if (v < MIN_WIDTH_IN) {
                // clamp to 18" and show an error
                widthInput.value = MIN_WIDTH_IN;
                widthError.textContent = `minimum width is ${MIN_WIDTH_IN}"`;
            } else {
                // valid â†’ clear message
                widthError.textContent = "";
            }
        }

        function applyDoorDrawerPreset(preset) {
            const doorSel = document.getElementById("doorStyle");
            const drawerSel = document.getElementById("drawerStyle");
            if (!doorSel || !drawerSel) return;

            switch (preset) {
                case "slab":
                    doorSel.value = "slab";
                    drawerSel.value = "slab";
                    break;

                case "shaker":
                    doorSel.value = "shaker";
                    drawerSel.value = "shaker";
                    break;

                case "double-shaker":
                    doorSel.value = "double-shaker";
                    drawerSel.value = "double-shaker";
                    break;

                case "slab-shaker":
                    // doors = shaker, drawers = slab top + shaker combo
                    doorSel.value = "shaker";
                    drawerSel.value = "slab-shaker";
                    break;

                case "slab-double-shaker":
                    // doors = double shaker, drawers = slab top + double shaker combo
                    doorSel.value = "double-shaker";
                    drawerSel.value = "slab-double-shaker";
                    break;

                default:
                    // safety fallback â€“ do nothing
                    break;
            }
        }

        function updateSinkPositionVisibility() {
            const widthField = document.getElementById("width");
            const sinkCountEl = document.getElementById("sinkCount");
            const sinkPosWrap = document.getElementById("sinkPositionField");
            const sinkPosSel = document.getElementById("sinkPosition");

            if (!widthField || !sinkCountEl || !sinkPosWrap) return;

            const widthIn = Number(widthField.value) || 0;
            const sinkCount = Number(sinkCountEl.value) || 0;

            // only show when:
            //  - exactly 1 sink
            //  - width between 30" and 115"
            const show =
                sinkCount === 1 &&
                widthIn >= 30 &&
                widthIn <= 115;

            sinkPosWrap.style.display = show ? "" : "none";

            // when hidden, force value back to "center" so model stays sane
            if (!show && sinkPosSel) {
                sinkPosSel.value = "center";
            }
        }

        function updateMobileDrawingVisibility() {
            const shell = document.getElementById("mobile-drawing-shell");
            if (!shell) return;

            const activePageId = document.querySelector(".page.active")?.id || "page1";

            // hide on page1 + page2 only
            const hide = (activePageId === "page1" || activePageId === "page2");

            shell.style.display = hide ? "none" : "flex";
        }




        function getFinalDrawerLayoutForSection(model, sectionIndex, openingHpx) {
            const px = model.scale.inchToPx;

            const base = computeDrawerLayout(
                openingHpx,
                px,
                model.topDrawerHeightPreset || "equal",
                model.drawerRailsMode || "none",
                model.drawerRailHeightIn ?? DEFAULT_DRAWER_RAIL_HEIGHT_IN,
                model
            );

            // apply override
            const overridden = getDrawerCountForSection(
                model,
                sectionIndex,
                base.drawerCount
            );

            // clamp by min face height
            const MIN_FACE_IN = 5;
            const maxDrawers = Math.floor((openingHpx / px) / MIN_FACE_IN);
            const finalCount = Math.max(1, Math.min(overridden, maxDrawers));

            // force drawer count
            base.drawerCount = finalCount;

            // force rail count
            if (base.mode === "all") {
                base.railCount = Math.max(finalCount - 1, 0);
            } else if (base.mode === "top") {
                base.railCount = finalCount > 1 ? 1 : 0;
            } else {
                base.railCount = 0;
            }

            // recompute heights AFTER rails, preserving top drawer intent
            const totalRailPx = base.railHeightPx * base.railCount;
            const usablePx = openingHpx - totalRailPx;

            // apply top drawer logic only when 3+ drawers
            if (finalCount >= 3) {
                const rawHeights = computeDrawerRowHeightsPx(
                    usablePx,
                    px,
                    model.topDrawerHeightPreset || "equal"
                );

                // safety clamp in case preset returns wrong count
                if (rawHeights.length === finalCount) {
                    base.heightsPx = rawHeights;
                } else {
                    base.heightsPx = Array(finalCount).fill(usablePx / finalCount);
                }
            } else {
                // 1â€“2 drawers â†’ always equal
                base.heightsPx = Array(finalCount).fill(usablePx / finalCount);
            }


            return base;
        }


        function updateStileAndRailControlsVisibility(model) {
            const sections = model.sections || [];
            const sectionCount = sections.length;
            const isSingleSection = sectionCount === 1;

            const removeStilesField = document.getElementById("removeStilesField");
            const removeStilesSel = document.getElementById("removeStiles");
            const stileWidthField = document.getElementById("frameStileWidthField");

            const railsModeField = document.getElementById("drawerRailsModeField");
            const railsModeSel = document.getElementById("drawerRailsMode");
            const railHeightField = document.getElementById("drawerRailHeightField");

            // âœ… Always enforce the simplest rule first:
            // Single-section â†’ stile UI does not apply.
            if (isSingleSection) {
                if (removeStilesField) removeStilesField.style.display = "none";
                if (stileWidthField) stileWidthField.style.display = "none";

                // rails are allowed; only show if the fields exist
                if (railsModeField) railsModeField.style.display = "";
                if (railsModeSel && railHeightField) {
                    const mode = railsModeSel.value || "none";
                    railHeightField.style.display = (mode === "none") ? "none" : "";
                }
                return;
            }

            // multi-section vanity
            if (removeStilesField) removeStilesField.style.display = "";

            const stilesRemoved = (removeStilesSel && removeStilesSel.value === "true");

            // ðŸ”’ HARD RULE: multi-section + no stiles â†’ rails MUST be none
            if (stilesRemoved && railsModeSel) {
                if (railsModeSel.value !== "none") {
                    railsModeSel.value = "none";
                }
            }

            // stile width visible only when stiles are present
            if (stileWidthField) {
                stileWidthField.style.display = stilesRemoved ? "none" : "";
            }

            const drawerRailsNote = document.getElementById("drawerRailsNote");
            if (drawerRailsNote) {
                drawerRailsNote.style.display =
                    (stilesRemoved && railsModeBeforeStilesOff !== "none")
                        ? "block"
                        : "none";
            }

            // rails controls only meaningful when we have stiles
            if (stilesRemoved) {
                if (railsModeField) railsModeField.style.display = "none";
                if (railHeightField) railHeightField.style.display = "none";
            } else {
                if (railsModeField) railsModeField.style.display = "";
                if (railsModeSel && railHeightField) {
                    const mode = railsModeSel.value || "none";
                    railHeightField.style.display = (mode === "none") ? "none" : "";
                }
            }
        }

        function updatePriceDisplay(model) {
            const price = computeCurrentPrice(model);
            const formatted = `$${price.toLocaleString()}`;

            // pinned drawing price
            const priceValue = document.getElementById("price-value");
            if (priceValue) {
                priceValue.textContent = formatted;
            }
        }


        function openPriceModal(model) {
            const modal = document.getElementById("price-modal");
            const content = document.getElementById("price-breakdown-content");

            if (!modal || !content) return;

            const breakdown = computePriceBreakdown(model);

            let html = `
        <div class="price-line">
            <span>base price</span>
            <span>$${breakdown.base.toLocaleString()}</span>
        </div>
    `;

            if (breakdown.extras.length) {
                breakdown.extras.forEach(item => {
                    html += `
                <div class="price-line extra">
                    <span>${item.label}</span>
                    <span>+$${item.amount.toLocaleString()}</span>
                </div>
            `;
                });
            }

            html += `
        <div class="price-line price-total">
            <span>total</span>
            <span>$${breakdown.total.toLocaleString()}</span>
        </div>
    `;

            content.innerHTML = html;
            modal.classList.remove("hidden");
        }

        function updateMakeupDeskControlsVisibility() {
            const enabledSel = document.getElementById("makeupDeskEnabled");
            const posField = document.getElementById("makeupDeskPositionField");
            const widthField = document.getElementById("makeupDeskWidthField");
            const heightField = document.getElementById("makeupDeskHeightField");

            if (!enabledSel || !posField || !widthField || !heightField) return;

            const on = enabledSel.value === "yes";

            posField.style.display = on ? "block" : "none";
            widthField.style.display = on ? "block" : "none";
            heightField.style.display = on ? "block" : "none";
        }

        function formatInchesFraction(val) {
            const negative = val < 0;
            let v = Math.abs(val);

            let sixteenths = Math.round(v * 16);
            const whole = Math.floor(sixteenths / 16);
            let rem = sixteenths % 16;

            if (rem === 0) {
                const base = String(whole);
                return negative ? "-" + base : base;
            }

            function gcd(a, b) {
                while (b !== 0) {
                    const t = a % b;
                    a = b;
                    b = t;
                }
                return a;
            }

            let denom = 16;
            const g = gcd(rem, denom);
            rem /= g;
            denom /= g;

            const frac = `${rem}/${denom}`;
            const result = whole === 0 ? frac : `${whole} ${frac}`;
            return negative ? "-" + result : result;
        }


        function setupDrawingEngine() {
            ensureSvgSetup();

            if (drawingEngineInitialized) return;
            drawingEngineInitialized = true;

            // âœ… Clear selected section when user focuses any form field (so highlight doesn't stick)
            if (!window.__vbClearSectionOnFocus) {
                window.__vbClearSectionOnFocus = true;

                document.addEventListener("focusin", (e) => {
                    const t = e.target;
                    if (!t) return;

                    const tag = (t.tagName || "").toUpperCase();
                    if (tag !== "INPUT" && tag !== "SELECT" && tag !== "TEXTAREA") return;

                    // don't clear when focusing anything inside the drawing area / mobile bar
                    if (t.closest("#drawing-panel") || t.closest("#mobile-drawing-bar")) return;

                    if (selectedSectionIndex != null) {
                        selectedSectionIndex = null;
                        updateDrawing();
                    }
                });
            }


            // =====================================================
            // 1) APPLY ALL DEFAULT VALUES BEFORE ANYTHING ELSE
            // =====================================================

            const legInput = document.getElementById("frameLegWidth");
            const stileInput = document.getElementById("frameStileWidth");
            const topRailInput = document.getElementById("frameTopRailHeight");
            const bottomRailInput = document.getElementById("frameBottomRailHeight");
            const toeInput = document.getElementById("toeKickHeight");
            const bottomSel = document.getElementById("bottomDetail");

            const drawerRailHeightField = document.getElementById("drawerRailHeightField");
            const drawerRailsNote = document.getElementById("drawerRailsNote");


            if (legInput && !legInput.value) legInput.value = FRAME_DEFAULTS.legWidthIn;
            if (stileInput && !stileInput.value) stileInput.value = FRAME_DEFAULTS.stileWidthIn;
            if (topRailInput && !topRailInput.value) topRailInput.value = FRAME_DEFAULTS.topRailHeightIn;
            if (bottomRailInput && !bottomRailInput.value) bottomRailInput.value = FRAME_DEFAULTS.bottomRailHeightIn;

            if (toeInput) {
                if (!toeInput.value) toeInput.value = 4;
                toeInput.step = 0.25;
            }

            function syncDrawerRailsUI() {
                if (!drawerRailsModeSel || !drawerRailHeightField) return;
                const mode = drawerRailsModeSel.value || "none";

                // show height field only when rails are on
                drawerRailHeightField.style.display = (mode === "none" ? "none" : "");

                // the blue note is only for the moment we *kill* rails because of stiles,
                // so normal mode changes should hide it.
                if (drawerRailsNote && mode !== "none") {
                    drawerRailsNote.style.display = "none";
                }
            }


            // rails between drawers: defaults
            const drawerRailsModeSel = document.getElementById("drawerRailsMode");
            const drawerRailHeightInput = document.getElementById("drawerRailHeightIn");

            if (drawerRailsModeSel && !drawerRailsModeSel.value) {
                drawerRailsModeSel.value = "none";
            }
            if (drawerRailHeightInput && !drawerRailHeightInput.value) {
                drawerRailHeightInput.value = String(DEFAULT_DRAWER_RAIL_HEIGHT_IN);
            }



            const shelfBelowSel = document.getElementById("shelfBelow");
            const shelfSpaceInput = document.getElementById("shelfSpaceIn");

            // defaults
            if (shelfBelowSel && !shelfBelowSel.value) {
                shelfBelowSel.value = "no";
            }
            if (shelfSpaceInput && !shelfSpaceInput.value) {
                shelfSpaceInput.value = 8;
            }

            function updateShelfControlsVisibility() {
                const fld = document.getElementById("shelfSpaceField");
                const thickFld = document.getElementById("shelfThicknessField");
                if (!fld || !thickFld) return;

                const shelfBelow = shelfBelowSel.value === "yes";
                fld.style.display = shelfBelow ? "block" : "none";
                thickFld.style.display = shelfBelow ? "block" : "none";
            }


            // ðŸ”¥ CALL IT ONCE so page loads correctly
            updateShelfControlsVisibility();

            // ðŸ”¥ RUN IT AGAIN every time the dropdown changes
            shelfBelowSel.addEventListener("change", () => {
                updateShelfControlsVisibility();
                updateDrawing();
            });

            const makeupDeskEnabledSel = document.getElementById("makeupDeskEnabled");
            const makeupDeskPositionSel = document.getElementById("makeupDeskPosition");
            const makeupDeskWidthInput = document.getElementById("makeupDeskWidth");
            const makeupDeskHeightInput = document.getElementById("makeupDeskHeight");

            if (makeupDeskEnabledSel && !makeupDeskEnabledSel.value) {
                makeupDeskEnabledSel.value = "no";
            }
            if (makeupDeskPositionSel && !makeupDeskPositionSel.value) {
                makeupDeskPositionSel.value = "center";
            }
            if (makeupDeskWidthInput && !makeupDeskWidthInput.value) {
                makeupDeskWidthInput.value = 26;
            }
            if (makeupDeskHeightInput && !makeupDeskHeightInput.value) {
                makeupDeskHeightInput.value = 4;
            }


            // =====================================================
            // 2) SYNC ALL DEPENDENT UI
            // =====================================================
            syncBottomHeightLabelAndLimits();

            // These MUST run NOW, BEFORE first draw.
            updateLayoutOptions();
            updateBottomControlsVisibility();
            updateSinkCountOptions();
            updateSinkPositionVisibility();
            syncDrawerRailsUI();
            updateMakeupDeskControlsVisibility();


            const presetSel = document.getElementById("doorDrawerPreset");
            if (presetSel && presetSel.value) {
                applyDoorDrawerPreset(presetSel.value);
            }


            // =====================================================
            // 3) RESET DRAWER OVERRIDE FLAGS FOR A CLEAN START
            // =====================================================
            drawerOverrideFlags.single = false;
            drawerOverrideFlags.outer = false;
            drawerOverrideFlags.center = false;
            drawerOverrideFlags.twoSection = false;  // ðŸ‘ˆ new

            const singleInput = document.getElementById("drawerWidthSingle");
            const outerInput = document.getElementById("drawerWidthOuter");
            const centerInput = document.getElementById("drawerWidthCenter");
            const twoSectionInput = document.getElementById("drawerWidthTwoSection"); // ðŸ‘ˆ new

            if (singleInput) singleInput.value = "";
            if (outerInput) outerInput.value = "";
            if (centerInput) centerInput.value = "";
            if (twoSectionInput) twoSectionInput.value = ""; // ðŸ‘ˆ new



            // âš ï¸ ARCHITECTURE RULE:
            // UI â†’ computeModel â†’ computeGeometry â†’ draw
            // Never skip layers.

            // =====================================================
            // 4) ATTACH LISTENERS ONLY AFTER UI IS READY
            // =====================================================
            const ids = [
                "width",
                "height",
                "depth",
                "floating",
                "sinkCount",
                "sinkPosition",
                "toeKickHeight",
                "bottomDetail",
                "frameLegWidth",
                "frameTopRailHeight",
                "frameBottomRailHeight",
                "frameStileWidth",
                "removeTopRail",
                "removeBottomRail",
                "removeStiles",
                "layoutPreset",
                "visibleSides",
                "doorDrawerPreset",
                "doorStyle",
                "drawerStyle",
                "topDrawerHeightPreset",
                "drawerWidthSingle",
                "drawerWidthOuter",
                "drawerWidthCenter",
                "drawerWidthTwoSection",
                "shelfBelow",
                "shelfSpaceIn",
                "shelfThickness",
                // ðŸ”¹ NEW:
                "drawerRailsMode",
                "drawerRailHeightIn",
                "makeupDeskEnabled",
                "makeupDeskPosition",
                "makeupDeskWidth",
                "makeupDeskHeight"

            ];





            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;

                const handler = (evt) => {
                    if (id === "drawerWidthSingle") {
                        drawerOverrideFlags.single = true;
                        lastDrawerEdited = "single";
                    } else if (id === "drawerWidthOuter") {
                        drawerOverrideFlags.outer = true;
                        lastDrawerEdited = "outer";
                    } else if (id === "drawerWidthCenter") {
                        drawerOverrideFlags.center = true;
                        lastDrawerEdited = "center";
                    } else if (id === "drawerWidthTwoSection") {
                        drawerOverrideFlags.twoSection = true;
                        lastDrawerEdited = "twoSection";
                    }
                    if (id === "drawerRailsMode") {
                        syncDrawerRailsUI();
                    }
                    if (id === "makeupDeskEnabled") {
                        updateMakeupDeskControlsVisibility();
                    }


                    // layout changes reset drawer overrides
                    if (
                        id === "width" ||
                        id === "sinkCount" ||
                        id === "layoutPreset" ||
                        id === "sinkPosition"
                    ) {
                        drawerOverrideFlags.single = false;
                        drawerOverrideFlags.outer = false;
                        drawerOverrideFlags.center = false;
                        drawerOverrideFlags.twoSection = false;

                        if (singleInput) singleInput.value = "";
                        if (outerInput) outerInput.value = "";
                        if (centerInput) centerInput.value = "";
                        const twoInput = document.getElementById("drawerWidthTwoSection");
                        if (twoInput) twoInput.value = "";
                    }


                    // width / sinkCount / sinkPosition all affect which layouts are valid
                    if (id === "width" || id === "sinkCount" || id === "sinkPosition") {
                        updateLayoutOptions();
                    }

                    // ONLY width affects which sink counts are allowed
                    if (id === "width") {
                        updateSinkCountOptions();
                    }

                    // show/hide the sink-position dropdown when width or sinkCount changes
                    if (id === "width" || id === "sinkCount") {
                        updateSinkPositionVisibility();
                    }

                    if (id === "bottomDetail") {
                        syncBottomHeightLabelAndLimits();
                    }

                    if (id === "removeStiles") {
                        const stileWidthField = document.getElementById("frameStileWidthField");
                        const drawerRailsNote = document.getElementById("drawerRailsNote");
                        const drawerRailsModeSel = document.getElementById("drawerRailsMode");
                        const drawerRailHeightField = document.getElementById("drawerRailHeightField");

                        const turningStilesOff = (evt.target.value === "true");

                        if (turningStilesOff) {
                            // what rails mode did we have *before* killing it?
                            const prevMode = drawerRailsModeSel ? drawerRailsModeSel.value : "none";
                            const hadRailsBefore = prevMode === "top" || prevMode === "all";

                            // remember it globally so we can restore later
                            railsModeBeforeStilesOff = hadRailsBefore ? prevMode : "none";

                            // hide stile width field
                            if (stileWidthField) stileWidthField.style.display = "none";

                            // kill rails in the UI (drawing will follow because computeModel reads this)
                            if (drawerRailsModeSel) {
                                drawerRailsModeSel.value = "none";
                            }
                            if (drawerRailHeightField) {
                                drawerRailHeightField.style.display = "none";
                            }

                            // show blue note only if we actually had rails before
                            if (drawerRailsNote) {
                                drawerRailsNote.style.display = hadRailsBefore ? "block" : "none";
                            }

                            // keep rails UI in sync
                            if (typeof syncDrawerRailsUI === "function") {
                                syncDrawerRailsUI();
                            }
                        } else {
                            // turning stiles back ON
                            if (stileWidthField) stileWidthField.style.display = "";
                            if (drawerRailsNote) drawerRailsNote.style.display = "none";

                            if (drawerRailsModeSel) {
                                // only restore if we truly had rails before
                                if (railsModeBeforeStilesOff === "top" || railsModeBeforeStilesOff === "all") {
                                    drawerRailsModeSel.value = railsModeBeforeStilesOff;
                                    if (drawerRailHeightField) {
                                        drawerRailHeightField.style.display = "";
                                    }
                                } else {
                                    // there were no rails originally â†’ stay at none
                                    drawerRailsModeSel.value = "none";
                                    if (drawerRailHeightField) {
                                        drawerRailHeightField.style.display = "none";
                                    }
                                }
                            }

                            if (typeof syncDrawerRailsUI === "function") {
                                syncDrawerRailsUI();
                            }
                        }

                        // IMPORTANT: do NOT `return` here.
                        // We want to still fall through to the `updateDrawing();` at the bottom.
                    }



                    if (id === "floating") {
                        updateBottomControlsVisibility();
                    }

                    if (id === "shelfBelow") {
                        updateShelfControlsVisibility();
                    }

                    if (id === "shelfSpaceIn") {
                        // clamp 6â€“12 and snap the field
                        if (shelfSpaceInput) {
                            let v = Number(shelfSpaceInput.value);
                            if (!v || !isFinite(v)) v = 8;
                            if (v < 6) v = 6;
                            if (v > 12) v = 12;
                            shelfSpaceInput.value = v;
                        }
                    }

                    if (id === "toeKickHeight") {
                        let v = Number(toeInput.value);
                        if (!v) v = 4;

                        if (v < 2.5) v = 2.5;
                        if (v > 24) v = 24;
                        toeInput.value = v;

                        if (bottomSel.value === "toe-kick" && v > 7) {
                            bottomSel.value = "open-below";
                            syncBottomHeightLabelAndLimits();
                        }
                    }

                    // ðŸ”¹ NEW: when preset changes, sync door + drawer styles
                    if (id === "doorDrawerPreset") {
                        applyDoorDrawerPreset(evt.target.value);
                    }
                    // only enforce the 18" minimum *after* they're done typing
                    if (id === "width" && evt.type === "change") {
                        enforceMinWidth();
                    }

                    updateDrawing();
                };

                const isDrawerWidth =
                    id === "drawerWidthSingle" ||
                    id === "drawerWidthOuter" ||
                    id === "drawerWidthCenter" ||
                    id === "drawerWidthTwoSection";

                const useChangeOnly = (
                    isDrawerWidth ||
                    el.tagName === "SELECT" ||
                    el.type === "checkbox" ||
                    el.type === "radio"
                );

                // ðŸ”‘ For drawer widths:
                // - "input" sets override flags immediately (prevents sync from overwriting while typing)
                // - "change" triggers recompute + draw once the user commits
                if (isDrawerWidth) {
                    el.addEventListener("input", (evt) => {
                        if (id === "drawerWidthSingle") {
                            drawerOverrideFlags.single = true;
                            lastDrawerEdited = "single";
                        } else if (id === "drawerWidthOuter") {
                            drawerOverrideFlags.outer = true;
                            lastDrawerEdited = "outer";
                        } else if (id === "drawerWidthCenter") {
                            drawerOverrideFlags.center = true;
                            lastDrawerEdited = "center";
                        } else if (id === "drawerWidthTwoSection") {
                            drawerOverrideFlags.twoSection = true;
                            lastDrawerEdited = "twoSection";
                        }
                        // IMPORTANT: no updateDrawing() here
                    });
                }

                // Keep your main handler exactly as-is, but now drawer widths redraw on "change"
                el.addEventListener(useChangeOnly ? "change" : "input", handler);


            });


            // =====================================================
            // GLOBAL CLICK â€” clear section selection
            // =====================================================
            document.addEventListener("click", (e) => {
                // --- price modal open/close ---
                const modal = document.getElementById("price-modal");
                if (modal) {
                    if (e.target.closest("#price-button")) {
                        const model = computeModel();
                        openPriceModal(model);
                        return;
                    }

                    if (
                        e.target.classList.contains("price-modal-backdrop") ||
                        e.target.classList.contains("price-modal-close")
                    ) {
                        modal.classList.add("hidden");
                        return;
                    }
                }

                // don't treat taps on the mobile bar/buttons as "outside click"
                if (e.target.closest("#mobile-drawing-bar")) {
                    return;
                }


                // --- clear section selection when clicking outside hit targets ---
                if (
                    selectedSectionIndex !== null &&
                    !e.target.closest("input, select, button, label")
                ) {
                    selectedSectionIndex = null;
                    updateDrawing();
                }

            });

            // =====================================================
            // ðŸ”’ MOBILE SCROLL: prevent restore-to-middle on load/back
            // =====================================================
            if (!window.__vbScrollInit) {
                window.__vbScrollInit = true;

                // stop browser from restoring old scroll position (mobile Safari especially)
                if ("scrollRestoration" in history) {
                    history.scrollRestoration = "manual";
                }

                const resetAllScroll = () => {
                    window.scrollTo(0, 0);
                    document.documentElement.scrollTop = 0;
                    document.body.scrollTop = 0;

                    const pageContainer = document.getElementById("page-container");
                    if (pageContainer) pageContainer.scrollTop = 0;

                    const mobileStep = document.getElementById("mobile-step-container");
                    if (mobileStep) mobileStep.scrollTop = 0;
                };

                // initial load
                window.addEventListener("load", () => {
                    resetAllScroll();
                    requestAnimationFrame(resetAllScroll);
                });

                // back/forward cache restore
                window.addEventListener("pageshow", () => {
                    resetAllScroll();
                    requestAnimationFrame(resetAllScroll);
                });
            }



            // =====================================================
            // 5) FINAL â€” FIRST DRAW MUST HAPPEN AFTER ALL SETUP
            // =====================================================
            initialDrawDone = true;
            updateDrawing();
            syncGlobalNavState();
            syncUIState("page1");


        }

        function setupFinishPage() {
            const finishType = document.getElementById("finishType");

            // These now refer to *all fields* with those classes
            const woodFields = document.querySelectorAll(".wood-field");
            const paintFields = document.querySelectorAll(".paint-field");

            const paintFinish = document.getElementById("paintFinish");
            const customColorField = document.getElementById("customColorField");
            const primerColorField = document.getElementById("primerColorField");

            if (!finishType) return;

            // Helper to show/hide groups
            function setDisplay(nodes, value) {
                nodes.forEach(n => n.style.display = value);
            }

            // MAIN FINISH SWITCH
            finishType.addEventListener("change", () => {
                const val = finishType.value;

                // hide everything first
                setDisplay(woodFields, "none");
                setDisplay(paintFields, "none");

                // show only the category
                if (val === "wood") {
                    setDisplay(woodFields, "flex");
                }
                if (val === "paint") {
                    setDisplay(paintFields, "flex");
                }

                // always hide subfields
                if (customColorField) customColorField.style.display = "none";
                if (primerColorField) primerColorField.style.display = "none";
            });

            // PAINT FINISH SUB OPTIONS
            if (paintFinish) {
                paintFinish.addEventListener("change", () => {
                    const val = paintFinish.value;

                    if (customColorField) customColorField.style.display = "none";
                    if (primerColorField) primerColorField.style.display = "none";

                    if (val === "custom") {
                        customColorField.style.display = "flex";
                    }
                    if (val === "primed") {
                        primerColorField.style.display = "flex";
                    }
                });
            }
        }

        window.addEventListener("load", setupFinishPage);

        // =====================================================
        // MOBILE PINCH + PAN FOR DRAWING (CSS TRANSFORM ONLY)
        // =====================================================

        let mobileScale = 1;
        let mobileTranslateX = 0;
        let mobileTranslateY = 0;

        let lastTouchDist = null;
        let lastTouchMid = null;

        function applyMobileTransform() {
            const svg = getActiveDrawingSvg ? getActiveDrawingSvg() : document.getElementById("vanityDrawing");
            if (!svg) return;

            const isMobile = window.matchMedia("(max-width: 768px)").matches;

            // Prefer stable wrapper if present
            const g = svg.querySelector("#mobileViewport");
            const target = g || svg;

            if (!isMobile) {
                target.style.transform = "";
                target.style.transformOrigin = "";
                return;
            }

            // IMPORTANT: stable origin so midpoint math stays correct
            target.style.transformOrigin = "0 0";
            target.style.transform =
                `translate(${mobileTranslateX}px, ${mobileTranslateY}px) scale(${mobileScale})`;
        }


        // Recenter expanded drawing when the *visible* viewport changes (rotation / URL bar)
        if (window.visualViewport) {
            window.visualViewport.addEventListener("resize", () => {
                if (!document.body.classList.contains("drawing-expanded")) return;

                mobileScale = 1;
                mobileTranslateX = 0;
                mobileTranslateY = 0;

                if (typeof applyMobileTransform === "function") applyMobileTransform();
            });
        }


        function getTouchDistance(t1, t2) {
            const dx = t2.clientX - t1.clientX;
            const dy = t2.clientY - t1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchMidpoint(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }


        function setupMobileDrawingGestures() {
            const svg = document.getElementById("vanityDrawing");
            if (!svg) return;

            let lastOneFinger = null;

            svg.addEventListener("touchstart", (e) => {
                if (e.touches.length === 1) {
                    lastOneFinger = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }

                if (e.touches.length === 2) {
                    lastTouchDist = getTouchDistance(e.touches[0], e.touches[1]);
                    lastTouchMid = getTouchMidpoint(e.touches[0], e.touches[1]);
                }
            }, { passive: false });

            svg.addEventListener("touchmove", (e) => {
                // 1-finger pan
                if (e.touches.length === 1 && lastOneFinger) {
                    e.preventDefault();

                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;

                    mobileTranslateX += (x - lastOneFinger.x);
                    mobileTranslateY += (y - lastOneFinger.y);

                    lastOneFinger = { x, y };
                    applyMobileTransform();
                    return;
                }

                // 2-finger pinch zoom anchored to the midpoint (Photos-style)
                if (e.touches.length === 2) {
                    e.preventDefault();

                    const rect = svg.getBoundingClientRect();
                    if (!rect.width || !rect.height) return;

                    const newDist = getTouchDistance(e.touches[0], e.touches[1]);
                    const newMid = getTouchMidpoint(e.touches[0], e.touches[1]);

                    if (!lastTouchDist || !lastTouchMid) {
                        lastTouchDist = newDist;
                        lastTouchMid = newMid;
                        return;
                    }

                    // Midpoints in element-local pixels
                    const lastMidLocal = {
                        x: lastTouchMid.x - rect.left,
                        y: lastTouchMid.y - rect.top
                    };
                    const newMidLocal = {
                        x: newMid.x - rect.left,
                        y: newMid.y - rect.top
                    };

                    // Content point under the *last* midpoint (in transformed space)
                    const uX = (lastMidLocal.x - mobileTranslateX) / mobileScale;
                    const uY = (lastMidLocal.y - mobileTranslateY) / mobileScale;

                    // New scale (clamped)
                    const scaleDelta = newDist / lastTouchDist;
                    const nextScale = Math.max(0.5, Math.min(3, mobileScale * scaleDelta));

                    // Keep same content point under the *new* midpoint
                    mobileTranslateX = newMidLocal.x - (uX * nextScale);
                    mobileTranslateY = newMidLocal.y - (uY * nextScale);
                    mobileScale = nextScale;

                    lastTouchDist = newDist;
                    lastTouchMid = newMid;

                    applyMobileTransform();
                }
            }, { passive: false });

            svg.addEventListener("touchend", (e) => {
                if (!e.touches || e.touches.length === 0) {
                    lastOneFinger = null;
                }
                if (!e.touches || e.touches.length < 2) {
                    lastTouchDist = null;
                    lastTouchMid = null;
                }
            });
        }


        function setupQuarterInchSteppers() {
            const wraps = Array.from(document.querySelectorAll(".stepper-input"));
            if (!wraps.length) return;

            const snapQ = (n) => {
                const x = Number(n);
                if (!isFinite(x)) return null;
                return Math.round(x * 4) / 4;
            };

            function isDrawerWidth(id) {
                return (
                    id === "drawerWidthSingle" ||
                    id === "drawerWidthOuter" ||
                    id === "drawerWidthCenter" ||
                    id === "drawerWidthTwoSection"
                );
            }

            function markDrawerOverride(id) {
                if (typeof drawerOverrideFlags === "undefined") return;
                if (id === "drawerWidthSingle") { drawerOverrideFlags.single = true; lastDrawerEdited = "single"; }
                if (id === "drawerWidthOuter") { drawerOverrideFlags.outer = true; lastDrawerEdited = "outer"; }
                if (id === "drawerWidthCenter") { drawerOverrideFlags.center = true; lastDrawerEdited = "center"; }
                if (id === "drawerWidthTwoSection") { drawerOverrideFlags.twoSection = true; lastDrawerEdited = "twoSection"; }
            }

            // Seed from current model (only if field is blank)
            function seedFromModel(inputId) {
                try {
                    if (typeof computeModel !== "function") return null;
                    const m = computeModel();
                    const secs = m?.sections || [];
                    const n = secs.length;
                    if (!n) return null;

                    const drawers = secs
                        .map((sec, idx) => ({ sec, idx }))
                        .filter(d => d.sec?.role === "drawer");

                    if (!drawers.length) return null;

                    const s = (v) => {
                        const q = snapQ(v);
                        return (q != null && q > 0) ? q : null;
                    };

                    if (inputId === "drawerWidthTwoSection" && n === 2 && drawers.length === 1) {
                        return s(drawers[0].sec.widthIn);
                    }

                    if (inputId === "drawerWidthSingle" && n === 3) {
                        return s(drawers[0].sec.widthIn);
                    }

                    if (n === 5 || (n === 3 && drawers.length === 3)) {
                        if (inputId === "drawerWidthOuter") {
                            const outer = drawers.find(d => d.idx === 0) || drawers.find(d => d.idx === n - 1) || drawers[0];
                            return outer ? s(outer.sec.widthIn) : null;
                        }
                        if (inputId === "drawerWidthCenter") {
                            const center = drawers.find(d => d.idx !== 0 && d.idx !== n - 1) || drawers[0];
                            return center ? s(center.sec.widthIn) : null;
                        }
                    }

                    return null;
                } catch {
                    return null;
                }
            }

            // bind once
            wraps.forEach((wrap) => {
                if (wrap.dataset.stepperBound === "1") return;
                wrap.dataset.stepperBound = "1";

                const input = wrap.querySelector("input");
                if (!input) return;

                const stepAttr = wrap.getAttribute("data-step");
                const step = (stepAttr != null && stepAttr !== "") ? Number(stepAttr) : 0.25;

                // SNAP ON BLUR (manual typing)
                input.addEventListener("blur", () => {
                    const raw = String(input.value ?? "").trim();
                    if (raw === "") return;

                    const snapped = snapQ(raw);
                    if (snapped == null) return;

                    input.value = String(snapped);
                    markDrawerOverride(input.id);

                    input.dispatchEvent(
                        new Event(isDrawerWidth(input.id) ? "change" : "input", { bubbles: true })
                    );
                });

                // STEPPER BUTTONS
                wrap.querySelectorAll(".stepper-btn").forEach((btn) => {
                    btn.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const dir = Number(btn.getAttribute("data-dir"));
                        if (!isFinite(dir) || dir === 0) return;

                        const raw = String(input.value ?? "").trim();
                        let base = parseFloat(raw);

                        if (!isFinite(base)) {
                            const seed = seedFromModel(input.id);
                            base = (seed != null) ? Number(seed) : NaN;
                        }
                        if (!isFinite(base)) base = 0;

                        const next = base + dir * (isFinite(step) && step > 0 ? step : 0.25);
                        const snapped = snapQ(next);
                        if (snapped == null) return;

                        input.value = String(snapped);
                        markDrawerOverride(input.id);

                        input.dispatchEvent(
                            new Event(isDrawerWidth(input.id) ? "change" : "input", { bubbles: true })
                        );
                    });
                });
            });
        }

        function setupMobileDrawingBarHandlers() {
            const expandBtn = document.getElementById("mobile-expand-button");     // "full screen"
            const toggleBtn = document.getElementById("mobile-minimize-button");   // minimize/expand toggle
            const priceBtn = document.getElementById("mobile-price-button");
            const closeBtn = document.getElementById("mobile-expand-close");

            if (!expandBtn || !toggleBtn || !priceBtn) return;

            function setExpanded(on) {
                const svg = (typeof getActiveDrawingSvg === "function")
                    ? getActiveDrawingSvg()
                    : document.getElementById("vanityDrawing");

                if (svg) {
                    if (on) {
                        // âœ… keep: lock expanded redraw to the last non-expanded effective px
                        const lastPx = Number(svg.dataset.lastEffectivePx);
                        if (isFinite(lastPx) && lastPx > 0) {
                            svg.dataset.lockedEffectivePx = String(lastPx);
                        }
                    } else {
                        // leaving expanded â†’ clear lock
                        if (svg.dataset.lockedEffectivePx) delete svg.dataset.lockedEffectivePx;
                    }
                }

                document.body.classList.toggle("drawing-expanded", !!on);

                // do NOT reset mobileScale/mobileTranslate
                requestAnimationFrame(() => {
                    if (typeof applyMobileTransform === "function") applyMobileTransform();
                });
            }

            function setMinimized(on) {
                document.body.classList.toggle("drawing-minimized", !!on);

                // keep ALL THREE buttons visible
                toggleBtn.textContent = on ? "expand" : "minimize";

                // âœ… when expanding again, force a redraw if we skipped while minimized
                if (!on) {
                    requestAnimationFrame(() => {
                        const svg = getActiveDrawingSvg();
                        if (svg && svg.dataset.needsRedrawOnExpand === "1") {
                            delete svg.dataset.needsRedrawOnExpand;
                            updateDrawing();
                        }
                    });
                }
            }


            // default state: NOT minimized
            setMinimized(false);

            toggleBtn.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();

                const isMin = document.body.classList.contains("drawing-minimized");
                setMinimized(!isMin);
            });

            expandBtn.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                setExpanded(true);
            });

            if (closeBtn) {
                closeBtn.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setExpanded(false);
                });
            }

            priceBtn.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                const model = computeModel();
                openPriceModal(model);
            });
        }

        window.addEventListener("load", () => {
            window.scrollTo(0, 0);

            const pageContainer = document.getElementById("page-container");
            if (pageContainer) pageContainer.scrollTop = 0;
        });


        window.addEventListener("load", () => {
            setupDrawingEngine();
            setupMobileDrawingGestures();
            setupQuarterInchSteppers();
            initFieldHelp();
        });




        function initFieldHelp() {
            const modal = document.getElementById("helpModal");
            const titleEl = document.getElementById("helpModalTitle");
            const bodyEl = document.getElementById("helpModalBody");
            const imgEl = document.getElementById("helpModalImg");

            if (!modal || !titleEl || !bodyEl || !imgEl) return;

            function openHelpFrom(btn) {
                const title = btn.getAttribute("data-help-title") || "info";
                const html = btn.getAttribute("data-help-html") || "";
                const body = btn.getAttribute("data-help-body") || "";
                const img = btn.getAttribute("data-help-img") || "";

                titleEl.textContent = title;
                if (html) {
                    bodyEl.innerHTML = html;
                } else {
                    bodyEl.innerHTML = body.replace(/\n/g, "<br>");
                }



                if (html) {
                    imgEl.removeAttribute("src");
                    imgEl.style.display = "none";
                } else if (img) {
                    imgEl.src = img;
                    imgEl.style.display = "block";
                } else {
                    imgEl.removeAttribute("src");
                    imgEl.style.display = "none";
                }


                modal.classList.remove("hidden");
            }

            function closeHelp() {
                modal.classList.add("hidden");
                imgEl.removeAttribute("src");
                imgEl.style.display = "none";
            }
            document.addEventListener("click", (e) => {
                // 1) Click on the ? icon
                const helpBtn = e.target.closest(".help-icon");
                if (helpBtn) {
                    e.preventDefault();
                    openHelpFrom(helpBtn);
                    return;
                }

                // 2) Click on the label text that HAS a help icon
                const helpLabel = e.target.closest(".label-with-help");
                if (helpLabel && !e.target.closest("select") && !e.target.closest("input")) {
                    const btn = helpLabel.querySelector(".help-icon");
                    if (btn) {
                        e.preventDefault();
                        openHelpFrom(btn);
                        return;
                    }
                }

                // 3) Close modal
                const closeTarget = e.target.closest("[data-help-close='1']");
                if (closeTarget) {
                    e.preventDefault();
                    closeHelp();
                }
            });


            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && !modal.classList.contains("hidden")) {
                    closeHelp();
                }
            });
        }


    </script>

    <!-- PRICE BREAKDOWN MODAL -->
    <div id="price-modal" class="price-modal hidden">
        <div class="price-modal-backdrop"></div>

        <div class="price-modal-card">
            <h3>price breakdown</h3>

            <div id="price-breakdown-content"></div>

            <button class="price-modal-close">close</button>
        </div>
    </div>

    <div id="helpModal" class="help-modal hidden">
        <div class="help-modal-backdrop" data-help-close="1"></div>

        <div class="help-modal-card" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
            <h3 id="helpModalTitle" class="help-modal-title"></h3>

            <img id="helpModalImg" class="help-modal-img" alt="example image" />

            <p id="helpModalBody" class="help-modal-body"></p>

            <button type="button" class="help-modal-close" data-help-close="1">close</button>
        </div>
    </div>


</body>

</html>
